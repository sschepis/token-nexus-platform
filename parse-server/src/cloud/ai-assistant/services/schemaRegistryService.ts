// parse-server/src/cloud/ai-assistant/services/schemaRegistryService.ts
import { SchemaDefinition, SchemaProperty } from '../../../../../src/ai-assistant/types';
// import Parse from 'parse-server'; // Might be needed if schemas are stored in Parse Objects

// Placeholder for where schemas might be stored or how they are discovered.
// This could be a configuration file, fetched from a database,
// or dynamically generated by inspecting Parse.Schema or other data sources.
const inMemorySchemas: Map<string, SchemaDefinition> = new Map();

export class SchemaRegistryService {
  constructor() {
    console.log("SchemaRegistryService initialized");
    // Preload some example schemas
    this.loadExampleSchemas();
  }

  private loadExampleSchemas(): void {
    const userSchema: SchemaDefinition = {
      apiName: "User",
      label: "User",
      description: "Represents a user in the system.",
      properties: {
        objectId: { apiName: "objectId", label: "User ID", type: "string", description: "The unique identifier for the user." },
        username: { apiName: "username", label: "Username", type: "string", description: "The user's login name." },
        email: { apiName: "email", label: "Email", type: "string", description: "The user's email address." },
        firstName: { apiName: "firstName", label: "First Name", type: "string", required: false },
        lastName: { apiName: "lastName", label: "Last Name", type: "string", required: false },
        roles: { apiName: "roles", label: "Roles", type: "array", itemType: "string", description: "Roles assigned to the user."}
      },
      availableActions: ["read", "list"] // Example actions
    };
    inMemorySchemas.set(userSchema.apiName, userSchema);

    const taskSchema: SchemaDefinition = {
      apiName: "Task",
      label: "Task",
      description: "Represents a task or to-do item.",
      properties: {
        objectId: { apiName: "objectId", label: "Task ID", type: "string" },
        title: { apiName: "title", label: "Title", type: "string", required: true },
        description: { apiName: "description", label: "Description", type: "string", required: false },
        status: { 
          apiName: "status", 
          label: "Status", 
          type: "enum", 
          options: [
            { label: "Pending", value: "pending" }, 
            { label: "In Progress", value: "in_progress" },
            { label: "Completed", value: "completed" }
          ],
          required: true 
        },
        assignee: { apiName: "assignee", label: "Assignee", type: "reference", referenceTo: "User", description: "User assigned to this task."}
      },
      availableActions: ["create", "read", "update", "delete", "list"]
    };
    inMemorySchemas.set(taskSchema.apiName, taskSchema);
    console.log("SchemaRegistryService: Example schemas loaded.");
  }

  /**
   * Retrieves the schema definition for a given entity API name.
   * @param entityApiName The API name of the entity.
   * @returns The schema definition or null if not found.
   */
  async getSchema(entityApiName: string): Promise<SchemaDefinition | null> {
    console.log(`SchemaRegistryService: Getting schema for "${entityApiName}"`);
    // In a real implementation, this might query Parse.Schema for Custom Objects,
    // or fetch from a dedicated schema store.
    const schema = inMemorySchemas.get(entityApiName);
    if (schema) {
      return Promise.resolve(schema);
    }

    // Example: Dynamically fetch Parse.Schema if not in memory (conceptual)
    /*
    try {
      const parseSchema = new Parse.Schema(entityApiName);
      const schemaJson = await parseSchema.get({ useMasterKey: true }); // Requires master key
      if (schemaJson && schemaJson.fields) {
        const properties: Record<string, SchemaProperty> = {};
        for (const fieldName in schemaJson.fields) {
          const field = schemaJson.fields[fieldName];
          properties[fieldName] = {
            apiName: fieldName,
            label: fieldName, // Could be improved with a display name convention
            type: this.mapParseTypeToSchemaType(field.type, field.targetClass),
            required: field.required || false,
            referenceTo: field.targetClass,
          };
        }
        const dynamicSchema: SchemaDefinition = {
          apiName: entityApiName,
          label: entityApiName, // Improve with display name
          properties: properties,
          availableActions: ["create", "read", "update", "delete", "list"] // Default actions
        };
        inMemorySchemas.set(entityApiName, dynamicSchema); // Cache it
        return dynamicSchema;
      }
    } catch (error) {
      console.warn(`SchemaRegistryService: Could not dynamically fetch schema for "${entityApiName}":`, error);
    }
    */
    return Promise.resolve(null);
  }

  // private mapParseTypeToSchemaType(parseType: string, targetClass?: string): SchemaProperty['type'] {
  //   switch (parseType) {
  //     case 'String': return 'string';
  //     case 'Number': return 'number';
  //     case 'Boolean': return 'boolean';
  //     case 'Date': return 'datetime'; // Or 'date' if only date part
  //     case 'Pointer': return targetClass ? 'reference' : 'string'; // Pointer to what?
  //     case 'Relation': return 'array'; // Typically array of references
  //     case 'Array': return 'array';
  //     case 'Object': return 'object';
  //     default: return 'string'; // Fallback
  //   }
  // }

  /**
   * Lists all available entity API names for which schemas can be retrieved.
   * @returns An array of entity API names.
   */
  async listAvailableEntities(): Promise<string[]> {
    // This would list entities from all configured/discovered sources.
    const entityNames = Array.from(inMemorySchemas.keys());
    console.log(`SchemaRegistryService: Listing available entities: ${entityNames.join(', ')}`);
    return Promise.resolve(entityNames);
    // Example: Could also query Parse.Schema.all() and merge
  }

  /**
   * Registers or updates a schema definition.
   * Useful for dynamic schema loading or manual configuration.
   */
  async registerSchema(schema: SchemaDefinition): Promise<void> {
    inMemorySchemas.set(schema.apiName, schema);
    console.log(`SchemaRegistryService: Schema "${schema.apiName}" registered/updated.`);
    return Promise.resolve();
  }
}