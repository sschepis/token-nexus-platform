{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/facets/CollateralTokenFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utilities/Modifiers.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../tokens/CollateralTokenFactory.sol\";\nimport \"../tokens/RestrictedCollateralToken.sol\";\nimport \"../identity/IdentityStorage.sol\";\n\n/**\n * @title CollateralTokenFactoryFacet\n * @dev Diamond facet for creating and managing RestrictedCollateralToken instances\n */\ncontract CollateralTokenFactoryFacet is Modifiers {\n    // Event emitted when a new token is created\n    event CollateralTokenCreated(uint256 indexed tradeDealId, address indexed tokenAddress, string name, string symbol);\n    \n    // Event emitted when the factory is initialized\n    event CollateralTokenFactoryInitialized(address indexed factoryAddress);\n    \n    // Storage structure for the CollateralTokenFactoryFacet\n    struct CollateralTokenFactoryStorage {\n        address factoryAddress;\n        mapping(uint256 => address) tradeDealToToken;\n    }\n    \n    // Returns the storage slot for the CollateralTokenFactoryStorage\n    function collateralTokenFactoryStorage() internal pure returns (CollateralTokenFactoryStorage storage ds) {\n        bytes32 position = keccak256(\"collateral.collateralTokenFactory.storage\");\n        assembly {\n            ds.slot := position\n        }\n    }\n    \n    /**\n     * @dev Constructor - initializes the factory\n     * This is automatically called when the facet is added to the diamond\n     */\n    function CollateralTokenFactoryFacet_init() external {\n        require(collateralTokenFactoryStorage().factoryAddress == address(0), \"CollateralTokenFactoryFacet: already initialized\");\n        // Create a new CollateralTokenFactory\n        RestrictedCollateralToken implementation = new RestrictedCollateralToken();\n        CollateralTokenFactory factory = new CollateralTokenFactory(address(implementation));\n        \n        // Set the factory address\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        ds.factoryAddress = address(factory);\n        \n        // Emit event\n        emit CollateralTokenFactoryInitialized(address(factory));\n    }\n    \n    /**\n     * @dev Get the CollateralTokenFactory contract address\n     * @return The address of the CollateralTokenFactory contract (automatically created in the constructor)\n     */\n    function getCollateralTokenFactory() external view returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        return ds.factoryAddress;\n    }\n    \n    /**\n     * @dev Create a new RestrictedCollateralToken for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @return The address of the new token\n     */\n    function createCollateralToken(\n        uint256 _tradeDealId,\n        string memory _name,\n        string memory _symbol,\n        bool _restrictionsEnabled\n    ) external onlyOwner returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Check if the factory is set\n        require(ds.factoryAddress != address(0), \"CollateralTokenFactoryFacet: factory not set\");\n        \n        // Check if a token already exists for this trade deal\n        require(ds.tradeDealToToken[_tradeDealId] == address(0), \"CollateralTokenFactoryFacet: token already exists for this trade deal\");\n        \n        // Create the token\n        address tokenAddress = CollateralTokenFactory(ds.factoryAddress).createToken(\n            _name,\n            _symbol,\n            msg.sender, // Use the caller's address as the diamond address\n            _tradeDealId,\n            _restrictionsEnabled\n        );\n        \n        // Store the token address\n        ds.tradeDealToToken[_tradeDealId] = tokenAddress;\n        \n        // Emit an event\n        emit CollateralTokenCreated(_tradeDealId, tokenAddress, _name, _symbol);\n        \n        return tokenAddress;\n    }\n    \n    /**\n     * @dev Get the token address for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @return The address of the token\n     */\n    function getCollateralTokenAddress(uint256 _tradeDealId) external view returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // First check the local mapping\n        if (ds.tradeDealToToken[_tradeDealId] != address(0)) {\n            return ds.tradeDealToToken[_tradeDealId];\n        }\n        \n        // If not found locally, check the factory\n        if (ds.factoryAddress != address(0)) {\n            return CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        return address(0);\n    }\n    \n    /**\n     * @dev Set restrictions for a token\n     * @param _tradeDealId The ID of the trade deal\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     */\n    function setCollateralTokenRestrictions(uint256 _tradeDealId, bool _restrictionsEnabled) external onlyOwner {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Get the token address\n        address tokenAddress = ds.tradeDealToToken[_tradeDealId];\n        if (tokenAddress == address(0) && ds.factoryAddress != address(0)) {\n            tokenAddress = CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        // Check if the token exists\n        require(tokenAddress != address(0), \"CollateralTokenFactoryFacet: token does not exist for this trade deal\");\n        \n        // Set the restrictions\n        RestrictedCollateralToken(tokenAddress).setRestrictionsEnabled(_restrictionsEnabled);\n    }\n    \n    /**\n     * @dev Check if an address is a participant in a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @param _address The address to check\n     * @return Whether the address is a participant\n     */\n    function isCollateralTokenParticipant(uint256 _tradeDealId, address _address) external view returns (bool) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Get the token address\n        address tokenAddress = ds.tradeDealToToken[_tradeDealId];\n        if (tokenAddress == address(0) && ds.factoryAddress != address(0)) {\n            tokenAddress = CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        // Check if the token exists\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n        \n        // Check if the address is a participant\n        return RestrictedCollateralToken(tokenAddress).isParticipant(_address);\n    }\n}"
    },
    "contracts/identity/IdentityStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721A.sol\";\nimport {TrustedIssuer} from \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport {IIdentity} from \"../interfaces/IIdentity.sol\";\nimport {Claim} from \"../interfaces/IClaim.sol\";\nimport \"../interfaces/IMarketplace.sol\";\nimport {MultiSaleStorage} from \"../interfaces/IMultiSale.sol\";\nimport \"../libraries/TradeDealLib.sol\";\nimport \"../libraries/FeeDistributorLib.sol\"; // Add import for FeeDistributorLib\n\nimport \"hardhat/console.sol\";\n\nlibrary IdentitySystemStorage {\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n    using Address for address;\nbytes32 internal constant MULTISALE_STORAGE_POSITION =\n        keccak256(\"diamond.nextblock.bitgem.app.MultiSaleStorage.storage\");\n\n    function multiSaleStorage()\n        internal\n        pure\n        returns (MultiSaleStorage storage ds)\n    {\n        bytes32 position = MULTISALE_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    // CollateralStorage struct definition\n    struct CollateralStorage {\n        address nft;\n        address invoicePool;\n        address vabb;\n        address usdcPool;\n        address interest;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n    }\n\n    error ApprovalCallerNotOwnerNorApproved();\n    error ApprovalQueryForNonexistentToken();\n    error ApproveToCaller();\n    error ApprovalToCurrentOwner();\n    error BalanceQueryForZeroAddress();\n    error MintedQueryForZeroAddress();\n    error BurnedQueryForZeroAddress();\n    error AuxQueryForZeroAddress();\n    error MintToZeroAddress();\n    error MintZeroQuantity();\n    error OwnerIndexOutOfBounds();\n    error OwnerQueryForNonexistentToken();\n    error TokenIndexOutOfBounds();\n    error TransferCallerNotOwnerNorApproved();\n    error TransferFromIncorrectOwner();\n    error TransferToNonERC721ReceiverImplementer();\n    error TransferToZeroAddress();\n    error URIQueryForNonexistentToken();\n\n    struct IdentitySystem {\n        // ERC721A storage\n        ERC721AContract erc721Contract;\n        // TrustedIssuer storage\n        mapping(address => TrustedIssuer) trustedIssuers;\n        address[] trustedIssuerAddresses;\n        mapping(address => mapping(uint256 => bool)) trustedIssuerClaimTopics;\n        mapping(address => uint256[]) trustedIssuerClaimTopicsList;\n        mapping(uint256 => bool) topics;\n        uint256[] topicList;\n        // Identity storage\n        mapping(address => address) identities;\n        mapping(address => address) identityOwnersMap;\n        address[] identityOwners;\n        // Claim storage\n        mapping(address => mapping(uint256 => uint256)) claims;\n        mapping(address => uint256[]) claimList;\n        // Claim storage\n        mapping(uint256 => Claim) tokenClaims;\n        Claim[] tokenClaimList;\n        // ERC721Permissioned storage\n        address delegatedMinter;\n        mapping(uint256 => bool) frozen;\n\n        uint256 itemIds;\n        uint256 itemsSold;\n        mapping(uint256 => MarketItem) idToMarketItem;\n        mapping(uint256 => bool) idToListed;\n        MarketItem[] items;\n\n        // Merkle proof tracking for MultiSale\n        mapping(bytes32 => bool) usedMerkleLeaves;\n        \n        // Collateral storage\n        CollateralStorage collateralStorage;\n        \n        // Trade Deal storage\n        TradeDealLib.TradeDealStorage tradeDealStorage;\n\n        // Fee Distributor storage\n        FeeDistributorLib.FeeDistributorStorage feeDistributorStorage;\n    }\n\n    bytes32 constant IDENTITY_SYSTEM_STORAGE_POSITION =\n        keccak256(\"diamond.identity.system.storage\");\n\n    function diamondStorage()\n        internal\n        pure\n        returns (IdentitySystemStorage.IdentitySystem storage ds)\n    {\n        bytes32 position = IDENTITY_SYSTEM_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function _tokenExists(\n        IdentitySystem storage self,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        return self.erc721Contract._ownerships[_tokenId].addr != address(0);\n    }\n\n    function _getIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (address addr) {\n        return self.identities[_userAddress];\n    }\n\n    function getIdentityOwner(\n        IdentitySystem storage self,\n        address _identity\n    ) internal view returns (address) {\n        return self.identityOwnersMap[_identity];\n    }\n\n    function isIdentityAddress(\n        IdentitySystem storage self,\n        address _identity\n    ) internal view returns (bool) {\n        return self.identityOwnersMap[_identity] != address(0);\n    }\n\n    function isRegistered(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return self.identities[_userAddress] != address(0);\n    }\n\n    function isIdentityOwner(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return\n            self.identityOwnersMap[self.identities[_userAddress]] ==\n            _userAddress;\n    }\n\n    // trusted issuer\n\n    function isTrustedIssuer(\n        IdentitySystem storage self,\n        address _issuer\n    ) internal view returns (bool) {\n        return self.trustedIssuers[_issuer].claimIssuer != address(0);\n    }\n\n    function addTrustedIssuer(\n        IdentitySystem storage self,\n        address _trustedIssuer,\n        uint[] calldata _claimTopics\n    ) internal {\n        self.trustedIssuers[_trustedIssuer] = TrustedIssuer({\n            claimIssuer: _trustedIssuer,\n            claimTopics: _claimTopics\n        });\n        self.trustedIssuerAddresses.push(_trustedIssuer);\n    }\n\n    function removeTrustedIssuer(\n        IdentitySystem storage self,\n        address _trustedIssuer\n    ) internal {\n        delete self.trustedIssuers[_trustedIssuer];\n        for (uint256 i = 0; i < self.trustedIssuerAddresses.length; i++) {\n            if (self.trustedIssuerAddresses[i] == _trustedIssuer) {\n                self.trustedIssuerAddresses[i] = self.trustedIssuerAddresses[\n                    self.trustedIssuerAddresses.length - 1\n                ];\n                self.trustedIssuerAddresses.pop();\n                break;\n            }\n        }\n    }\n\n    // claim topics\n\n    function addClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal {\n        self.topics[_claimTopic] = true;\n        self.topicList.push(_claimTopic);\n    }\n\n    function removeClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal {\n        delete self.topics[_claimTopic];\n        for (uint256 i = 0; i < self.topicList.length; i++) {\n            if (self.topicList[i] == _claimTopic) {\n                self.topicList[i] = self.topicList[self.topicList.length - 1];\n                self.topicList.pop();\n                break;\n            }\n        }\n    }\n\n    function getClaimTopics(\n        IdentitySystem storage self\n    ) internal view returns (uint256[] memory) {\n        return self.topicList;\n    }\n\n    function hasClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal view returns (bool) {\n        return self.topics[_claimTopic];\n    }\n\n    // trusted issuer / claim topics\n\n    function updateIssuerClaimTopics(\n        IdentitySystem storage self,\n        address _trustedIssuer,\n        uint[] calldata _claimTopics\n    ) internal {\n        self.trustedIssuers[_trustedIssuer].claimTopics = _claimTopics;\n        for (\n            uint256 i = 0;\n            i < self.trustedIssuerClaimTopicsList[_trustedIssuer].length;\n            i++\n        ) {\n            delete self.trustedIssuerClaimTopics[_trustedIssuer][\n                self.trustedIssuerClaimTopicsList[_trustedIssuer][i]\n            ];\n        }\n    }\n\n    function addTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint _claimTopic\n    ) internal {\n        self.trustedIssuerClaimTopics[_issuer][_claimTopic] = true;\n        self.trustedIssuerClaimTopicsList[_issuer].push(_claimTopic);\n    }\n\n    function removeTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint _claimTopic\n    ) internal {\n        delete self.trustedIssuerClaimTopics[_issuer][_claimTopic];\n        for (\n            uint256 i = 0;\n            i < self.trustedIssuerClaimTopicsList[_issuer].length;\n            i++\n        ) {\n            if (self.trustedIssuerClaimTopicsList[_issuer][i] == _claimTopic) {\n                self.trustedIssuerClaimTopicsList[_issuer][i] = self\n                    .trustedIssuerClaimTopicsList[_issuer][\n                        self.trustedIssuerClaimTopicsList[_issuer].length - 1\n                    ];\n                self.trustedIssuerClaimTopicsList[_issuer].pop();\n                break;\n            }\n        }\n    }\n\n    modifier isTrustedIssuerForClaimTopic(uint256 _claimTopic) {\n        IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.isTrustedIssuer(msg.sender), \"Not a trusted issuer\");\n        require(\n            _storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopic),\n            \"Issuer not authorized for claim topic\"\n        );\n        _;\n    }\n\n    function hasTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint256 _claimTopic\n    ) internal view returns (bool) {\n        if (!self.isTrustedIssuer(_issuer)) return false;\n        uint256[] storage claimTopics = self\n            .trustedIssuers[_issuer]\n            .claimTopics;\n        for (uint256 i = 0; i < claimTopics.length; i++) {\n            if (claimTopics[i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function addIdentity(\n        IdentitySystem storage self,\n        address _userAddress,\n        address _identity\n    ) internal {\n        self.identities[_userAddress] = _identity;\n        self.identityOwners.push(_userAddress);\n        self.identityOwnersMap[_identity] = _userAddress;\n    }\n\n    function removeIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal {\n        address identityAddress = self.identities[_userAddress]; // Capture identity address before deletion\n        delete self.identities[_userAddress];\n        for (uint256 i = 0; i < self.identityOwners.length; i++) {\n            if (self.identityOwners[i] == _userAddress) {\n                self.identityOwners[i] = self.identityOwners[\n                    self.identityOwners.length - 1\n                ];\n                self.identityOwners.pop();\n                self.identityOwnersMap[identityAddress] = address(0); // Use captured identityAddress\n                break;\n            }\n        }\n    }\n\n    function hasIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        address identity = self.identities[_userAddress];\n        return identity != address(0);\n    }\n\n    function hasClaims(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return self.identities[_userAddress] != address(0);\n    }\n\n    function isVerified(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return hasIdentity(self, _userAddress) && hasClaims(self, _userAddress);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        IdentitySystem storage self,\n        address msgSender,\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        uint256 startTokenId = self.erc721Contract._currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        self._beforeTokenTransfer(address(0), to, startTokenId, true);\n\n        unchecked {\n            self.erc721Contract._addressData[to].balance += uint64(quantity);\n            self.erc721Contract._addressData[to].numberMinted += uint64(quantity);\n\n            self.erc721Contract._ownerships[startTokenId].addr = to;\n            self.erc721Contract._ownerships[startTokenId].startTimestamp = uint64(\n                block.timestamp\n            );\n\n            uint256 updatedIndex = startTokenId;\n\n            // log quantity\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (\n                    safe &&\n                    !_checkOnERC721Received(\n                        msgSender,\n                        address(0),\n                        to,\n                        updatedIndex,\n                        _data\n                    )\n                ) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                }\n                self.erc721Contract._currentIndex = updatedIndex + 1;\n                updatedIndex++;\n                self._addTokenToAllTokensEnumeration(updatedIndex); // Add this line\n            }\n        }\n\n        _afterTokenTransfer(self, address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint64) {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        return self.erc721Contract._addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(\n        IdentitySystem storage self,\n        address owner,\n        uint64 aux\n    ) internal {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        self.erc721Contract._addressData[owner].aux = aux;\n    }\n\n    function ownershipOf(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n        unchecked {\n            if (curr < self.erc721Contract._currentIndex) {\n                TokenOwnership memory ownership = self.erc721Contract._ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = self.erc721Contract._ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (bool) {\n        return\n            tokenId < self.erc721Contract._currentIndex && !self.erc721Contract._ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (address) {\n        if (!_exists(self, tokenId)) revert ApprovalQueryForNonexistentToken();\n        return self.erc721Contract._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(\n        IdentitySystem storage self,\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        self.erc721Contract._operatorApprovals[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        IdentitySystem storage self,\n        address owner,\n        address operator\n    ) internal view returns (bool) {\n        return self.erc721Contract._operatorApprovals[owner][operator];\n    }\n\n    function currentIndex(\n        IdentitySystem storage self\n    ) internal view returns (uint256) {\n        return self.erc721Contract._currentIndex;\n    }\n    \n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        IdentitySystem storage self,\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bool _force\n    ) internal {\n        TokenOwnership memory prevOwnership = self.ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (msgSender == prevOwnership.addr ||\n            self.isApprovedForAll(prevOwnership.addr, msgSender) ||\n            self.getApproved(tokenId) == msgSender);\n\n        if (!isApprovedOrOwner && !_force)\n            revert TransferCallerNotOwnerNorApproved();\n        if (prevOwnership.addr != from && !_force) revert TransferFromIncorrectOwner();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        self._beforeTokenTransfer(from, to, tokenId, _force);\n\n        if (from == address(0)) {\n            self._addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            self._removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            self._removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            self._addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        // Clear approvals from the previous owner\n        self._approve(address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self.erc721Contract._addressData[from].balance -= 1;\n            self.erc721Contract._addressData[to].balance += 1;\n\n            self.erc721Contract._ownerships[tokenId].addr = to;\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self.erc721Contract._currentIndex) {\n                    self.erc721Contract._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = prevOwnership\n                        .startTimestamp;\n                }\n            }\n        }\n        \n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(self, from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(IdentitySystem storage self, address from, uint256 tokenId) internal {\n        self._beforeTokenTransfer(from, address(0), tokenId, true);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, from);\n\n        self._removeTokenFromOwnerEnumeration(from, tokenId);\n        self._removeTokenFromAllTokensEnumeration(tokenId);\n\n        unchecked {\n            self.erc721Contract._addressData[from].balance -= 1;\n            self.erc721Contract._addressData[from].numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            self.erc721Contract._ownerships[tokenId].addr = from;\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n            self.erc721Contract._ownerships[tokenId].burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self.erc721Contract._currentIndex) {\n                    self.erc721Contract._ownerships[nextTokenId].addr = from;\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = self.erc721Contract._ownerships[tokenId].startTimestamp;\n                }\n            }\n        }\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfer(self, from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self.erc721Contract._burnCounter++;\n        }\n    }\n\n    function exists(IdentitySystem storage self, uint256 tokenId) internal view returns (bool) {\n        return _exists(self, tokenId);\n    }\n\n\n    function setTokenClaimTopics(IdentitySystem storage self, uint256 tokenId, uint256[] memory claimTopics) internal {\n        require(self.exists(tokenId), \"ERC721: token does not exist\");\n        for (uint256 i = 0; i < claimTopics.length; i++) {\n            self.tokenClaims[tokenId] = Claim({\n                topic: claimTopics[i],\n                scheme: 0,\n                issuer: address(this),\n                signature: \"\",\n                data: \"\",\n                uri: \"\"\n            });\n        }\n    }\n\n    function getTokenClaimTopics(uint256 tokenId) public view returns (Claim[] memory) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(identitySystem._exists(tokenId), \"ERC721: token does not exist\");\n        Claim[] memory claimTopics = new Claim[](identitySystem.tokenClaimList.length);\n        for (uint256 i = 0; i < identitySystem.tokenClaimList.length; i++) {\n            claimTopics[i] = identitySystem.tokenClaims[tokenId];\n        }\n        return claimTopics;\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        IdentitySystem storage self,\n        address to,\n        uint256 tokenId,\n        address owner\n    ) internal {\n        self.erc721Contract._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function _ownerOf(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (address) {\n        return ownershipOf(self, tokenId).addr;\n    }\n\n    function _isContract(\n        address account\n    ) internal view returns (bool) {\n        // According to EIP-1052, an address is a contract if it has code.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (_isContract(to)) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msgSender,\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function tokensOfOwner(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256[] memory) {\n        require(owner != address(0), \"IdentityStorage: owner query for zero address\");\n        \n        uint256 ownerTokenCount = IERC721(address(this)).balanceOf(owner);\n        if (ownerTokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        }\n        \n        uint256[] memory tokens = new uint256[](ownerTokenCount);\n        for (uint256 i = 0; i < ownerTokenCount; i++) {\n            tokens[i] = self.erc721Contract._ownedTokens[owner][i];\n        }\n        \n        return tokens;\n    }\n\n    function tokenOfOwnerByIndex(\n        IdentitySystem storage self,\n        address owner, \n        uint256 index) internal view returns (uint256) {\n        require(index < IERC721(address(this)).balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return self.erc721Contract._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply(\n        IdentitySystem storage self\n    ) internal view returns (uint256) {\n        return self.erc721Contract._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(\n        IdentitySystem storage self,\n        uint256 index\n    ) internal view returns (uint256) {\n        require(index < totalSupply(self), \"ERC721Enumerable: global index out of bounds\");\n        return self.erc721Contract._allTokens[index];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(\n        IdentitySystem storage self,\n        address to, \n        uint256 tokenId) internal {\n        uint256 length = IERC721(address(this)).balanceOf(to);\n        self.erc721Contract._ownedTokens[to][length] = tokenId;\n        self.erc721Contract._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(\n        IdentitySystem storage self,\n        uint256 tokenId) internal {\n        self.erc721Contract._allTokensIndex[tokenId] = self.erc721Contract._allTokens.length + 1;\n        self.erc721Contract._allTokens.push(tokenId);\n    }\n\n    function _getIdentityAddress(IdentitySystem storage self, address _address) internal view returns (address) {\n        address identityAddress = self._getIdentity(_address);\n        return identityAddress != address(0) ? identityAddress : _address;\n    }\n\n    function _hasClaim(IdentitySystem storage self, address _address, uint256 _claimTopic) internal view returns (bool) {\n        address idObj = self._getIdentityAddress(_address);\n        for (uint256 i = 0; i < self.claimList[idObj].length; i++) {\n            if (self.claimList[idObj][i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(\n        IdentitySystem storage self,\n        address from,\n        uint256 tokenId\n    ) internal {\n        // address owner = IERC721(address(this)).ownerOf(tokenId);\n        address thisAddress = address(this);\n\n\n        // require(owner == thisAddress, \"ERC721: transfer of token that is not own\");\n        uint256 lastTokenIndex = IERC721(thisAddress).balanceOf(from) - 1; \n        uint256 tokenIndex = self.erc721Contract._ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = self.erc721Contract._ownedTokens[from][lastTokenIndex];\n\n            self.erc721Contract._ownedTokens[from][tokenIndex] = lastTokenId;\n            self.erc721Contract._ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete self.erc721Contract._ownedTokensIndex[tokenId];\n        delete self.erc721Contract._ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = self.erc721Contract._allTokens.length - 1;\n        uint256 tokenIndex = self.erc721Contract._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = self.erc721Contract._allTokens[lastTokenIndex];\n\n        self.erc721Contract._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        self.erc721Contract._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete self.erc721Contract._allTokensIndex[tokenId];\n        self.erc721Contract._allTokens.pop();\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n\n    function _beforeTokenTransfer(\n        IdentitySystem storage self,\n        address from,\n        address to,\n        uint256,\n        bool force\n    ) internal view {\n        // Allow transfers from or to the contract itself without additional checks\n        if(force) return;\n\n        bool hasCommonClaim = false;\n        uint256 claimType = 1; // Start from claim type 1\n\n        while (!hasCommonClaim) {\n            bool hasFromClaim = self._hasClaim(from, claimType) ||\n                from == address(this);\n            if (hasFromClaim && self._hasClaim(to, claimType)) {\n                hasCommonClaim = true;\n            } else {\n                claimType++;\n                if (claimType == 0) {\n                    // Overflow, we've checked all possible claim types\n                    break;\n                }\n            }\n        }\n\n        require(\n            hasCommonClaim,\n            \"ERC721: sender and receiver do not have a common claim\"\n        );\n    }\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfer(\n        IdentitySystem storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal {}\n}\n"
    },
    "contracts/interfaces/IAttribute.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nenum AttributeType {\r\n    Unknown,\r\n    String ,\r\n    Bytes32,\r\n    Uint256,\r\n    Uint8,\r\n    Uint256Array,\r\n    Uint8Array\r\n}\r\n\r\nstruct Attribute {\r\n    string key;\r\n    AttributeType attributeType;\r\n    string value;\r\n}\r\n\r\n// attribute storage\r\nstruct AttributeContract {\r\n    mapping(uint256 => bool)  burnedIds;\r\n    mapping(uint256 => mapping(string => Attribute))  attributes;\r\n    mapping(uint256 => string[]) attributeKeys;\r\n    mapping(uint256 =>  mapping(string => uint256)) attributeKeysIndexes;\r\n}\r\n\r\n\r\n/// @notice a pool of tokens that users can deposit into and withdraw from\r\ninterface IAttribute {\r\n    /// @notice get an attribute for a tokenid keyed by string\r\n    function getAttribute(\r\n        uint256 id,\r\n        string memory key\r\n    ) external view returns (Attribute calldata _attrib);\r\n}\r\n"
    },
    "contracts/interfaces/IClaim.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n}"
    },
    "contracts/interfaces/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IIdentity.sol\";\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n    bool isRemoved;\n}\n\ninterface IClaimIssuer is IIdentity {\n\n    event ClaimRevoked(bytes indexed signature);\n\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n    function revokeClaimBySignature(bytes calldata signature) external;\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\n    \n}"
    },
    "contracts/interfaces/ICollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICollateral {\n    function mint(address to, uint256 amount) external;\n    function burn(address from, uint256 amount) external;\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Propose an upgrade to be executed after the timelock period\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    function proposeDiamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Execute a previously proposed upgrade after the timelock period\r\n    function executeDiamondCut() external;\r\n    \r\n    /// @notice Cancel a proposed upgrade\r\n    function cancelDiamondCut() external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n    event DiamondCutProposed(address indexed proposer, uint256 indexed proposalTime, uint256 executionTime);\r\n    event DiamondCutCancelled(address indexed canceller);\r\n}\r\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/* solhint-disable indent */\n\n// Compiler will pack this into a single 256bit word.\nstruct TokenOwnership {\n    address addr; // The address of the owner.\n    uint64 startTimestamp; // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n    bool burned; // Whether the token has been burned.\n}\n\n// Compiler will pack this into a single 256bit word.\nstruct AddressData {\n    \n    uint64 balance; // Realistically, 2**64-1 is more than enough.\n    uint64 numberMinted; // Keeps track of mint count with minimal overhead for tokenomics.\n    uint64 numberBurned; // Keeps track of burn count with minimal overhead for tokenomics.\n    // For miscellaneous variable(s) pertaining to the address\n    // (e.g. number of whitelist mint slots used).\n    // If there are multiple variables, please pack them into a uint64.\n    uint64 aux;\n}\n\nstruct ERC721AContract {\n    // The tokenId of the next token to be minted.\n    uint256 _currentIndex;\n\n    // The number of tokens burned.\n    uint256 _burnCounter;\n\n    // Token name\n    string _name;\n\n    // Token symbol\n    string _symbol;\n\n    // the base uri\n    string __uri;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) _operatorApprovals;\n    \n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) _allTokensIndex;\n}\n\n/// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\nevent Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n);\n\n/// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\nevent ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n);\n\n/**\n * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n */\nevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n"
    },
    "contracts/interfaces/IERC721Permissioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC721Permissioned {\n\n    event TransferForced(address indexed from, address indexed to, uint256 indexed tokenId);\n    event DelegatedMinterSet(address indexed newDelegatedMinter);\n    event Mint(address indexed to, uint256 indexed tokenId);\n    event Burn(address indexed from, uint256 indexed tokenId);\n    event Freeze(address indexed from, uint256 indexed tokenId);\n    event FreezeBatch(address indexed from, uint256[] tokenIds);\n    event Release(address indexed from, uint256 indexed tokenId);\n\n    // force a transfer from the user to the to address irrepective of registry\n    // TODO: Does this mean that the transfer will go even if both addresses aren't\n    //      registered? If so, this is a security issue.\n    function forcedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external returns (bool);\n\n    function setDelegatedMinter(address _newDelegatedMinter) external returns (bool);\n    function delegatedMinter() external view returns (address);\n\n    function mint(address _to, bytes calldata data) external returns (uint256);\n    function burn(uint256 _tokenId) external returns (bool);\n\n    function freeze(uint256 tokenID) external;\n    function release(uint256 tokenID) external;\n\n}\n"
    },
    "contracts/interfaces/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\ninterface IERC734 is IERC165 {\n    // events\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(\n        uint256 indexed executionId,\n        address indexed to,\n        uint256 indexed value,\n        bytes data\n    );\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    // functions\n    // setters\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external;\n    function removeKey(bytes32 _key, uint256 _purpose) external;\n    function approve(uint256 _id, bool _approve) external;\n\n    // getters\n    function getKey(bytes32 _key) external view returns(uint256[] memory purposes, uint256 keyType, bytes32 key);\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory);\n    function getKeysByPurpose(uint256 _purpose) external view returns(bytes32[] memory);\n    function getExecution(uint256 _id) external view returns(address to, uint256 value, bytes memory data, bool approved, uint256 executionType);\n}\n"
    },
    "contracts/interfaces/IERC735.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IERC735 {\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    function getClaim(bytes32 _claimId) external returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\n    function getClaimIdsByTopic(uint256 _topic) external returns(bytes32[] memory claimIds);\n    function addClaim(\n        uint256 _topic, \n        uint256 _scheme, \n        address _issuer, \n        bytes memory _signature, \n        bytes memory _data, \n        string memory _uri) external returns (uint256 claimRequestId);\n    function changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (bool success);\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n}\n\n/*\nHow IdentityRegistry works:\n\n1. User creates an Identity contract\n2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData)\n3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity)\n4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim)\n5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID)\n\n*/"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IFeeDistributor\n * @dev Interface for a fee distribution system.\n */\ninterface IFeeDistributor {\n    /**\n     * @notice Sets the addresses that will receive fees and their corresponding weights.\n     * @dev Weights determine the proportion of fees each receiver gets.\n     * @param _feeReceivers Array of addresses to receive fees.\n     * @param _feeWeights Array of weights corresponding to each receiver. Must sum to a specific value (e.g., 10000 for basis points).\n     */\n    function setFeeReceivers(\n        address[] calldata _feeReceivers,\n        uint256[] calldata _feeWeights\n    ) external;\n\n    /**\n     * @notice Gets the current fee receivers and their weights.\n     * @return feeReceivers Array of addresses currently set to receive fees.\n     * @return feeWeights Array of weights corresponding to each receiver.\n     */\n    function getFeeReceivers()\n        external\n        view\n        returns (\n            address[] memory feeReceivers,\n            uint256[] memory feeWeights\n        );\n\n    /**\n     * @notice Calculates the adjusted principal amount and individual fee amounts based on the total principal.\n     * @dev This function is view-only and does not perform any state changes or transfers.\n     * @param principalAmount The total amount before fee deduction.\n     * @return adjustedAmount The principal amount remaining after deducting total fees.\n     * @return feeAmounts Array of individual fee amounts calculated for each receiver.\n     */\n    function calculateAmounts(uint256 principalAmount) \n        external\n        view\n        returns (\n            uint256 adjustedAmount,\n            uint256[] memory feeAmounts\n        );\n\n    /**\n     * @notice Distributes a principal amount, sending calculated fees to receivers and the adjusted amount to the principal receiver.\n     * @dev Requires the contract to hold sufficient funds (e.g., USDC) to perform the transfers.\n     * @param principalAmountReceiver The address to receive the adjusted principal amount.\n     * @param _principalAmount The total amount to be distributed.\n     * @return adjustedAmountReceiver The address that received the adjusted principal amount.\n     * @return adjustedAmount The adjusted principal amount transferred.\n     * @return feeReceivers The addresses that received the fee amounts.\n     * @return feeAmounts The individual fee amounts transferred.\n     */\n    function distributeAmounts(\n        address principalAmountReceiver,\n        uint256 _principalAmount\n    ) external returns (\n        address adjustedAmountReceiver,\n        uint256 adjustedAmount,\n        address[] memory feeReceivers,\n        uint256[] memory feeAmounts\n    );\n\n    /**\n     * @dev Emitted when the fee receivers and weights are updated.\n     * @param feeReceivers The new array of fee receiver addresses.\n     * @param feeWeights The new array of corresponding fee weights.\n     */\n    event FeeReceiversSet(\n        address[] feeReceivers,\n        uint256[] feeWeights\n    );\n\n    /**\n     * @dev Emitted when principal and fee amounts are successfully distributed.\n     * @param principalAmountReceiver The address that received the adjusted principal amount.\n     * @param principalAmount The original principal amount before fee deduction.\n     * @param adjustedAmountReceiver The address that received the adjusted principal amount (same as principalAmountReceiver).\n     * @param adjustedAmount The adjusted principal amount transferred.\n     * @param feeReceivers The addresses that received the fee amounts.\n     * @param feeAmounts The individual fee amounts transferred.\n     */\n    event AmountsDistributed(\n        address principalAmountReceiver,\n        uint256 principalAmount,\n        address adjustedAmountReceiver,\n        uint256 adjustedAmount,\n        address[] feeReceivers,\n        uint256[] feeAmounts\n    );\n\n    /**\n     * @dev Emitted when the Fee Distributor is initialized.\n     * @param distributionToken The address of the ERC20 token set for distribution.\n     * @param totalWeightBasis The basis used for calculating fee weights (e.g., 10000).\n     */\n    event FeeDistributorInitialized(\n        address indexed distributionToken,\n        uint256 totalWeightBasis\n    );\n}"
    },
    "contracts/interfaces/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC734 } from \"./IERC734.sol\";\nimport { IERC735 } from \"./IERC735.sol\";\n\ninterface IIdentity is IERC734, IERC735 {\n    function isVerified() external view returns (bool);\n    function getClaimTopics() external view returns (uint256[] memory);\n}"
    },
    "contracts/interfaces/IInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IInterest {\n    function mint(address to, uint256 amount) external;\n    function burn(address from, uint256 amount) external;\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Structure defining a fee receiver for marketplace sales\n * @param receiver The address that will receive the fee\n * @param sharePerMillion The fee share in parts per million (e.g., 10,000 = 1%)\n */\nstruct FeeReceiver {\n    address payable receiver;\n    uint256 sharePerMillion;\n}\n\nstruct MarketItem {\n    address nftContract;\n    uint256 tokenId;\n    address seller;\n    address owner;\n    uint256 price;\n    bool sold;\n    address receiver;\n    address paymentToken;\n}\n\ninterface IMarketplace {\n\n    event Bids(uint256 indexed itemId, address bidder, uint256 amount);\n    event Sales(address indexed tokenAddress, uint256 indexed tokenId, address indexed owner);\n\n    event Listings(\n        address indexed nftContract,\n        uint256 indexed tokenId,\n        address seller,\n        address receiver,\n        address owner,\n        uint256 price,\n        bool sold,\n        address paymentToken\n    );\n    event Delisted(uint256 indexed itemId);\n\n    function listItem(\n        address nftContract,\n        address payable receiver,\n        uint256 tokenId,\n        uint256 price,\n        bool transferNFT,\n        address paymentToken\n    ) external payable;\n\n    function delistItem(address nftContract, uint256 itemId) external;\n\n    function purchaseItem(address nftContract, uint256 itemId) external payable;\n\n    function fetchItems() external view returns (MarketItem[] memory);\n\n    function fetchItem(address nftContract, uint256 tokenId) external view returns (MarketItem memory);\n\n    function getMarketplaceFeeReceivers() external view returns (FeeReceiver[] memory);\n}\n"
    },
    "contracts/interfaces/IMultiSale.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { TokenType } from \"./IToken.sol\";\nimport { VariablePriceContract } from \"./IVariablePrice.sol\";\nimport { Attribute } from \"./IAttribute.sol\";\n\n/// @Nnotice the payment type for the token\nenum PaymentType {\n    Ether,\n    ERC20\n}\n\n/// @notice the multisale purchase\nstruct MultiSalePurchase {\n    uint256 multiSaleId;\n    address purchaser;\n    address receiver;\n    uint256 quantity;\n}\n    \n/// @notice the merkle proof for the token sale\nstruct MultiSaleProof {\n    uint256 leaf;\n    uint256 total;\n    bytes32[] merkleProof;\n    bytes data;\n}\n\nenum PaymentMethod {\n    Native, // Payment with the native currency (e.g., ETH)\n    ERC20 // Payment with an ERC20 token\n}\n\n/// @notice the settings for the token sale,\nstruct MultiSaleSettings {\n\n    TokenType tokenType; // the type of token being sold\n    address token; // the token being sold\n    uint256 tokenHash; // the token hash being sold. set to 0 to autocreate hash\n\n    uint256 whitelistHash; // the whitelist hash. set to 0 for owhitelist\n    bool whitelistOnly; // if true, only whitelisted addresses can purchase\n\n    PaymentMethod paymentMethod; // New field to indicate payment method\n    address paymentToken; // New field to store the ERC20 token address for payments\n\n    // owner and payee\n    address owner; // the owner of the contract\n    address payee; // the payee of the co ntract\n\n    string symbol; // the symbol of the token\n    string name; // the name of the token\n    string description; // the description of the token\n\n    // open state\n    bool openState; // open or closed\n    uint256 startTime; // block number when the sale starts\n    uint256 endTime; // block number when the sale ends\n\n    // quantitiesp\n    uint256 maxQuantity; // max number of tokens that can be sold\n    uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\n    uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\n    uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\n\n    PaymentType paymentType; // the type of payment that is being used\n    address tokenAddress; // the address of the payment token, if payment type is TOKEN\n\n    uint256 nextSaleId; // the next sale id\n    VariablePriceContract price; // the variable prices\n\n}\n\n/// @notice the multi sale contract\nstruct MultiSaleContract {\n    MultiSaleSettings settings;\n\n    uint256 nonce;\n    uint256 totalPurchased;\n        \n    mapping(address => uint256) purchased;\n    mapping(uint256 => uint256) _redeemedData;\n    mapping(address => uint256) _redeemedDataQuantities;\n    mapping(address => uint256) _totalDataQuantities;\n    mapping(address => uint256) _accountQuantities;\n}\n\n/// @notice the multi sale storage\nstruct MultiSaleStorage {\n    // the nonce\n    uint256 tsnonce;\n    mapping(uint256 => MultiSaleContract) _tokenSales; // token sale settings\n    uint256[] _tokenSaleIds;\n}\n\n\ninterface IMultiSale {\n\n    // @notice emitted when a token sale is created\n    event MultiSaleCreated(uint256 indexed tokenSaleId, MultiSaleSettings settings);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleOpen (uint256 indexed tokenSaleId, MultiSaleSettings tokenSale);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleClosed (uint256 indexed tokenSaleId);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleSold (uint256 indexed tokenSaleId, address indexed purchaser, uint256[] tokenIds, bytes data);\n\n    // token settings were updated\n    event MultiSaleUpdated (uint256 indexed tokenSaleId, MultiSaleSettings tokenSale );\n\n}\n"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice the definition for a token.\r\nstruct TokenDefinition {\r\n    address token;\r\n    string name;\r\n    string symbol;\r\n    string description;\r\n    uint256 totalSupply;\r\n    string imageName;\r\n    string[] imagePalette;\r\n    string externalUrl;\r\n}\r\n\r\nenum TokenType {\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}"
    },
    "contracts/interfaces/ITrustedIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"./IClaimIssuer.sol\";\n\nstruct TrustedIssuer {\n    address claimIssuer;\n    uint[] claimTopics;\n}\n\ninterface ITrustedIssuersRegistry {\n\n    // events\n    event TrustedIssuerAdded(address indexed trustedIssuer, uint[] claimTopics);\n    event TrustedIssuerRemoved(address indexed trustedIssuer);\n    event ClaimTopicsUpdated(address indexed trustedIssuer, uint[] claimTopics);\n\n    // functions\n    // setters\n    function addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external;\n    function removeTrustedIssuer(address _trustedIssuer) external;\n    function updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external;\n\n    // getters\n    function getTrustedIssuer(address issuerAddress) external view returns (TrustedIssuer memory);\n    function getTrustedIssuers() external view returns (TrustedIssuer[] memory);\n    function isTrustedIssuer(address _issuer) external view returns(bool);\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory);\n    function hasTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);\n\n}"
    },
    "contracts/interfaces/IUSDCPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUSDCPool {\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getBalance() external view returns (uint256);\n    function distributeInterest() external;\n}"
    },
    "contracts/interfaces/IVariablePrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\n/// @notice DIctates how the price of the token is increased post every sale\nenum PriceModifier {\n    None,\n    Fixed,\n    Exponential,\n    InverseLog\n}\n\nstruct VariablePriceContract {\n    // the price of the token\n    uint256 price;\n        // how the price is modified\n    PriceModifier priceModifier;\n    // only used if priceModifier is EXPONENTIAL or INVERSELOG or FIXED\n    uint256 priceModifierFactor;\n    // max price for the token\n    uint256 maxPrice;\n}\n\nstruct VariablePriceStorage {\n    // the price of the token\n    VariablePriceContract variablePrices;\n}\n\n/// @notice common struct definitions for tokens\ninterface IVariablePrice {\n    /// @notice get the increased price of the token\n    function getIncreasedPrice() external view returns (uint256);\n\n    /// @notice get the increased price of the token\n    function getTokenPrice() external view returns (VariablePriceContract memory);\n}\n"
    },
    "contracts/libraries/AttributeLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../interfaces/IAttribute.sol\";\n\nstruct AttributeStorage {\n    AttributeContract attributes;\n}\n\nlibrary AttributeLib {\n    event AttributeSet(address indexed tokenAddress, uint256 tokenId, Attribute attribute);\n    event AttributeRemoved(address indexed tokenAddress, uint256 tokenId, string attributeKey);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.AttributeStorage.storage\");\n\n    function attributeStorage() internal pure returns (AttributeStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice set an attribute for a tokenid keyed by string\n    function _getAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal view returns (Attribute memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributes[tokenId][key];\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeValues(\n        uint256 id\n    ) internal view returns (string[] memory) {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        string[] memory keys = ct.attributeKeys[id];\n        string[] memory values = new string[](keys.length);\n        uint256 keysLength = keys.length;\n        for (uint256 i = 0; i < keysLength; i++) {\n            values[i] = ct.attributes[id][keys[i]].value;\n        }\n        return values;\n    }\n    \n    /// @notice set an attribute to a tokenid keyed by string\n    function _setAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        Attribute memory attribute\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        if (self.attributeKeysIndexes[tokenId][attribute.key] == 0 \n            && bytes(self.attributes[tokenId][attribute.key].value).length == 0) {\n            self.attributeKeys[tokenId].push(attribute.key);\n            self.attributeKeysIndexes[tokenId][attribute.key] = self.attributeKeys[tokenId].length - 1;\n        }\n        self.attributes[tokenId][attribute.key] = attribute;\n    }\n    \n    /// @notice set multiple  attributes for the token\n    function _setAttributes(\n        AttributeContract storage self,\n        uint256 tokenId, \n        Attribute[] memory _attributes)\n        internal\n    {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        uint256 attributesLength = _attributes.length;\n        for (uint256 i = 0; i < attributesLength; i++) {\n            _setAttribute(self, tokenId, _attributes[i]);\n        }\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeKeys(\n        AttributeContract storage self,\n        uint256 tokenId\n    ) internal view returns (string[] memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributeKeys[tokenId];\n    }\n\n    /// @notice remove the attribute for a tokenid keyed by string\n    function _removeAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        delete self.attributes[tokenId][key];\n        uint256 ndx = self.attributeKeysIndexes[tokenId][key];\n        for (uint256 i = ndx; i < self.attributeKeys[tokenId].length - 1; i++) {\n            self.attributeKeys[tokenId][i] = self.attributeKeys[tokenId][i + 1];\n            self.attributeKeysIndexes[tokenId][self.attributeKeys[tokenId][i]] = i;\n        }\n        delete self.attributeKeys[tokenId][self.attributeKeys[tokenId].length - 1];\n        emit AttributeRemoved(address(this), tokenId, key);\n    }\n\n    // @notice set multiple attributes for the token\n    function _burn(\n        AttributeContract storage self,\n        uint256 tokenId)\n        internal\n    {\n        self.burnedIds[tokenId] = true;\n    }\n}\n"
    },
    "contracts/libraries/FeeDistributorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary FeeDistributorLib {\n    using SafeERC20 for IERC20;\n\n    // Storage struct for Fee Distributor settings\n    struct FeeDistributorStorage {\n        address[] feeReceivers;\n        uint256[] feeWeights;\n        uint256 totalWeightBasis; // e.g., 10000 for basis points\n        address distributionToken; // Address of the ERC20 token to distribute (e.g., USDC)\n    }\n// --- Logic Functions (Implementations TBD) ---\n    // --- Logic Functions (Implementations TBD) ---\n\n    /**\n     * @notice Initializes the Fee Distributor settings. Should only be called once.\n     * @param ds Diamond storage pointer.\n     * @param _distributionToken Address of the ERC20 token to be distributed.\n     * @param _totalWeightBasis The basis for fee weights (e.g., 10000 for basis points).\n     */\n    function _initializeFeeDistributor(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address _distributionToken,\n        uint256 _totalWeightBasis\n    ) internal {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        require(fds.distributionToken == address(0), \"FeeDistributor: Already initialized\");\n        // Allow address(0) for native currency distribution\n        require(_totalWeightBasis > 0, \"FeeDistributor: Basis must be positive\");\n\n        fds.distributionToken = _distributionToken;\n        fds.totalWeightBasis = _totalWeightBasis;\n    }\n\n    /**\n     * @notice Sets the fee receivers and their weights.\n     * @param ds Diamond storage pointer.\n     * @param _feeReceivers Array of addresses to receive fees.\n     * @param _feeWeights Array of weights corresponding to each receiver.\n     */\n    function _setFeeReceivers(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address[] memory _feeReceivers,\n        uint256[] memory _feeWeights\n    ) internal returns (address[] memory, uint256[] memory) {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        require(_feeReceivers.length == _feeWeights.length, \"FeeDistributor: Array lengths mismatch\");\n        require(_feeReceivers.length > 0, \"FeeDistributor: Must provide at least one receiver\");\n\n        uint256 totalWeightSum = 0;\n        for (uint i = 0; i < _feeReceivers.length; i++) {\n            require(_feeReceivers[i] != address(0), \"FeeDistributor: Invalid receiver address\");\n            require(_feeWeights[i] > 0, \"FeeDistributor: Weight must be positive\");\n            totalWeightSum += _feeWeights[i];\n        }\n        require(totalWeightSum == fds.totalWeightBasis, \"FeeDistributor: Weights must sum to basis\");\n\n        fds.feeReceivers = _feeReceivers;\n        fds.feeWeights = _feeWeights;\n\n        return (_feeReceivers, _feeWeights); // Return for event emission in facet\n    }\n\n    /**\n     * @notice Gets the current fee receivers and their weights.\n     * @param ds Diamond storage pointer.\n     * @return feeReceivers_ Array of addresses currently set to receive fees.\n     * @return feeWeights_ Array of weights corresponding to each receiver.\n     */\n    function _getFeeReceivers(\n        IdentitySystemStorage.IdentitySystem storage ds\n    )\n        internal\n        view\n        returns (\n            address[] memory feeReceivers_,\n            uint256[] memory feeWeights_\n        )\n    {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        return (fds.feeReceivers, fds.feeWeights);\n    }\n\n    /**\n     * @notice Calculates the adjusted principal amount and individual fee amounts.\n     * @param ds Diamond storage pointer.\n     * @param principalAmount The total amount before fee deduction.\n     * @return adjustedAmount The principal amount remaining after deducting total fees.\n     * @return feeAmounts Array of individual fee amounts calculated for each receiver.\n     */\n    function _calculateAmounts(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        uint256 principalAmount\n    )\n        internal\n        view\n        returns (\n            uint256 adjustedAmount,\n            uint256[] memory feeAmounts\n        )\n    {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        address[] memory receivers = fds.feeReceivers;\n        uint256 numReceivers = receivers.length;\n\n        if (numReceivers == 0) {\n            // No fee receivers configured, return full principal (pass-through)\n            return (principalAmount, new uint256[](0));\n        }\n\n        // If fee receivers are configured, then the basis must be initialized.\n        require(fds.totalWeightBasis > 0, \"FeeDistributor: Not initialized or invalid basis\");\n        uint256[] memory weights = fds.feeWeights; // Get weights only if needed\n\n        feeAmounts = new uint256[](numReceivers);\n        uint256 totalFeeAmount = 0;\n\n        for (uint i = 0; i < numReceivers; i++) {\n            // Calculate fee: (principalAmount * weight) / basis\n            // Protect against overflow before division\n            uint256 fee = (principalAmount * weights[i]) / fds.totalWeightBasis;\n            feeAmounts[i] = fee;\n            totalFeeAmount += fee;\n        }\n\n        require(totalFeeAmount <= principalAmount, \"FeeDistributor: Total fees exceed principal\");\n        adjustedAmount = principalAmount - totalFeeAmount;\n\n        return (adjustedAmount, feeAmounts);\n    }\n\n    /**\n     * @notice Distributes a principal amount after deducting fees.\n     * @dev Can distribute either native currency (if distributionToken is address(0)) or a specified ERC20 token.\n     * @dev Assumes the contract holds sufficient balance of the currency/token to distribute.\n     * @param ds Diamond storage pointer.\n     * @param self The address of the calling contract (the diamond) for native transfers.\n     * @param principalAmountReceiver The address to receive the adjusted principal amount.\n     * @param _principalAmount The total amount to be distributed.\n     * @return adjustedAmountReceiver_ The address that received the adjusted principal amount.\n     * @return adjustedAmount_ The adjusted principal amount transferred.\n     * @return feeReceivers_ The addresses that received the fee amounts.\n     * @return feeAmounts_ The individual fee amounts transferred.\n     */\n    function _distributeAmounts(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address self, // Address of the diamond/calling contract\n        address principalAmountReceiver,\n        uint256 _principalAmount\n    ) internal returns (\n        address adjustedAmountReceiver_,\n        uint256 adjustedAmount_,\n        address[] memory feeReceivers_,\n        uint256[] memory feeAmounts_\n    ) {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        // No require for token != address(0) anymore, as address(0) signifies native currency\n        require(principalAmountReceiver != address(0), \"FeeDistributor: Invalid principal receiver\");\n\n        // Calculate amounts\n        (uint256 adjustedAmount, uint256[] memory feeAmounts) = _calculateAmounts(ds, _principalAmount);\n\n        address[] memory receivers = fds.feeReceivers;\n        bool isNative = fds.distributionToken == address(0);\n\n        if (isNative) {\n            // Native currency distribution\n            require(self.balance >= _principalAmount, \"FeeDistributor: Insufficient native balance\");\n            // Transfer fees\n            for (uint i = 0; i < receivers.length; i++) {\n                if (feeAmounts[i] > 0) {\n                    (bool success, ) = payable(receivers[i]).call{value: feeAmounts[i]}(\"\");\n                    require(success, \"FeeDistributor: Native fee transfer failed\");\n                }\n            }\n            // Transfer adjusted principal amount\n            if (adjustedAmount > 0) {\n                (bool success, ) = payable(principalAmountReceiver).call{value: adjustedAmount}(\"\");\n                require(success, \"FeeDistributor: Native principal transfer failed\");\n            }\n        } else {\n            // ERC20 token distribution\n            IERC20 token = IERC20(fds.distributionToken);\n            require(token.balanceOf(self) >= _principalAmount, \"FeeDistributor: Insufficient token balance\");\n            // Transfer fees\n            for (uint i = 0; i < receivers.length; i++) {\n                if (feeAmounts[i] > 0) {\n                    token.safeTransfer(receivers[i], feeAmounts[i]);\n                }\n            }\n            // Transfer adjusted principal amount\n            if (adjustedAmount > 0) {\n                token.safeTransfer(principalAmountReceiver, adjustedAmount);\n            }\n        }\n\n        // Return values for event emission\n        return (principalAmountReceiver, adjustedAmount, receivers, feeAmounts);\n    }\n\n}"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IERC173.sol\"; // for IERC173 interface\nimport \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    // Upgrade proposal struct for timelock functionality\n    struct UpgradeProposal {\n        IDiamondCut.FacetCut[] diamondCut;\n        address initAddress;\n        bytes initCalldata;\n        uint256 proposalTime;\n        bool exists;\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n        // Timelock for upgrades (in seconds)\n        uint256 upgradeTimelock;\n        // Storage for the current upgrade proposal\n        UpgradeProposal upgradeProposal;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit IERC173.OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    // Timelock constants\n    uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days;\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Initialize timelock settings for upgrade proposals\n    function initializeUpgradeTimelock(uint256 _timelock) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeTimelock == 0, \"LibDiamond: Timelock already initialized\");\n        ds.upgradeTimelock = _timelock > 0 ? _timelock : DEFAULT_UPGRADE_TIMELOCK;\n    }\n\n    // Propose a diamond cut to be executed after the timelock\n    function proposeDiamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(!ds.upgradeProposal.exists, \"LibDiamond: Upgrade already proposed\");\n        require(ds.upgradeTimelock > 0, \"LibDiamond: Timelock not initialized\");\n        \n        // Create a deep copy of the diamond cut to store in the proposal\n        IDiamondCut.FacetCut[] memory diamondCutCopy = new IDiamondCut.FacetCut[](_diamondCut.length);\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            diamondCutCopy[i] = _diamondCut[i];\n            \n            // Deep copy the function selectors array\n            bytes4[] memory selectors = new bytes4[](_diamondCut[i].functionSelectors.length);\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                selectors[j] = _diamondCut[i].functionSelectors[j];\n            }\n            diamondCutCopy[i].functionSelectors = selectors;\n        }\n        \n        // Store the proposal\n        // Create empty array in storage first\n        delete ds.upgradeProposal.diamondCut;\n        \n        // Manually copy each element and its nested arrays to storage\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            // Create a new struct in storage by pushing an empty element first\n            ds.upgradeProposal.diamondCut.push();\n            \n            // Now set the values for this element's fields\n            ds.upgradeProposal.diamondCut[i].facetAddress = _diamondCut[i].facetAddress;\n            ds.upgradeProposal.diamondCut[i].action = _diamondCut[i].action;\n            \n            // For the selectors array, we need to handle it separately\n            // Clear any existing selectors to ensure clean state\n            delete ds.upgradeProposal.diamondCut[i].functionSelectors;\n            \n            // Copy each selector individually\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                ds.upgradeProposal.diamondCut[i].functionSelectors.push(_diamondCut[i].functionSelectors[j]);\n            }\n        }\n        ds.upgradeProposal.initAddress = _init;\n        ds.upgradeProposal.initCalldata = _calldata;\n        ds.upgradeProposal.proposalTime = block.timestamp;\n        ds.upgradeProposal.exists = true;\n        \n        emit IDiamondCut.DiamondCutProposed(msg.sender, block.timestamp, block.timestamp + ds.upgradeTimelock);\n    }\n    \n    // Execute a proposed diamond cut after the timelock period\n    function executeDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        require(\n            block.timestamp >= ds.upgradeProposal.proposalTime + ds.upgradeTimelock,\n            \"LibDiamond: Timelock period not elapsed\"\n        );\n        \n        // Execute the diamond cut\n        diamondCut(\n            ds.upgradeProposal.diamondCut,\n            ds.upgradeProposal.initAddress,\n            ds.upgradeProposal.initCalldata\n        );\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n    }\n    \n    // Cancel a proposed diamond cut\n    function cancelDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n        \n        emit IDiamondCut.DiamondCutCancelled(msg.sender);\n    }\n}\n"
    },
    "contracts/libraries/TradeDealLib.sol": {
      "content": " // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../identity/IdentityStorage.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"../interfaces/IInterest.sol\";\nimport \"../interfaces/IUSDCPool.sol\";\nimport \"../interfaces/IAttribute.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nusing SafeERC20 for IERC20;\nimport \"../interfaces/IERC721Permissioned.sol\";\nimport \"../interfaces/IFeeDistributor.sol\"; // Added for fee distribution\nimport \"hardhat/console.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../libraries/AttributeLib.sol\";\n\nimport {console} from \"hardhat/console.sol\";\n\nlibrary TradeDealLib {\n    // These event declarations are temporary until we complete migration\n    // They'll be removed once we've updated all functions to return event params\n    // rather than emit events directly\n    \n    // Operation mode for trade deals\n    enum OperationMode {\n        CENTRALIZED,    // Contract owner manages all fund operations\n        SELF_SERVICE,   // Borrowers can directly withdraw/repay funds\n        HYBRID,         // Mixed model with configurable permissions\n        CUSTOM          // Fine-grained permission configuration\n    }\n    \n    // Roles for the role-based access control system\n    enum Role {\n        NONE,        // No special role (default)\n        ADMIN,       // Full control over the trade deal\n        LENDER,      // Can deposit funds and receive Collateral tokens\n        BORROWER,    // Can deposit invoices and withdraw funds (in self-service)\n        UNDERWRITER, // Can approve/reject deals, modify terms\n        LIQUIDATOR   // Can liquidate collateral if terms are violated\n    }\n    \n    // Permission bit flags for fine-grained control\n    uint256 constant PERMISSION_DEPOSIT_FUNDS = 1;\n    uint256 constant PERMISSION_WITHDRAW_FUNDS = 2;\n    uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4;\n    uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8;\n    uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16;\n    \n    event TradeDealCreated(\n        uint256 indexed tradeDealId,\n        string name,\n        string symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        bool active,\n        address nftAddress,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    );\n    // Removed duplicate TradeDealUpdated event definition\n    event TradeDealActivated(uint256 indexed tradeDealId);\n    event TradeDealDeactivated(uint256 indexed tradeDealId);\n    event TradeDealParticipantAdded(uint256 indexed tradeDealId, address indexed participant);\n    event TradeDealParticipantRemoved(uint256 indexed tradeDealId, address indexed participant);\n    event InvoiceDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n    event InvoiceWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n    event USDCDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 amount);\n    event USDCWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 amount);\n    event InterestDistributedForTradeDeal(uint256 indexed tradeDealId, uint256 totalInterest, uint256 invoicePoolInterest, uint256 interestInterest, uint256 interestTokensMinted);\n    event TradeDealRequiredClaimTopicsSet(uint256 indexed tradeDealId, uint256[] claimTopics);\n    // New events for enhanced functionality\n    event TradeDealFullyFunded(uint256 indexed tradeDealId, uint256 fundingTarget);\n    event TradeDealFundingWithdrawn(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\n    event TradeDealRepaid(uint256 indexed tradeDealId, address indexed repayer, uint256 amount, bool fullyRepaid);\n    event CollateralTokensRedeemed(uint256 indexed tradeDealId, address indexed redeemer, uint256 collateralAmount, uint256 usdcAmount);\n    // Trade Deal data structure\n    struct TradeDeal {\n        uint256 id;\n        string name;\n        string symbol;           // Symbol for the trade deal, used for Collateral token\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        uint256[] requiredClaimTopics; // Claim topics required for participation\n        address collateralAddress;     // Address of the Collateral token contract for this trade deal\n        address interestAddress;     // Address of the VABI token contract for this trade deal\n        address usdcAddress;     // Address of the USDC token contract for this trade deal\n        OperationMode operationMode; // Operation mode (CENTRALIZED or SELF_SERVICE)\n    }\n\n    struct CollateralRedemptionResult {\n        uint256 tradeDealId;\n        address redeemer;\n        uint256 collateralAmount;\n        uint256 usdcAmount;\n    }\n    \n    // Extended CollateralleStorage to support trade deals\n    struct TradeDealStorage {\n        // Trade deal tracking\n        mapping(uint256 => TradeDeal) tradeDeals;\n        uint256[] tradeDealIds;\n        uint256 nextTradeDealId;\n        \n        // Per-trade deal mappings\n        mapping(uint256 => uint256[]) tradeDealInvoices; // Trade deal ID => array of invoice token IDs\n        mapping(uint256 => uint256) tradeDealUsdcBalances; // Trade deal ID => USDC balance\n        mapping(uint256 => mapping(address => bool)) tradeDealParticipants; // Trade deal ID => user address => is participant\n        mapping(uint256 => uint256[]) tradeDealRequiredClaimTopics; // Trade deal ID => array of required claim topics\n        \n        // Role-based access control\n        mapping(uint256 => mapping(address => Role)) userRoles; // Trade deal ID => user address => role\n        mapping(uint256 => mapping(address => uint256)) userPermissions; // Trade deal ID => user address => permissions\n        \n        // New fields for enhanced functionality\n        mapping(uint256 => uint256) tradeDealFundingTargets; // Trade deal ID => funding target\n        mapping(uint256 => bool) tradeDealFundingWithdrawn; // Trade deal ID => whether funding has been withdrawn\n        mapping(uint256 => uint256) tradeDealRepaidAmounts; // Trade deal ID => amount repaid\n        mapping(uint256 => uint256) tradeDealTotalDebt; // Trade deal ID => total debt (principal + interest)\n        \n        // Track original depositors of invoices\n        mapping(uint256 => mapping(uint256 => address)) invoiceDepositors; // Trade deal ID => token ID => original depositor\n    }\n    \n    // Return struct for createTradeDeal function\n    struct CreateTradeDealResult {\n        uint256 tradeDealId;\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        address nftAddress;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n        bool hasClaimTopics;\n        uint256[] requiredClaimTopics;\n        OperationMode operationMode;\n    }\n    \n    // Parameters struct for createTradeDeal function\n    struct CreateTradeDealParams {\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        uint256[] requiredClaimTopics;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n        OperationMode operationMode;\n    }\n    \n    // Create a new trade deal\n    function _createTradeDeal(\n        CreateTradeDealParams memory params\n    ) internal returns (CreateTradeDealResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        uint256 tradeDealId = tds.nextTradeDealId++;\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        tradeDeal.id = tradeDealId;\n        tradeDeal.name = params.name;\n        tradeDeal.symbol = params.symbol;\n        tradeDeal.interestRate = params.interestRate;\n        tradeDeal.collateralToInterestRatio = params.collateralToInterestRatio;\n        tradeDeal.active = true;\n        \n        // Check if we should use the CollateralTokenFactoryFacet to create a new Collateral token\n        address collateralAddress = params.collateralAddress;\n        if (collateralAddress == address(0)) {\n            // Try to create a new Collateral token\n            collateralAddress = _createOrGetCollateralToken(tradeDealId, params.symbol);\n        }\n        \n        tradeDeal.collateralAddress = collateralAddress;\n        tradeDeal.interestAddress = params.interestAddress;\n        tradeDeal.usdcAddress = params.usdcAddress;\n        tradeDeal.operationMode = params.operationMode;\n        \n        // Set required claim topics\n        bool hasClaimTopics = params.requiredClaimTopics.length > 0;\n        if (hasClaimTopics) {\n            uint256 requiredClaimTopicsLength = params.requiredClaimTopics.length;\n            for (uint256 i = 0; i < requiredClaimTopicsLength; i++) {\n                tradeDeal.requiredClaimTopics.push(params.requiredClaimTopics[i]);\n                tds.tradeDealRequiredClaimTopics[tradeDealId].push(params.requiredClaimTopics[i]);\n            }\n        }\n        // Initialize repayment tracking - funding target will be set when an invoice is deposited\n        tds.tradeDealFundingTargets[tradeDealId] = 0; // Will be set based on NFT totalAmount when invoice is deposited\n        tds.tradeDealRepaidAmounts[tradeDealId] = 0;\n        tds.tradeDealTotalDebt[tradeDealId] = 0; // Will be set when fully funded\n        tds.tradeDealFundingWithdrawn[tradeDealId] = false;\n        tds.tradeDealFundingWithdrawn[tradeDealId] = false;\n        \n        tds.tradeDealIds.push(tradeDealId);\n        \n        // Instead of emitting events, return the data needed for the facet to emit events\n        CreateTradeDealResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.name = params.name;\n        result.symbol = params.symbol;\n        result.interestRate = params.interestRate;\n        result.collateralToInterestRatio = params.collateralToInterestRatio;\n        result.active = true;\n        result.nftAddress = address(0); // Use address(0) for nftAddress since we're using the Diamond's ERC721PermissionedTokenFacet\n        result.collateralAddress = collateralAddress;\n        result.interestAddress = params.interestAddress;\n        result.usdcAddress = params.usdcAddress;\n        result.hasClaimTopics = hasClaimTopics;\n        result.requiredClaimTopics = params.requiredClaimTopics;\n        result.operationMode = params.operationMode;\n        \n        return result;\n    }\n    // Return struct for updateTradeDeal function\n    struct UpdateTradeDealResult {\n        uint256 tradeDealId;\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n    }\n    \n    // Update an existing trade deal\n    // Update an existing trade deal\n    function _updateTradeDeal(\n        uint256 tradeDealId,\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) internal returns (UpdateTradeDealResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        tradeDeal.name = name;\n        tradeDeal.symbol = symbol;\n        tradeDeal.interestRate = interestRate;\n        tradeDeal.collateralToInterestRatio = collateralToInterestRatio;\n        tradeDeal.collateralAddress = collateralAddress;\n        tradeDeal.interestAddress = interestAddress;\n        tradeDeal.usdcAddress = usdcAddress;\n        \n        // Instead of emitting an event, return the data needed for the facet to emit the event\n        UpdateTradeDealResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.name = name;\n        result.symbol = symbol;\n        result.interestRate = interestRate;\n        result.collateralToInterestRatio = collateralToInterestRatio;\n        result.active = tradeDeal.active;\n        result.collateralAddress = collateralAddress;\n        result.interestAddress = interestAddress;\n        result.usdcAddress = usdcAddress;\n        \n        return result;\n    }\n    \n    // Return struct for activate/deactivate trade deal\n    struct TradeDealStateChangeResult {\n        uint256 tradeDealId;\n    }\n    \n    // Activate a trade deal\n    function _activateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDeals[tradeDealId].active = true;\n        \n        // Return result instead of emitting event\n        TradeDealStateChangeResult memory result;\n        result.tradeDealId = tradeDealId;\n        return result;\n    }\n    \n    // Deactivate a trade deal\n    function _deactivateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDeals[tradeDealId].active = false;\n        \n        // Return result instead of emitting event\n        TradeDealStateChangeResult memory result;\n        result.tradeDealId = tradeDealId;\n        return result;\n    }\n    \n    // Check if a trade deal exists\n    function _tradeDealExists(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        return tradeDealId < tds.nextTradeDealId && tds.tradeDeals[tradeDealId].id == tradeDealId;\n    }\n    \n    // Get trade deal info\n    function _getTradeDealInfo(uint256 tradeDealId) internal view returns (TradeDeal memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDeals[tradeDealId];\n    }\n    \n    // Get all trade deal IDs\n    function _getAllTradeDealIds() internal view returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        return tds.tradeDealIds;\n    }\n    \n    // Return struct for participant management functions\n    struct TradeDealParticipantResult {\n        uint256 tradeDealId;\n        address participant;\n    }\n    \n    // Participant management\n    function _addTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDealParticipants[tradeDealId][participant] = true;\n        \n        // Return result instead of emitting event\n        TradeDealParticipantResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.participant = participant;\n        return result;\n    }\n    \n    function _removeTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDealParticipants[tradeDealId][participant] = false;\n        \n        // Return result instead of emitting event\n        TradeDealParticipantResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.participant = participant;\n        return result;\n    }\n    \n    function _isTradeDealParticipant(uint256 tradeDealId, address user) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // First check if the user is explicitly added as a participant\n        if (tds.tradeDealParticipants[tradeDealId][user]) {\n            return true;\n        }\n        \n        // If no required claim topics are set, only explicit participants are allowed\n        if (tds.tradeDealRequiredClaimTopics[tradeDealId].length == 0) {\n            return false;\n        }\n        \n        // Check if the user has any of the required claim topics\n        address identityAddress = ds.identities[user];\n        if (identityAddress == address(0)) {\n            return false; // User has no identity\n        }\n        \n        // Get the user's claims\n        uint256[] storage userClaims = ds.claimList[identityAddress];\n        \n        // Check if the user has any of the required claim topics\n        uint256 requiredClaimTopicsLength = tds.tradeDealRequiredClaimTopics[tradeDealId].length;\n        for (uint256 i = 0; i < requiredClaimTopicsLength; i++) {\n            uint256 requiredClaimTopic = tds.tradeDealRequiredClaimTopics[tradeDealId][i];\n            \n            for (uint256 j = 0; j < userClaims.length; j++) {\n                if (userClaims[j] == requiredClaimTopic) {\n                    return true; // User has a required claim\n                }\n            }\n        }\n        \n        return false; // User has no required claims\n    }\n    \n    // Return struct for invoice management functions\n    struct InvoiceActionResult {\n        uint256 tradeDealId;\n        uint256 tokenId;\n    }\n    \n    // Invoice management for trade deals\n    function _depositInvoiceToTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        \n        // Use the Diamond's ERC721PermissionedTokenFacet to transfer the NFT\n        // This bypasses the need for approval\n        bytes memory emptyData = \"\";\n        IERC721Permissioned(address(this)).forcedTransfer(\n            msg.sender,\n            address(this),\n            tokenId,\n            emptyData\n        );\n        \n        // Track the invoice in this trade deal\n        tds.tradeDealInvoices[tradeDealId].push(tokenId);\n        // Record the original depositor of this invoice\n        tds.invoiceDepositors[tradeDealId][tokenId] = msg.sender;\n        \n        // Get the totalAmount from the NFT and set it as the funding target\n        uint256 totalAmount = _getNFTInvoiceTotalAmount(tokenId);\n        tds.tradeDealFundingTargets[tradeDealId] += totalAmount;\n        \n        // Return result instead of emitting event\n        InvoiceActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.tokenId = tokenId;\n        return result;\n    }\n\n    function _withdrawInvoiceFromTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // Verify that the NFT is owned by this contract\n        require(IERC721(address(this)).ownerOf(tokenId) == address(this), \"NFT not owned by this contract\");\n        \n        // Check if the caller is the original depositor of this invoice\n        require(\n            tds.invoiceDepositors[tradeDealId][tokenId] == msg.sender ||\n            msg.sender == LibDiamond.contractOwner(),\n            \"Only the original depositor or contract owner can withdraw this invoice\"\n        );\n        \n        // Remove the invoice from this trade deal's tracking\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        bool found = false;\n        uint256 invoicesLength = invoices.length;\n        for (uint256 i = 0; i < invoicesLength; i++) {\n            if (invoices[i] == tokenId) {\n                // Remove by swapping with the last element and popping\n                invoices[i] = invoices[invoices.length - 1];\n                invoices.pop();\n                found = true;\n                break;\n            }\n        }\n        \n        require(found, \"Invoice not found in this trade deal\");\n\n        // *** FIX: Decrease funding target when invoice is withdrawn ***\n        uint256 invoiceAmount = _getNFTInvoiceTotalAmount(tokenId);\n        if (tds.tradeDealFundingTargets[tradeDealId] >= invoiceAmount) {\n             tds.tradeDealFundingTargets[tradeDealId] -= invoiceAmount;\n        } else {\n            // Avoid underflow if target is somehow already less than amount (shouldn't happen)\n            tds.tradeDealFundingTargets[tradeDealId] = 0;\n        }\n        // *** END FIX ***\n\n        // Use forcedTransfer to transfer the NFT back to the sender\n        // This bypasses the need for approval\n        bytes memory emptyData = \"\";\n        IERC721Permissioned(address(this)).forcedTransfer(\n            address(this),\n            msg.sender,\n            tokenId,\n            emptyData\n        );\n\n        // Clean up the depositor tracking\n        delete tds.invoiceDepositors[tradeDealId][tokenId];\n        \n        // Return result instead of emitting event\n        InvoiceActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.tokenId = tokenId;\n        return result;\n    }\n    \n    // Return struct for USDC management functions\n    struct USDCActionResult {\n        uint256 tradeDealId;\n        uint256 amount;\n        bool isFullyFunded;\n        uint256 fundingTarget;\n    }\n    \n    // USDC management for trade deals\n    function _depositUSDCToTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.usdcAddress != address(0), \"Trade deal USDC address not set\");\n        \n        // Get funding target and current balance\n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\n        uint256 currentBalance = tds.tradeDealUsdcBalances[tradeDealId];\n        \n        // If funding target exists, check that deposit won't exceed it\n        if (fundingTarget > 0) {\n            uint256 remainingToFund = fundingTarget > currentBalance ?\n                fundingTarget - currentBalance : 0;\n                \n            require(amount <= remainingToFund, \"Amount exceeds remaining funding needed\");\n        }\n        \n        // Log the depositor address and amount\n        address depositor = msg.sender;\n        \n        // Use the USDC token's transferFrom method to transfer tokens from the sender to this contract\n        IERC20(tradeDeal.usdcAddress).safeTransferFrom(depositor, address(this), amount);\n        \n        // Track the amount in this trade deal\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Explicitly add the depositor as a participant in the trade deal\n        // This ensures they can receive Collateral tokens\n        if (!_isTradeDealParticipant(tradeDealId, depositor)) {\n            _addTradeDealParticipant(tradeDealId, depositor);\n        }\n        \n        // If the trade deal has a Collateral token, mint Collateral tokens to the depositor\n        if (tradeDeal.collateralAddress != address(0)) {\n            // Get the Collateral token contract\n            address collateralToken = tradeDeal.collateralAddress;\n            \n            // Force the trade deal to be active during minting\n            bool wasActive = tradeDeal.active;\n            tradeDeal.active = true;\n            \n            // Try to mint Collateral tokens to the depositor\n            // We need to make sure the depositor is added as a participant first\n            // This is done by the _addTradeDealParticipant call above\n            \n            // Adjust for the difference in decimals between USDC (6) and Collateral (18)\n            // Multiply by 10^12 to convert from USDC decimals to Collateral decimals\n            uint256 adjustedAmount = amount * 1000000000000; // 10^12\n\n            // Attempt to mint Collateral tokens; will revert if it fails\n            ICollateral(collateralToken).mint(depositor, adjustedAmount);\n            // *** END FIX ***\n            \n            // Restore the original active state\n            tradeDeal.active = wasActive;\n        }\n        \n        // Check if this deposit completes the funding\n        if (fundingTarget > 0 && currentBalance + amount >= fundingTarget) {\n            // Calculate total debt including interest\n            uint256 interest = (fundingTarget * tradeDeal.interestRate) / 10000;\n            tds.tradeDealTotalDebt[tradeDealId] = fundingTarget + interest;\n            \n            // Track if funding was completed for the result\n        }\n        \n        // Return result instead of emitting events\n        USDCActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.amount = amount;\n        result.isFullyFunded = (fundingTarget > 0 && currentBalance + amount >= fundingTarget);\n        result.fundingTarget = fundingTarget;\n        return result;\n    }\n    \n    function _withdrawUSDCFromTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDealUsdcBalances[tradeDealId] >= amount, \"Insufficient USDC balance in trade deal\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.usdcAddress != address(0), \"Trade deal USDC address not set\");\n        \n        // Use the USDC token's transfer method to transfer tokens from this contract to the sender\n        require(IERC20(tradeDeal.usdcAddress).transfer(msg.sender, amount), \"USDC transfer failed\");\n        \n        // Update the amount in this trade deal\n        tds.tradeDealUsdcBalances[tradeDealId] -= amount;\n        \n        // Return result instead of emitting event\n        USDCActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.amount = amount;\n        result.isFullyFunded = false; // Not applicable for withdrawal\n        result.fundingTarget = 0;     // Not applicable for withdrawal\n        return result;\n    }\n    \n    // Return struct for interest distribution\n    struct InterestDistributionResult {\n        uint256 tradeDealId;\n        uint256 totalInterest;\n        uint256 invoicePoolInterest;\n        uint256 interestInterest;\n        uint256 interestTokensMinted;\n    }\n    \n    // Interest distribution for a specific trade deal\n    // This function is kept for backward compatibility but is simplified to avoid VABI token complexity\n    function _distributeInterestForTradeDeal(uint256 tradeDealId) internal view returns (InterestDistributionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        \n        // Note: Interest calculation is now handled during funding completion and repayment processes\n        // This function is maintained for backward compatibility\n        \n        // We'll calculate interest but won't do anything with it\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        uint256 balance = tds.tradeDealUsdcBalances[tradeDealId];\n        uint256 interest = (balance * tradeDeal.interestRate) / 10000;\n        \n        // Return result instead of emitting event\n        InterestDistributionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.totalInterest = interest;\n        result.invoicePoolInterest = interest; // All interest goes to the trade deal now\n        result.interestInterest = 0;               // No VABI interest\n        result.interestTokensMinted = 0;           // No VABI tokens minted\n        \n        return result;\n    }\n    \n    // Get USDC balance for a specific trade deal\n    function _getUSDCBalanceForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealUsdcBalances[tradeDealId];\n    }\n    \n    // Get invoice count for a specific trade deal\n    function _getInvoiceCountForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealInvoices[tradeDealId].length;\n    }\n    \n    // Get invoice token ID for a specific trade deal\n    function _getInvoiceTokenIdForTradeDeal(uint256 tradeDealId, uint256 index) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(index < tds.tradeDealInvoices[tradeDealId].length, \"Index out of bounds\");\n        \n        return tds.tradeDealInvoices[tradeDealId][index];\n    }\n    \n    // Return struct for setting required claim topics\n    struct ClaimTopicsResult {\n        uint256 tradeDealId;\n        uint256[] claimTopics;\n    }\n    \n    // Set required claim topics for a trade deal\n    function _setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) internal returns (ClaimTopicsResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // Clear existing claim topics\n        delete tds.tradeDealRequiredClaimTopics[tradeDealId];\n        delete tds.tradeDeals[tradeDealId].requiredClaimTopics;\n        \n        // Set new claim topics\n        uint256 claimTopicsLength = claimTopics.length;\n        for (uint256 i = 0; i < claimTopicsLength; i++) {\n            tds.tradeDealRequiredClaimTopics[tradeDealId].push(claimTopics[i]);\n            tds.tradeDeals[tradeDealId].requiredClaimTopics.push(claimTopics[i]);\n        }\n        \n        // Return result instead of emitting event\n        ClaimTopicsResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.claimTopics = claimTopics;\n        return result;\n    }\n    \n    // Get required claim topics for a trade deal\n    function _getTradeDealRequiredClaimTopics(uint256 tradeDealId) internal view returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealRequiredClaimTopics[tradeDealId];\n    }\n    \n    // Check if a trade deal is fully funded\n    function _isTradeDealFunded(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\n        if (fundingTarget == 0) {\n            return false; // No funding target set\n        }\n        \n        return tds.tradeDealUsdcBalances[tradeDealId] >= fundingTarget;\n    }\n    \n    // Check if a trade deal is fully repaid\n    function _isTradeDealRepaid(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        if (totalDebt == 0) {\n            return false; // No debt established yet\n        }\n        \n        return tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt;\n    }\n    \n    // Return struct for funding withdrawal\n    struct FundingWithdrawalResult {\n        uint256 tradeDealId;\n        address recipient;\n        uint256 amount;\n    }\n    \n    // Allow fundees to withdraw USDC funding\n    function _withdrawTradeDealFunding(uint256 tradeDealId, address borrowerAddress) internal returns (FundingWithdrawalResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(_isTradeDealFunded(tradeDealId), \"Trade deal is not fully funded\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        require(borrowerAddress != address(0), \"Borrower address cannot be zero\"); // Added check\n        \n        // Verify caller has deposited invoices as collateral\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        require(invoices.length > 0, \"No invoices deposited as collateral\");\n        \n        // Get token addresses\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Get the funding amount\n        uint256 fundingAmount = tds.tradeDealFundingTargets[tradeDealId];\n        \n        // Mark as withdrawn\n        tds.tradeDealFundingWithdrawn[tradeDealId] = true;\n        \n        // Distribute USDC via FeeDistributor: fees to receivers, adjusted principal to borrower\n        IFeeDistributor feeDistributor = IFeeDistributor(address(this));\n        (address adjustedReceiver, uint256 adjustedAmount, , ) = feeDistributor.distributeAmounts(borrowerAddress, fundingAmount);\n        require(adjustedReceiver == borrowerAddress, \"FeeDistributor: Adjusted amount sent to wrong receiver\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= fundingAmount;\n        \n        // Return result instead of emitting event\n        FundingWithdrawalResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.recipient = borrowerAddress; // Recipient is the borrower\n        result.amount = adjustedAmount;    // Amount is the adjusted principal received\n        return result;\n    }\n    \n    // Return struct for debt repayment\n    struct RepaymentResult {\n        uint256 tradeDealId;\n        address repayer;\n        uint256 amount;\n        bool fullyRepaid;\n    }\n    \n    // Allow fundees to repay their debt\n    function _repayTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (RepaymentResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding not yet withdrawn\");\n        \n        // Calculate remaining debt\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        uint256 repaidSoFar = tds.tradeDealRepaidAmounts[tradeDealId];\n        uint256 remainingDebt = totalDebt > repaidSoFar ? totalDebt - repaidSoFar : 0;\n        \n        require(remainingDebt > 0, \"No remaining debt to repay\");\n        require(amount <= remainingDebt, \"Amount exceeds remaining debt\");\n        \n        // Get USDC token\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Transfer USDC from repayer to contract\n        IERC20(usdcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Update repaid amount\n        tds.tradeDealRepaidAmounts[tradeDealId] += amount;\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Check if fully repaid\n        bool fullyRepaid = (tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt);\n        \n        // Return result instead of emitting event\n        RepaymentResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.repayer = msg.sender;\n        result.amount = amount;\n        result.fullyRepaid = fullyRepaid;\n        return result;\n    }\n\n    function _repayTradeDealForBorrower(uint256 tradeDealId, address borrower, uint256 amount) internal returns (RepaymentResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding not yet withdrawn\");\n        \n        // Calculate remaining debt\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        uint256 repaidSoFar = tds.tradeDealRepaidAmounts[tradeDealId];\n        uint256 remainingDebt = totalDebt > repaidSoFar ? totalDebt - repaidSoFar : 0;\n        \n        require(remainingDebt > 0, \"No remaining debt to repay\");\n        require(amount <= remainingDebt, \"Amount exceeds remaining debt\");\n        \n        // Get USDC token\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Transfer USDC from borrower to contract\n        IERC20(usdcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Update repaid amount\n        tds.tradeDealRepaidAmounts[tradeDealId] += amount;\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Check if fully repaid\n        bool fullyRepaid = (tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt);\n\n        // Return result instead of emitting event\n        RepaymentResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.repayer = borrower;\n        result.amount = amount;\n        result.fullyRepaid = fullyRepaid;\n    \n        return result;\n    }\n    \n    // Check if a user has a valid Collateral token balance for the trade deal\n    function _hasCollateralTokenBalance(uint256 tradeDealId, address user, uint256 requiredAmount) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address collateralToken = tradeDeal.collateralAddress;\n        \n        if (collateralToken == address(0)) return false;\n        \n        uint256 collateralBalance = ICollateral(collateralToken).balanceOf(user);\n        return collateralBalance >= requiredAmount;\n    }\n    \n    // Allow funders to redeem their Collateral tokens\n    function _redeemCollateralTokens(uint256 tradeDealId, uint256 collateralAmount) internal returns (CollateralRedemptionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(_isTradeDealRepaid(tradeDealId), \"Trade deal not fully repaid\");\n        \n        // Get token addresses\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address collateralToken = tradeDeal.collateralAddress;\n        address usdcToken = tradeDeal.usdcAddress;\n        require(collateralToken != address(0), \"Collateral token address not set\");\n        require(usdcToken != address(0), \"USDC token address not set\");\n        \n        // Check Collateral balance\n        uint256 collateralBalance = ICollateral(collateralToken).balanceOf(msg.sender);\n        require(collateralBalance >= collateralAmount, \"Insufficient Collateral balance\");\n        \n        // Calculate proportional USDC amount\n        uint256 totalCollateralSupply = ICollateral(collateralToken).totalSupply();\n        require(totalCollateralSupply > 0, \"No Collateral tokens in circulation\");\n        \n        uint256 usdcBalance = tds.tradeDealUsdcBalances[tradeDealId];\n        uint256 usdcAmount = (usdcBalance * collateralAmount) / totalCollateralSupply;\n        \n        require(usdcAmount > 0, \"Calculated USDC amount is zero\");\n        require(usdcBalance >= usdcAmount, \"Insufficient USDC balance in trade deal\");\n        \n        // Burn Collateral tokens\n        ICollateral(collateralToken).burn(msg.sender, collateralAmount);\n        \n        // Transfer USDC to redeemer\n        require(IERC20(usdcToken).transfer(msg.sender, usdcAmount), \"USDC transfer failed\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= usdcAmount;\n        \n        // Return result instead of emitting event\n        CollateralRedemptionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.redeemer = msg.sender;\n        result.collateralAmount = collateralAmount;\n        result.usdcAmount = usdcAmount;\n        return result;\n    }\n    \n    // Role-based access control functions\n    \n    /**\n     * @notice Set a user's role for a specific trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param role The role to assign\n     */\n    function _setUserRole(uint256 tradeDealId, address user, Role role) internal {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(user != address(0), \"Invalid user address\");\n        \n        tds.userRoles[tradeDealId][user] = role;\n        \n        // If user is being set as a borrower, also add them as a participant\n        if (role == Role.BORROWER && !tds.tradeDealParticipants[tradeDealId][user]) {\n            tds.tradeDealParticipants[tradeDealId][user] = true;\n        }\n    }\n    \n    /**\n     * @notice Check if a user has a specific role in a trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param role The role to check\n     * @return True if the user has the role, false otherwise\n     */\n    function _hasRole(uint256 tradeDealId, address user, Role role) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        if (!_tradeDealExists(tradeDealId)) return false;\n        if (user == address(0)) return false;\n        \n        // Contract owner is always considered to have ADMIN role\n        if (role == Role.ADMIN && user == LibDiamond.contractOwner()) return true;\n        \n        return tds.userRoles[tradeDealId][user] == role;\n    }\n    \n    /**\n     * @notice Check if a user has a specific permission in a trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param permission The permission to check\n     * @return True if the user has the permission, false otherwise\n     */\n    function _hasPermission(uint256 tradeDealId, address user, uint256 permission) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        if (!_tradeDealExists(tradeDealId)) return false;\n        if (user == address(0)) return false;\n        \n        // Contract owner always has all permissions\n        if (user == LibDiamond.contractOwner()) return true;\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        \n        // Check operation mode defaults\n        if (tradeDeal.operationMode == OperationMode.CENTRALIZED) {\n            // In centralized mode, only contract owner can withdraw funds\n            if (permission == PERMISSION_WITHDRAW_FUNDS) {\n                return user == LibDiamond.contractOwner();\n            }\n            \n            // Anyone can deposit funds or collateral in centralized mode\n            if (permission == PERMISSION_DEPOSIT_FUNDS || permission == PERMISSION_DEPOSIT_COLLATERAL) {\n                return true;\n            }\n        }\n        else if (tradeDeal.operationMode == OperationMode.SELF_SERVICE) {\n            // In self-service mode, borrowers can withdraw funds\n            if (permission == PERMISSION_WITHDRAW_FUNDS && _hasRole(tradeDealId, user, Role.BORROWER)) {\n                return true;\n            }\n            \n            // Anyone can deposit funds or collateral in self-service mode\n            if (permission == PERMISSION_DEPOSIT_FUNDS || permission == PERMISSION_DEPOSIT_COLLATERAL) {\n                return true;\n            }\n        }\n        \n        // For HYBRID and CUSTOM modes, check explicit permissions\n        return (tds.userPermissions[tradeDealId][user] & permission) != 0;\n    }\n    \n    /**\n     * @notice Extract the totalAmount from an NFT invoice metadata\n     * @param tokenId The token ID of the NFT invoice\n     * @return The totalAmount value from the metadata, or 0 if not found\n     */\n    function _getNFTInvoiceTotalAmount(uint256 tokenId) internal view returns (uint256) {\n        // Check if this token exists\n        require(IERC721(address(this)).ownerOf(tokenId) != address(0), \"Token does not exist\");\n        \n        // Get the totalAmount attribute using AttributeLib\n        AttributeStorage storage attributeStore = AttributeLib.attributeStorage();\n        AttributeContract storage attributeContract = attributeStore.attributes;\n        \n        // Try to get the \"totalAmount\" attribute\n        Attribute memory totalAmountAttr = AttributeLib._getAttribute(\n            attributeContract,\n            tokenId,\n            \"totalAmount\"\n        );\n        \n        // If the attribute exists and has a value, convert it to uint256\n        if (bytes(totalAmountAttr.value).length > 0) {\n            // Convert string to uint256\n            uint256 amount = _stringToUint(totalAmountAttr.value);\n            return amount;\n        }\n        \n        // Fallback logic - if totalAmount attribute is not found, check if there's an \"amount\" attribute\n        Attribute memory amountAttr = AttributeLib._getAttribute(\n            attributeContract,\n            tokenId,\n            \"amount\"\n        );\n        \n        if (bytes(amountAttr.value).length > 0) {\n            uint256 amount = _stringToUint(amountAttr.value);\n            return amount;\n        }\n        \n        // If no attributes found, return 0\n        return 0;\n    }\n    \n    /**\n     * @notice Helper function to convert a string to uint256\n     * @param s The string to convert\n     * @return result The converted uint256 value\n     */\n    function _stringToUint(string memory s) internal pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n        return result;\n    }\n    \n    // Return struct for self-service funding withdrawal\n    struct SelfServiceWithdrawalResult {\n        uint256 tradeDealId;\n        address recipient;\n        uint256 amount;\n    }\n    \n    /**\n     * @notice Allow borrowers to withdraw funds in self-service mode\n     * @param tradeDealId The ID of the trade deal\n     * @param borrower The address of the borrower\n     * @return Result struct with withdrawal details\n     */\n    function _withdrawTradeDealFundingSelf(uint256 tradeDealId, address borrower) internal returns (FundingWithdrawalResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.active, \"Trade deal is not active\");\n        require(tradeDeal.operationMode == OperationMode.SELF_SERVICE, \"Trade deal is not in self-service mode\");\n        require(_isTradeDealFunded(tradeDealId), \"Trade deal is not fully funded\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        \n        // Check if borrower is a participant and has the BORROWER role\n        require(_isTradeDealParticipant(tradeDealId, borrower), \"Not a participant in this trade deal\");\n        require(_hasRole(tradeDealId, borrower, Role.BORROWER), \"Must have borrower role to withdraw funds\");\n        \n        // Verify the borrower has deposited invoices as collateral\n        bool hasDepositedInvoice = false;\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        for (uint256 i = 0; i < invoices.length; i++) {\n            if (tds.invoiceDepositors[tradeDealId][invoices[i]] == borrower) {\n                hasDepositedInvoice = true;\n                break;\n            }\n        }\n        require(hasDepositedInvoice, \"Borrower has not deposited any invoices\");\n        \n        // Get token addresses\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Get the funding amount\n        uint256 fundingAmount = tds.tradeDealFundingTargets[tradeDealId];\n        \n        // Mark as withdrawn\n        tds.tradeDealFundingWithdrawn[tradeDealId] = true;\n        \n        // Distribute USDC via FeeDistributor: fees to receivers, adjusted principal to borrower\n        IFeeDistributor feeDistributor = IFeeDistributor(address(this));\n        (address adjustedReceiver, uint256 adjustedAmount, , ) = feeDistributor.distributeAmounts(borrower, fundingAmount);\n        require(adjustedReceiver == borrower, \"FeeDistributor: Adjusted amount sent to wrong receiver\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= fundingAmount;\n        \n        // Return result\n        FundingWithdrawalResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.recipient = borrower;\n        result.amount = adjustedAmount; // Amount is the adjusted principal received\n        return result;\n    }\n\n    // Helper function to create or get a Collateral token for a trade deal\n    function _createOrGetCollateralToken(uint256 tradeDealId, string memory symbol) internal returns (address) {\n        address collateralAddress = address(0);\n        \n        // First try to get the Collateral token address from the CollateralTokenFactoryFacet\n        (bool checkSuccess, bytes memory checkData) = address(this).staticcall(\n            abi.encodeWithSignature(\n                \"getCollateralTokenAddress(uint256)\",\n                tradeDealId\n            )\n        );\n        \n        // If the check was successful and returned a non-zero address, use that\n        if (checkSuccess && checkData.length > 0) {\n            address existingCollateralAddress = abi.decode(checkData, (address));\n            if (existingCollateralAddress != address(0)) {\n                return existingCollateralAddress;\n            }\n        }\n        \n        // If we still don't have a Collateral token address, try to create one\n        string memory tokenName = string(abi.encodePacked(symbol, \"-C\"));\n        string memory tokenSymbol = string(abi.encodePacked(symbol, \"-C\"));\n\n        // Call the CollateralTokenFactoryFacet to create a new Collateral token\n        (bool success, bytes memory data) = address(this).call(\n            abi.encodeWithSignature(\n                \"createCollateralToken(uint256,string,string,bool)\",\n                tradeDealId,\n                tokenName,\n                tokenSymbol,\n                true // Enable restrictions by default\n            )\n        );\n        \n        // If the call was successful, use the returned token address\n        if (success && data.length > 0) {\n            collateralAddress = abi.decode(data, (address));\n        }\n        \n        // If we still don't have a Collateral token address, try to get it again\n        if (collateralAddress == address(0)) {\n            (bool retrySuccess, bytes memory retryData) = address(this).staticcall(\n                abi.encodeWithSignature(\n                    \"getCollateralTokenAddress(uint256)\",\n                    tradeDealId\n                )\n            );\n            \n            // If the retry was successful and returned a non-zero address, use that\n            if (retrySuccess && retryData.length > 0) {\n                address retryCollateralAddress = abi.decode(retryData, (address));\n                if (retryCollateralAddress != address(0)) {\n                    collateralAddress = retryCollateralAddress;\n                }\n            }\n        }\n        \n        return collateralAddress;\n    }\n}\n"
    },
    "contracts/tokens/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract CollateralToken is ICollateral, ERC20Upgradeable, OwnableUpgradeable {\n\n    constructor() { _disableInitializers(); }\n\n    function mint(address to, uint256 amount) external virtual override onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external virtual override onlyOwner {\n        _burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual override(ERC20Upgradeable,ICollateral) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override(ERC20Upgradeable,ICollateral) returns (bool) {\n        return super.transferFrom(from, to, amount);\n    }\n\n    function approve(address spender, uint256 amount) public virtual override(ERC20Upgradeable,ICollateral) returns (bool) {\n        return super.approve(spender, amount);\n    }\n\n    function allowance(address owner, address spender) public view virtual override(ERC20Upgradeable,ICollateral) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n    function balanceOf(address account) public view virtual override(ERC20Upgradeable,ICollateral) returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    function totalSupply() public view virtual override(ERC20Upgradeable,ICollateral) returns (uint256) {\n        return super.totalSupply();\n    }\n}"
    },
    "contracts/tokens/CollateralTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./RestrictedCollateralToken.sol\";\n\n/**\n * @title CollateralTokenFactory\n * @dev Factory contract for creating new RestrictedCollateralToken instances using the minimal proxy pattern\n */\ncontract CollateralTokenFactory is Ownable {\n    // The implementation contract that will be cloned\n    address public implementation;\n    \n    // Mapping from trade deal ID to token address\n    mapping(uint256 => address) public tradeDealToToken;\n    \n    // Array of all created tokens\n    address[] public allTokens;\n    \n    // Event emitted when a new token is created\n    event TokenCreated(uint256 indexed tradeDealId, address indexed tokenAddress, string name, string symbol);\n    \n    /**\n     * @dev Constructor - sets the implementation contract\n     * @param _implementation The address of the implementation contract\n     */\n    constructor(address _implementation) Ownable(msg.sender) {\n        implementation = _implementation;\n    }\n    \n    /**\n     * @dev Set the implementation contract\n     * @param _implementation The address of the implementation contract\n     */\n    function setImplementation(address _implementation) external onlyOwner {\n        implementation = _implementation;\n    }\n    \n    /**\n     * @dev Create a new RestrictedCollateralToken\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     * @param _diamondAddress The address of the Diamond contract\n     * @param _tradeDealId The ID of the trade deal this token is associated with\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @return The address of the new token\n     */\n    function createToken(\n        string memory _name,\n        string memory _symbol,\n        address _diamondAddress,\n        uint256 _tradeDealId,\n        bool _restrictionsEnabled\n    ) external onlyOwner returns (address) {\n        // Check if a token already exists for this trade deal\n        require(tradeDealToToken[_tradeDealId] == address(0), \"CollateralTokenFactory: token already exists for this trade deal\");\n        \n        // Clone the implementation contract\n        address tokenAddress = Clones.clone(implementation);\n        \n        // Initialize the token\n        RestrictedCollateralToken(tokenAddress).initialize(\n            _name,\n            _symbol,\n            _diamondAddress,\n            _tradeDealId,\n            _restrictionsEnabled,\n            owner()\n        );\n\n\n        // Store the token address\n        tradeDealToToken[_tradeDealId] = tokenAddress;\n        allTokens.push(tokenAddress);\n        \n        // Emit an event\n        emit TokenCreated(_tradeDealId, tokenAddress, _name, _symbol);\n        \n        return tokenAddress;\n    }\n    \n    /**\n     * @dev Get the token address for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @return The address of the token\n     */\n    function getTokenAddress(uint256 _tradeDealId) external view returns (address) {\n        return tradeDealToToken[_tradeDealId];\n    }\n    \n    /**\n     * @dev Get the number of tokens created\n     * @return The number of tokens\n     */\n    function getTokenCount() external view returns (uint256) {\n        return allTokens.length;\n    }\n    \n    /**\n     * @dev Get a token address by index\n     * @param _index The index of the token\n     * @return The address of the token\n     */\n    function getTokenByIndex(uint256 _index) external view returns (address) {\n        require(_index < allTokens.length, \"CollateralTokenFactory: index out of bounds\");\n        return allTokens[_index];\n    }\n}"
    },
    "contracts/tokens/RestrictedCollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../identity/IdentityStorage.sol\";\nimport \"../tokens/CollateralToken.sol\";\n\n/**\n * @title RestrictedCollateralToken\n * @dev A Collateral token that can be restricted to only be held by participants of a specific trade deal\n */\ncontract RestrictedCollateralToken is CollateralToken {\n    // The address of the Diamond contract that contains the TradeDealFacet\n    address public diamondAddress;\n    \n    // The ID of the trade deal this token is associated with\n    uint256 public tradeDealId;\n    \n    // Whether to enforce restrictions on transfers\n    bool public restrictionsEnabled;\n\n    /**\n     * @dev Constructor - creates a new RestrictedCollateralToken\n     * Note: This is only used for the implementation contract, not for the proxies\n     */\n    constructor() {\n        // Disable initializers for the implementation contract\n        _disableInitializers();\n    }\n    \n    /**\n     * @dev Initialize the token with the given parameters\n     * @param _diamondAddress The address of the Diamond contract\n     * @param _tradeDealId The ID of the trade deal this token is associated with\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @param _owner The owner of the token\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _diamondAddress,\n        uint256 _tradeDealId,\n        bool _restrictionsEnabled,\n        address _owner\n    ) external initializer {\n        // Initialize the ERC20 token with the given name and symbol\n        __ERC20_init(_name, _symbol);\n        __Ownable_init(_owner);\n        diamondAddress = _diamondAddress;\n        tradeDealId = _tradeDealId;\n        restrictionsEnabled = _restrictionsEnabled;\n    }\n    \n    /**\n     * @dev Set whether to enforce restrictions on transfers\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     */\n    function setRestrictionsEnabled(bool _restrictionsEnabled) external onlyOwner {\n        restrictionsEnabled = _restrictionsEnabled;\n    }\n    \n    /**\n     * @dev Check if an address is allowed to hold tokens\n     * @param _address The address to check\n     * @return Whether the address is allowed to hold tokens\n     */\n    function isParticipant(address _address) public view returns (bool) {\n        // If restrictions are disabled, anyone can hold tokens\n        if (!restrictionsEnabled) {\n            return true;\n        }\n        \n        // Call the Diamond contract to check if the address is a participant in the trade deal\n        (bool success, bytes memory data) = diamondAddress.staticcall(\n            abi.encodeWithSignature(\"isTradeDealParticipant(uint256,address)\", tradeDealId, _address)\n        );\n        \n        // If the call failed, assume the address is not a participant\n        if (!success) {\n            return false;\n        }\n        \n        // Decode the result\n        return abi.decode(data, (bool));\n    }\n    \n    /**\n     * @dev Override the transfer function to enforce restrictions\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     * @return Whether the transfer was successful\n     */\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        return super.transfer(to, amount);\n    }\n    \n    /**\n     * @dev Override the transferFrom function to enforce restrictions\n     * @param from The address to transfer from\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     * @return Whether the transfer was successful\n     */\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        return super.transferFrom(from, to, amount);\n    }\n    \n    /**\n     * @dev Mint new tokens\n     * @param to The address to mint to\n     * @param amount The amount to mint\n     */\n    function mint(address to, uint256 amount) external override onlyOwner {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Burn tokens\n     * @param from The address to burn from\n     * @param amount The amount to burn\n     */\n    function burn(address from, uint256 amount) external override onlyOwner {\n        _burn(from, amount);\n    }\n    \n    /**\n     * @dev Override the approve function to maintain interface compatibility\n     * @param spender The address to approve\n     * @param amount The amount to approve\n     * @return Whether the approval was successful\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        return super.approve(spender, amount);\n    }\n    \n    /**\n     * @dev Override the allowance function to maintain interface compatibility\n     * @param owner The owner address\n     * @param spender The spender address\n     * @return The allowance\n     */\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n    \n    /**\n     * @dev Override the balanceOf function to maintain interface compatibility\n     * @param account The account to check\n     * @return The balance\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return super.balanceOf(account);\n    }\n    \n    /**\n     * @dev Override the totalSupply function to maintain interface compatibility\n     * @return The total supply\n     */\n    function totalSupply() public view override returns (uint256) {\n        return super.totalSupply();\n    }\n}"
    },
    "contracts/utilities/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/LibDiamond.sol\";\n\ncontract Modifiers {\n\n    modifier onlyOwner() {\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\n            \"not authorized to call function\");\n        _;\n    }\n\n    // Removed diamondOwner() function to avoid selector collision.\n    // Use owner() from OwnershipFacet (IERC173) instead.\n\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 11
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}