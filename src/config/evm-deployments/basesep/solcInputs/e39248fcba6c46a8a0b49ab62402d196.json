{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../token/ERC1155/IERC1155.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Metadata} from \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     * See sections 4 and 5 of https://datatracker.ietf.org/doc/html/rfc4648\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE, true);\n    }\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64Url `string` representation.\n     * Output is not padded with `=` as specified in https://www.rfc-editor.org/rfc/rfc4648[rfc4648].\n     */\n    function encodeURL(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE_URL, false);\n    }\n\n    /**\n     * @dev Internal table-agnostic conversion\n     */\n    function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // - `4 *`              -> 4 characters for each chunk\n        // This is equivalent to: 4 * Math.ceil(data.length / 3)\n        //\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 * data.length`  -> 4 characters for each chunk\n        // - ` + 2`             -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // This is equivalent to: Math.ceil((4 * data.length) / 3)\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        assembly (\"memory-safe\") {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guaratees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport \"./interfaces/IERC721Enumerable.sol\";\nimport \"./libraries/DiamondLib.sol\";\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { DiamondLib } from \"./libraries/DiamondLib.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { DiamondSettings } from \"./interfaces/IDiamond.sol\";\nimport { IERC173 } from \"./interfaces/IERC173.sol\";\n\n/**\n * @title Diamond\n * @dev Core diamond proxy contract implementing the EIP-2535 Diamond Standard\n * Functionality has been separated into facets:\n * - DiamondCutFacet: Handles diamond cut operations\n * - DiamondLoupeFacet: Provides introspection functions\n * - OwnershipFacet: Handles ownership operations\n */\ncontract Diamond is Initializable, IERC173 {\n    /**\n     * @notice Initialize the Diamond contract\n     * @param _owner The owner of the contract\n     * @param params Diamond settings including name and symbol\n     * @param _facets The initial facets to add\n     * @param diamondInit The initialization contract\n     * @param _calldata The initialization calldata\n     */\n    function initialize(\n        address _owner, \n        DiamondSettings memory params,\n        IDiamondCut.FacetCut[] memory _facets,\n        address diamondInit,\n        bytes calldata _calldata\n    ) public initializer {\n        // Set up interfaces\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC165).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC173).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721Metadata).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721Enumerable).interfaceId] = true;\n\n        // Initialize the diamond\n        LibDiamond.diamondCut(_facets, diamondInit, _calldata);\n\n        // Set the owner\n        LibDiamond.setContractOwner(_owner);\n\n        // Set the symbol and name of the diamond\n        DiamondLib.diamondStorage().diamondContract.settings.owner = _owner;\n        DiamondLib.diamondStorage().diamondContract.metadata['symbol'] = params.symbol;\n        DiamondLib.diamondStorage().diamondContract.metadata['name'] = params.name;\n\n        // Initialize the upgrade timelock\n        LibDiamond.initializeUpgradeTimelock(LibDiamond.DEFAULT_UPGRADE_TIMELOCK);\n    }\n\n    /**\n     * @notice Transfer ownership to a new address\n     * @param _newOwner The new owner address\n     */\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    /**\n     * @notice Get the current contract owner\n     * @return owner_ The current owner address\n     */\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    /**\n     * @notice Get this contract's address\n     * @return This contract's address\n     */\n    function diamondAddress() external view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Diamond Proxy fallback function\n     * Find facet for function that is called and execute the\n     * function using delegatecall\n     */\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // Get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // Get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        \n        // Execute external function from facet using delegatecall and return any value\n        assembly {\n            // Copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // Execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // Get any return value\n            returndatacopy(0, 0, returndatasize())\n            // Return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    // Allow contract to receive ETH\n    receive() external payable {}\n}\n"
    },
    "contracts/DiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./libraries/DiamondLib.sol\";\nimport \"./libraries/DiamondFactoryLib.sol\";\nimport \"./Diamond.sol\";\nimport \"./interfaces/IDiamondFactory.sol\";\nimport \"./interfaces/IMetadata.sol\";\nimport \"./interfaces/IControllable.sol\";\n\nimport \"./utilities/Controllable.sol\";\n\n/// @title Diamond Factory\n/// @notice This contract is used to create new Diamond contracts.\ncontract DiamondFactory is Initializable, Controllable {\n\n    using DiamondFactoryLib for DiamondFactoryLib.DiamondFactoryStorage;\n\n    event DiamondCreated(\n        address indexed factory,\n        address indexed diamond,\n        string indexed symbol,\n        DiamondSettings settings\n    );\n\n    event DiamondAdd(\n        address indexed factory,\n        string indexed symbol,\n        address indexed diamond\n    );\n\n    event DiamondRemoved(\n        address indexed factory,\n        string indexed symbol,\n        address indexed diamond\n    );\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @notice initiiate the factory\n    /// @param initData the initialization data for the factory\n    function initialize(DiamondFactoryInit memory initData) public initializer {\n        DiamondFactoryLib.diamondFactoryStorage()._addFacetSet(\n            initData.setName,\n            initData.facetAddresses\n        );\n        DiamondFactoryLib\n            .diamondFactoryStorage()\n            .contractData\n            .defaultFacetSet = initData.setName;\n    }\n\n    /// @notice get the facets for the diamond\n    function getFacets(string memory facetSet)\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return\n            DiamondFactoryLib.diamondFactoryStorage().contractData.facetsToAdd[\n                facetSet\n            ];\n    }\n\n    /// @notice set a number of template facets on this factory\n    /// @param facetSet the index of the facet to set\n    /// @param facetAddress the facet to set\n    function setFacets(\n        string memory facetSet,\n        IDiamondCut.FacetCut[] memory facetAddress\n    ) external onlyController {\n        DiamondFactoryLib\n            .diamondFactoryStorage()\n            .contractData\n            .defaultFacetSet = facetSet;\n        DiamondFactoryLib.diamondFactoryStorage()._addFacetSet(\n            facetSet,\n            facetAddress\n        );\n    }\n\n    /// @notice remote a facet set from the factory\n    /// @param facetSet the facet set to remove\n    function removeFacets(string memory facetSet) external onlyController {\n        delete DiamondFactoryLib\n            .diamondFactoryStorage()\n            .contractData\n            .facetsToAdd[facetSet];\n    }\n\n    /// @notice get the address of the diamond\n    /// @param symbol the symbol of the diamond\n    /// @return the address of the diamond\n    function getDiamondAddress(string memory symbol)\n        public\n        view\n        returns (address)\n    {\n        return\n            DiamondFactoryLib.diamondFactoryStorage()._getDiamondAddress(\n                address(this),\n                symbol,\n                type(Diamond).creationCode\n            );\n    }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param params diamond init parameters\n    /// @param diamondInit the diamond init contract\n    /// @param _calldata the calldata to pass to the diamond init contract\n    function createFromSet(\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        string memory facets\n    ) public onlyController returns (address payable diamondAddress) {\n        // get the factory storage context, error if token already exists\n        require(\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[params.symbol] == address(0),\n            \"exists\"\n        );\n        diamondAddress = DiamondFactoryLib.diamondFactoryStorage().createFromSet(\n            address(this),\n            params,\n            diamondInit,\n            _calldata,\n            type(Diamond).creationCode,\n            facets\n        );\n        emit DiamondCreated(address(this), diamondAddress, params.symbol, params);\n    }\n\n    /// @notice check if the token exists\n    /// @param symbol the symbol of the diamond to check\n    function exists(string memory symbol) public view returns (bool) {\n        return\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[symbol] != address(0);\n    }\n\n    /// @notice get all the symbols from the factory\n    /// @return the symbols\n    function symbols() public view returns (string[] memory) {\n        return\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondSymbols;\n    }\n\n}\n"
    },
    "contracts/facets/ClaimTopicsRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IClaimTopicsRegistry.sol\";\nimport \"../utilities/Modifiers.sol\";\nimport \"../identity/IdentityStorage.sol\";\n\n/// @title ClaimTopicsRegistryFacet\n/// @notice This contract is used to manage the claim topics registry\ncontract ClaimTopicsRegistryFacet is IClaimTopicsRegistry, Modifiers {\n\tusing IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    /// @notice Add a claim topic\n    /// @param _claimTopic The claim topic to add\n    /// @dev Only the owner can call this function\n    function addClaimTopic(uint256 _claimTopic) external override onlyOwner {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(!_storage.hasClaimTopic(_claimTopic), \"Claim topic already exists\");\n        _storage.addClaimTopic(_claimTopic);\n        emit ClaimTopicAdded(_claimTopic);\n    }\n\n    /// @notice Remove a claim topic\n    /// @param _claimTopic The claim topic to remove\n    /// @dev Only the owner can call this function\n    function removeClaimTopic(uint256 _claimTopic) external override onlyOwner {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_claimTopic != 0, \"Cannot remove claim topic 0\");\n        require(_storage.hasClaimTopic(_claimTopic), \"Claim topic does not exist\");\n        _storage.removeClaimTopic(_claimTopic);\n    }\n\n    /// @notice Get the claim topics\n    /// @return claimTopics The claim topics\n    function getClaimTopics() external view override returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.topicList;\n    }\n\n    function hasClaimTopicAssigned(uint256 _claimTopic) external view returns (bool) {\n         IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.hasClaimTopic(_claimTopic);\n    }\n}"
    },
    "contracts/facets/CollateralTokenFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utilities/Modifiers.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../tokens/CollateralTokenFactory.sol\";\nimport \"../tokens/RestrictedCollateralToken.sol\";\nimport \"../identity/IdentityStorage.sol\";\n\n/**\n * @title CollateralTokenFactoryFacet\n * @dev Diamond facet for creating and managing RestrictedCollateralToken instances\n */\ncontract CollateralTokenFactoryFacet is Modifiers {\n    // Event emitted when a new token is created\n    event CollateralTokenCreated(uint256 indexed tradeDealId, address indexed tokenAddress, string name, string symbol);\n    \n    // Event emitted when the factory is initialized\n    event CollateralTokenFactoryInitialized(address indexed factoryAddress);\n    \n    // Storage structure for the CollateralTokenFactoryFacet\n    struct CollateralTokenFactoryStorage {\n        address factoryAddress;\n        mapping(uint256 => address) tradeDealToToken;\n    }\n    \n    // Returns the storage slot for the CollateralTokenFactoryStorage\n    function collateralTokenFactoryStorage() internal pure returns (CollateralTokenFactoryStorage storage ds) {\n        bytes32 position = keccak256(\"collateral.collateralTokenFactory.storage\");\n        assembly {\n            ds.slot := position\n        }\n    }\n    \n    /**\n     * @dev Constructor - initializes the factory\n     * This is automatically called when the facet is added to the diamond\n     */\n    function CollateralTokenFactoryFacet_init() external {\n        require(collateralTokenFactoryStorage().factoryAddress == address(0), \"CollateralTokenFactoryFacet: already initialized\");\n        // Create a new CollateralTokenFactory\n        RestrictedCollateralToken implementation = new RestrictedCollateralToken();\n        CollateralTokenFactory factory = new CollateralTokenFactory(address(implementation));\n        \n        // Set the factory address\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        ds.factoryAddress = address(factory);\n        \n        // Emit event\n        emit CollateralTokenFactoryInitialized(address(factory));\n    }\n    \n    /**\n     * @dev Get the CollateralTokenFactory contract address\n     * @return The address of the CollateralTokenFactory contract (automatically created in the constructor)\n     */\n    function getCollateralTokenFactory() external view returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        return ds.factoryAddress;\n    }\n    \n    /**\n     * @dev Create a new RestrictedCollateralToken for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @return The address of the new token\n     */\n    function createCollateralToken(\n        uint256 _tradeDealId,\n        string memory _name,\n        string memory _symbol,\n        bool _restrictionsEnabled\n    ) external onlyOwner returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Check if the factory is set\n        require(ds.factoryAddress != address(0), \"CollateralTokenFactoryFacet: factory not set\");\n        \n        // Check if a token already exists for this trade deal\n        require(ds.tradeDealToToken[_tradeDealId] == address(0), \"CollateralTokenFactoryFacet: token already exists for this trade deal\");\n        \n        // Create the token\n        address tokenAddress = CollateralTokenFactory(ds.factoryAddress).createToken(\n            _name,\n            _symbol,\n            msg.sender, // Use the caller's address as the diamond address\n            _tradeDealId,\n            _restrictionsEnabled\n        );\n        \n        // Store the token address\n        ds.tradeDealToToken[_tradeDealId] = tokenAddress;\n        \n        // Emit an event\n        emit CollateralTokenCreated(_tradeDealId, tokenAddress, _name, _symbol);\n        \n        return tokenAddress;\n    }\n    \n    /**\n     * @dev Get the token address for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @return The address of the token\n     */\n    function getCollateralTokenAddress(uint256 _tradeDealId) external view returns (address) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // First check the local mapping\n        if (ds.tradeDealToToken[_tradeDealId] != address(0)) {\n            return ds.tradeDealToToken[_tradeDealId];\n        }\n        \n        // If not found locally, check the factory\n        if (ds.factoryAddress != address(0)) {\n            return CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        return address(0);\n    }\n    \n    /**\n     * @dev Set restrictions for a token\n     * @param _tradeDealId The ID of the trade deal\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     */\n    function setCollateralTokenRestrictions(uint256 _tradeDealId, bool _restrictionsEnabled) external onlyOwner {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Get the token address\n        address tokenAddress = ds.tradeDealToToken[_tradeDealId];\n        if (tokenAddress == address(0) && ds.factoryAddress != address(0)) {\n            tokenAddress = CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        // Check if the token exists\n        require(tokenAddress != address(0), \"CollateralTokenFactoryFacet: token does not exist for this trade deal\");\n        \n        // Set the restrictions\n        RestrictedCollateralToken(tokenAddress).setRestrictionsEnabled(_restrictionsEnabled);\n    }\n    \n    /**\n     * @dev Check if an address is a participant in a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @param _address The address to check\n     * @return Whether the address is a participant\n     */\n    function isCollateralTokenParticipant(uint256 _tradeDealId, address _address) external view returns (bool) {\n        CollateralTokenFactoryStorage storage ds = collateralTokenFactoryStorage();\n        \n        // Get the token address\n        address tokenAddress = ds.tradeDealToToken[_tradeDealId];\n        if (tokenAddress == address(0) && ds.factoryAddress != address(0)) {\n            tokenAddress = CollateralTokenFactory(ds.factoryAddress).getTokenAddress(_tradeDealId);\n        }\n        \n        // Check if the token exists\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n        \n        // Check if the address is a participant\n        return RestrictedCollateralToken(tokenAddress).isParticipant(_address);\n    }\n}"
    },
    "contracts/facets/FeeDistributorFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"../libraries/FeeDistributorLib.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../utilities/Modifiers.sol\";\nimport \"../identity/IdentityStorage.sol\"; // Needed for storage access via LibDiamond potentially\n\n/**\n * @title FeeDistributorFacet\n * @dev A Diamond facet for managing and executing fee distributions.\n */\ncontract FeeDistributorFacet is IFeeDistributor, Modifiers {\n\n    /**\n     * @notice Initializes the Fee Distributor settings.\n     * @dev Should only be called once, typically during deployment. Only callable by the contract owner.\n     * @param _distributionToken Address of the ERC20 token to be distributed (e.g., USDC). Cannot be address(0).\n     * @param _totalWeightBasis The basis for fee weights (e.g., 10000 for basis points). Must be greater than 0.\n     */\n    function initializeFeeDistributor(\n        address _distributionToken,\n        uint256 _totalWeightBasis\n    ) external onlyOwner {\n        require(_distributionToken != address(0), \"FeeDistributor: Distribution token cannot be zero address\");\n        FeeDistributorLib._initializeFeeDistributor(\n            IdentitySystemStorage.diamondStorage(),\n            _distributionToken,\n            _totalWeightBasis\n        );\n        // Optionally emit an event here if needed\n        emit FeeDistributorInitialized(_distributionToken, _totalWeightBasis);\n    }\n\n    /**\n     * @notice Sets the addresses that will receive fees and their corresponding weights.\n     * @dev Only callable by the contract owner. Weights determine the proportion of fees.\n     * @param _feeReceivers Array of addresses to receive fees.\n     * @param _feeWeights Array of weights corresponding to each receiver.\n     */\n    function setFeeReceivers(\n        address[] calldata _feeReceivers,\n        uint256[] calldata _feeWeights\n    ) external override onlyOwner {\n        // TODO: Call FeeDistributorLib._setFeeReceivers and handle return data/event\n        // Pass ds and capture return values for the event\n        (address[] memory receivers, uint256[] memory weights) = FeeDistributorLib._setFeeReceivers(IdentitySystemStorage.diamondStorage(), _feeReceivers, _feeWeights);\n        // Emit event with the returned data\n        emit FeeReceiversSet(receivers, weights);\n    }\n\n    /**\n     * @notice Gets the current fee receivers and their weights.\n     * @return feeReceivers Array of addresses currently set to receive fees.\n     * @return feeWeights Array of weights corresponding to each receiver.\n     */\n    function getFeeReceivers()\n        external\n        view\n        override\n        returns (\n            address[] memory feeReceivers,\n            uint256[] memory feeWeights\n        )\n    {\n        // TODO: Call FeeDistributorLib._getFeeReceivers\n        // Pass ds\n        (feeReceivers, feeWeights) = FeeDistributorLib._getFeeReceivers(IdentitySystemStorage.diamondStorage());\n        return (feeReceivers, feeWeights);\n    }\n\n    /**\n     * @notice Calculates the adjusted principal amount and individual fee amounts based on the total principal.\n     * @dev This function is view-only and does not perform any state changes or transfers.\n     * @param principalAmount The total amount before fee deduction.\n     * @return adjustedAmount The principal amount remaining after deducting total fees.\n     * @return feeAmounts Array of individual fee amounts calculated for each receiver.\n     */\n    function calculateAmounts(uint256 principalAmount)\n        external\n        view\n        override\n        returns (\n            uint256 adjustedAmount,\n            uint256[] memory feeAmounts\n        )\n    {\n        // TODO: Call FeeDistributorLib._calculateAmounts\n        // Pass ds\n        (adjustedAmount, feeAmounts) = FeeDistributorLib._calculateAmounts(IdentitySystemStorage.diamondStorage(), principalAmount);\n        return (adjustedAmount, feeAmounts);\n    }\n\n    /**\n     * @notice Distributes a principal amount, sending calculated fees to receivers and the adjusted amount to the principal receiver.\n     * @dev Requires the contract to hold sufficient funds (e.g., USDC) or allowance to perform the transfers.\n     * @param principalAmountReceiver The address to receive the adjusted principal amount.\n     * @param _principalAmount The total amount to be distributed.\n     * @return adjustedAmountReceiver The address that received the adjusted principal amount.\n     * @return adjustedAmount The adjusted principal amount transferred.\n     * @return feeReceivers The addresses that received the fee amounts.\n     * @return feeAmounts The individual fee amounts transferred.\n     */\n    function distributeAmounts(\n        address principalAmountReceiver,\n        uint256 _principalAmount\n    ) external override returns (\n        address adjustedAmountReceiver,\n        uint256 adjustedAmount,\n        address[] memory feeReceivers,\n        uint256[] memory feeAmounts\n    ) {\n        // TODO: Call FeeDistributorLib._distributeAmounts and handle return data/event\n        // Pass ds\n        (adjustedAmountReceiver, adjustedAmount, feeReceivers, feeAmounts) = FeeDistributorLib._distributeAmounts(IdentitySystemStorage.diamondStorage(), address(this), principalAmountReceiver, _principalAmount); // Add address(this)\n\n        // Placeholder: Emit event based on library return or directly if lib doesn't return data\n        emit AmountsDistributed(\n            principalAmountReceiver,\n            _principalAmount, // Original amount passed in\n            adjustedAmountReceiver,\n            adjustedAmount,\n            feeReceivers,\n            feeAmounts\n        );\n\n        return (adjustedAmountReceiver, adjustedAmount, feeReceivers, feeAmounts);\n    }\n}\n"
    },
    "contracts/facets/GemforceMinterFacet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\nimport \"../libraries/AttributeLib.sol\";\nimport \"../interfaces/IGemforceMinterFacet.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"../utilities/Modifiers.sol\";\nimport \"../interfaces/IAttribute.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n\n/// @title GemforceMinterFacet\n/// @notice A facet for minting tokens with customizable attributes in the Gemforce system\n/// @dev This facet provides functionality for token minting with associated metadata\n///      as attributes. It interacts with the diamond storage pattern through IdentitySystemStorage\n///      for token state and AttributeLib for storing token attributes. This facet implements\n///      the IGemforceMinterFacet interface and inherits access control from Modifiers.\n///      Only the contract owner can mint tokens through this facet.\ncontract GemforceMinterFacet is Modifiers, IGemforceMinterFacet {\n\n    using Strings for uint256;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    /**\n     * @notice Mint a new token with customizable attributes in a single transaction\n     * @dev This function allows the contract owner to mint a new token and immediately\n     *      assign attributes to it. The minting process involves:\n     *      1. Getting the next available token ID\n     *      2. Emitting the GemforceMinted event before any state changes\n     *      3. Minting the token through the identity system\n     *      4. Assigning all specified attributes to the token\n     *\n     *      The token is minted directly to the caller (owner) and all attributes are\n     *      stored through the AttributeLib library. Each attribute consists of a trait\n     *      type (key) and a value that can be used for token metadata or functionality.\n     *\n     * @param metadata Array of Attribute structs to assign to the token, each containing\n     *                a trait type and value\n     * @return The ID of the newly minted token\n     * @custom:security Only callable by the contract owner\n     * @custom:event Emits GemforceMinted with token ID, recipient, and all attributes\n     */\n    function gemforceMint(Attribute[] memory metadata) external override onlyOwner returns (uint256) {\n        // Get the identity system storage\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n\n        // Get the tokenId that will be assigned to the new token\n        uint256 tokenId = identitySystem.erc721Contract._currentIndex;\n        \n        // Emit the minting event before state changes\n        emit GemforceMinted(tokenId, msg.sender, metadata);\n\n        // Mint the new token\n        identitySystem._mint(msg.sender, msg.sender, 1, \"0x\", true);\n        \n        // Assign attributes to the minted token\n        for (uint256 i = 0; i < metadata.length; i++) {\n            AttributeLib._setAttribute(AttributeLib.attributeStorage().attributes, tokenId, metadata[i]);\n        }\n\n        // Return the token ID\n        return tokenId;\n    }\n    \n}"
    },
    "contracts/facets/IdentityRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IIdentityRegistry.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"../utilities/Modifiers.sol\";\n\nimport { IIdentityRegistry, IIdentity } from \"../interfaces/IIdentityRegistry.sol\";\n\n/**\n * @title IdentityRegistryFacet\n * @notice Manages a decentralized identity registry with claim verification capabilities\n * @dev This contract is implemented as a diamond facet following the EIP-2535 Diamond Standard.\n *      It provides functionality for managing digital identities and their associated claims.\n *      The identity system follows a claims-based model where trusted issuers can make\n *      verifiable claims about identities. The contract enforces permissions so that only\n *      authorized issuers can manage specific claim types.\n *\n *      Key functionalities include:\n *      - Adding and removing identities to/from the registry\n *      - Managing claims (attestations) about identities\n *      - Verifying identity status and claim ownership\n *      - Access control for trusted issuers\n *\n *      All state is stored via the diamond storage pattern in IdentitySystemStorage.\n */\ncontract IdentityRegistryFacet is IIdentityRegistry, Modifiers {\n\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    /**\n     * @dev Emitted when contract addresses are configured\n     */\n    event ContractAddressesSet();\n\n    /**\n     * @notice Restricts function access to trusted issuers only\n     * @dev A trusted issuer is an address that has been approved to issue and manage\n     *      claims within the identity system. This is a basic authorization check\n     *      that does not validate claim topic permissions.\n     */\n    modifier isTrustedIssuer() {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.isTrustedIssuer(msg.sender), \"Not trusted issuer\");\n        _;\n    }\n\n    /**\n     * @notice Restricts function access to issuers trusted for a specific claim topic\n     * @dev Ensures the caller is not only a trusted issuer but also specifically\n     *      authorized to issue or manage claims of the specified topic. This provides\n     *      a more granular level of access control.\n     * @param _claimTopic The specific claim topic that requires authorization\n     */\n    modifier isTrustedIssuerForClaimTopic(uint256 _claimTopic) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.isTrustedIssuer(msg.sender), \"Not a trusted issuer\");\n        require(_storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopic), \"Issuer not authorized for claim topic\");\n        _;\n    }\n\n    /**\n     * @notice Restricts function access to issuers trusted for multiple claim topics\n     * @dev Ensures the caller is authorized to issue or manage claims for all the\n     *      specified topics. If the caller is not authorized for even one topic,\n     *      the entire operation will be rejected.\n     * @param _claimTopics Array of claim topics that require authorization\n     */\n    modifier isTrustedIssuerForClaimTopics(uint256[] memory _claimTopics) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        for (uint256 i = 0; i < _claimTopics.length; i++) {\n            require(_storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopics[i]), \"Issuer not authorized for claim topic\");\n        }\n        _;\n    }\n\n    /**\n     * @dev Empty constructor as initialization happens through the diamond\n     */\n    constructor() {}\n\n    /**\n     * @notice Validates that a user address is registered and associated with an identity\n     * @dev Internal validation helper that checks both for zero addresses and\n     *      whether the address is linked to a valid identity in the registry\n     * @param _userAddress The user address to validate\n     */\n    function _validateUserAddress(address _userAddress) internal view {\n        require(_userAddress != address(0), \"User address cannot be zero\");\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage._getIdentity(_userAddress) != address(0), \"User address not associated with an identity\");\n    }\n\n    /**\n     * @notice Resolves an address to its associated identity address\n     * @dev If the address is registered in the identity system, returns the associated\n     *      identity address. Otherwise, returns the input address itself. This is useful\n     *      for functions that can accept either a user address or a direct identity address.\n     * @param _address The address to resolve (user address or identity address)\n     * @return The resolved identity address\n     */\n    function _getIdentityAddress(address _address) internal view returns (address) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address identityAddress = _storage._getIdentity(_address);\n        return identityAddress != address(0) ? identityAddress : _address;\n    }\n\n    /**\n     * @notice Adds a new identity to the registry (internal implementation)\n     * @dev Internal function that handles the actual logic of adding an identity.\n     *      This function is called by both addIdentity and batchAddIdentity.\n     *      It performs the necessary storage updates and emits the appropriate event.\n     * @param _issuer The address of the trusted issuer adding the identity\n     * @param _address The address of the user who owns the identity\n     * @param identityData The IIdentity contract instance representing the identity\n     */\n    function _addIdentity(address _issuer, address _address, IIdentity identityData) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.identities[_address] == address(0), \"Identity already exists\");\n        _storage.identities[_address] = address(identityData);\n        _storage.identityOwners.push(_address);\n        _storage.identityOwnersMap[address(identityData)] = _address;\n        emit IdentityAdded(_issuer, _address, identityData);\n    }\n\n    /**\n     * @notice Adds a new identity to the registry\n     * @dev Registers a new identity in the system, associating the provided\n     *      address with an identity contract. This operation can only be performed\n     *      by approved trusted issuers. The function checks that the address is valid\n     *      and that no identity is already registered for the given address.\n     *\n     * @param _address The address of the user who will own the identity\n     * @param identityData The IIdentity contract instance representing the identity\n     * @custom:access Restricted to trusted issuers (via isTrustedIssuer modifier)\n     * @custom:event Emits IdentityAdded event upon successful registration\n     */\n    function addIdentity(address _address, IIdentity identityData) external override isTrustedIssuer {\n        require(_address != address(0), \"Invalid identity address\");\n        _addIdentity(msg.sender, _address, identityData);\n    }\n\n    /**\n     * @notice Removes an identity from the registry\n     * @dev Deletes an identity from the system, removing all its associated data\n     *      and mappings. This operation can only be performed by trusted issuers.\n     *      The function performs several cleanup steps:\n     *      1. Removes the identity from the identities mapping\n     *      2. Updates the owner mapping\n     *      3. Removes the identity from the identityOwners array (using swap and pop)\n     *\n     * @param _identity The address of the identity to remove\n     * @custom:access Restricted to trusted issuers (via isTrustedIssuer modifier)\n     * @custom:event Emits IdentityRemoved event upon successful removal\n     */\n    function removeIdentity(address _identity) external override isTrustedIssuer {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.identities[_identity] != address(0), \"Identity does not exist\");\n        \n        // Find the owner of this identity and update mapping\n        address owner = _storage.identityOwnersMap[_identity];\n        if (owner != address(0)) {\n            delete _storage.identityOwnersMap[_identity];\n        }\n        \n        // Remove from identities mapping\n        delete _storage.identities[_identity];\n        \n        // Remove from identityOwners array using swap and pop\n        for (uint256 i = 0; i < _storage.identityOwners.length; i++) {\n            if (_storage.identityOwners[i] == _identity) {\n                // Swap with the last element\n                address lastIdentity = _storage.identityOwners[_storage.identityOwners.length - 1];\n                _storage.identityOwners[i] = lastIdentity;\n                \n                // Update the mapping for the swapped element\n                if (i < _storage.identityOwners.length - 1) {\n                    // Only update the map if we actually moved an element\n                    // (i.e., we're not removing the last element)\n                    _storage.identityOwnersMap[lastIdentity] = owner;\n                }\n                \n                // Remove the last element\n                _storage.identityOwners.pop();\n                break;\n            }\n        }\n        \n        emit IdentityRemoved(msg.sender, _identity, IIdentity(_identity));\n    }\n\n    /// @notice get the identity data contract address of an identity\n    /// @param _userAddress address of the identity user\n    /// @return identityData address of the identity data contract\n    function identity(address _userAddress) external view override returns (address) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._getIdentity(_userAddress);\n    }\n\n    /// @notice batch add identities to the registry\n    /// @param _addresses array of addresses of the identities\n    /// @param identityDatas array of addresses of the identity data contracts\n    /// @dev this function can only be called by a trusted issuer\n    function batchAddIdentity(address[] calldata _addresses, IIdentity[] calldata identityDatas) external override isTrustedIssuer {\n        require(_addresses.length == identityDatas.length, \"Arrays length mismatch\");\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            _addIdentity(msg.sender, _addresses[i], identityDatas[i]);\n        }\n    }\n\n    function addClaim(address _address, uint256 _claimTopic, bytes calldata _claim) external override isTrustedIssuerForClaimTopic(_claimTopic) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        require(_storage.getIdentityOwner(idObj) != address(0), \"Identity does not exist\");\n        require(_storage.claims[idObj][_claimTopic] == 0, \"Claim already exists\");\n        _storage.claims[idObj][_claimTopic] = _claimTopic;\n        _storage.claimList[idObj].push(_claimTopic);\n        emit ClaimAdded(msg.sender, idObj, _claimTopic, _claim);\n    }\n\n    function setClaims(address _address, uint256[] memory _claims) external override isTrustedIssuerForClaimTopics(_claims) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        require(_storage.getIdentityOwner(idObj) != address(0), \"Identity does not exist\");\n        for (uint256 i = 0; i < _claims.length; i++) {\n            require(_storage.claims[idObj][_claims[i]] == 0, \"Claim already exists\");\n            for(uint256 j = 0; j < _storage.topicList.length; j++) {\n                if (_storage.topicList[j] == _claims[i]) {\n                    _storage.claims[idObj][_claims[i]] = _claims[i];\n                    _storage.claimList[idObj].push(_claims[i]);\n                    emit ClaimAdded(msg.sender, idObj, _claims[i], \"\");\n                }\n            }\n        }\n        emit ClaimsSet(msg.sender, idObj, _claims);\n    }\n\n    function unsetClaims(address _address, uint256[] memory _claims) external override isTrustedIssuerForClaimTopics(_claims) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        require(_storage.getIdentityOwner(idObj) != address(0), \"Identity does not exist\");\n\n        uint256[] storage claimList = _storage.claimList[idObj];\n        uint256[] memory removedClaims = new uint256[](_claims.length);\n        uint256 removedCount = 0;\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            uint256 claimToRemove = _claims[i];\n            for (uint256 j = 0; j < claimList.length; j++) {\n                if (claimList[j] == claimToRemove) {\n                    // Move the last element to the position of the element to be removed\n                    claimList[j] = claimList[claimList.length - 1];\n                    // Remove the last element\n                    claimList.pop();\n\n                    // If you need to modify _storage.claims as well:\n                    delete _storage.claims[idObj][claimToRemove];\n\n                    removedClaims[removedCount] = claimToRemove;\n                    removedCount++;\n\n                    // Decrement j to recheck the current position, which now contains a new element\n                    j--;\n                    break;\n                }\n            }\n        }\n\n        // Resize removedClaims array to actual number of removed claims\n        assembly {\n            mstore(removedClaims, removedCount)\n        }\n\n        emit ClaimsRemoved(msg.sender, idObj, removedClaims);\n    }\n\n    function removeClaim(address _address, uint256 _claimTopic) external override isTrustedIssuerForClaimTopic(_claimTopic) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        require(_storage.getIdentityOwner(idObj) != address(0), \"Identity does not exist\");\n        require(idObj != msg.sender, \"Cannot set claims for self\");\n        \n        uint256[] storage claimList = _storage.claimList[idObj];\n        for (uint256 i = 0; i < claimList.length; i++) {\n            if (claimList[i] == _claimTopic) {\n                // Move the last element to the position of the element to be removed\n                claimList[i] = claimList[claimList.length - 1];\n                // Remove the last element\n                claimList.pop();\n                \n                // If you need to modify _storage.claims as well:\n                delete _storage.claims[idObj][_claimTopic];\n                \n                emit ClaimRemoved(msg.sender, idObj, _claimTopic);\n                return;\n            }\n        }\n        \n        revert(\"Claim does not exist\");\n    }\n\n    /// @notice does an identity exist\n    /// @param _userAddress address of the identity user\n    /// @return bool\n    function contains(address _userAddress) external view override returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._getIdentity(_userAddress) != address(0);\n    }\n\n    function containsAddress(address _userAddress) external view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._getIdentity(_userAddress) != address(0);\n    }\n\n    /// @notice is an identity verified\n    /// @param _address address of the identity user or identity contract\n    /// @return bool\n    function isVerified(address _address) external view override returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._getIdentity(_address) != address(0);\n    }\n\n    /// @notice get the users of the registry\n    /// @return array of addresses of the users\n    function getRegistryUsers() external view override returns (address[] memory) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.identityOwners;\n    }\n\n    /// @notice is the user a registry user\n    /// @param _registryUser address of the registry user\n    /// @return bool\n    function isRegistryUser(address _registryUser) external view override returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._getIdentity(_registryUser) != address(0);\n    }\n\n    function getClaims(address _address) external view override returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        return _storage.claimList[idObj];\n    }\n\n    function getClaim(address _address, uint256 _claimTopic) external view override returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        return _storage.claims[idObj][_claimTopic];\n    }\n\n    function hasClaim(address _address, uint256 _claimTopic) external view override returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        address idObj = _getIdentityAddress(_address);\n        for (uint256 i = 0; i < _storage.claimList[idObj].length; i++) {\n            if (_storage.claimList[idObj][i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/facets/MarketplaceFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// erc721 interface\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../utilities/Controllable.sol\";\nimport \"../interfaces/IMarketplace.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Modifiers} from \"../utilities/Modifiers.sol\";\nimport {IERC721Permissioned} from \"../interfaces/IERC721Permissioned.sol\";\n\n/**\n * @title MarketplaceFacet\n * @dev Provides NFT marketplace functionality for the Gemforce diamond.\n *      This facet enables users to list, purchase, and delist NFTs with\n *      support for both ETH and ERC20 token payments. It includes a\n *      configurable fee distribution system where a portion of each sale\n *      can be sent to multiple fee receivers.\n *\n *      The facet interacts with the IdentitySystemStorage for NFT transfers\n *      and marketplace state management. It implements reentrancy protection\n *      via the ReentrancyGuard to ensure security during payment operations.\n */\ncontract MarketplaceFacet is IMarketplace, Modifiers, ReentrancyGuard {\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Structure defining a fee receiver for marketplace sales\n     * @param receiver The address that will receive the fee\n     * @param sharePerMillion The fee share in parts per million (e.g., 10,000 = 1%)\n     */\n    /**\n     * @dev Array of fee receivers who get a percentage of each sale\n     * @notice The total of all shares must not exceed SHARE_PRECISION (100%)\n     */\n    FeeReceiver[] private feeReceivers;\n\n    /**\n     * @dev Precision for fee calculations (1,000,000 = 100%)\n     * @notice All share calculations use this as denominator (e.g., 10,000 = 1%)\n     */\n    uint256 private constant SHARE_PRECISION = 1_000_000;\n\n    /**\n     * @dev Emitted when the marketplace is initialized with fee receivers\n     * @param feeReceivers Array of fee receivers with their shares\n     */\n    event MarketplaceInitialized(FeeReceiver[] feeReceivers);\n\n    /**\n     * @dev Emitted when a payment is distributed to a receiver\n     * @param token Address of the token used for payment (address(0) for ETH)\n     * @param receiver Address receiving the payment\n     * @param amount Amount of tokens or ETH distributed\n     */\n    event PaymentDistributed(address token, address receiver, uint256 amount);\n\n    /**\n     * @notice Initialize the marketplace with fee receivers\n     * @dev Sets up the fee distribution system for the marketplace. Once initialized,\n     *      it cannot be modified. This one-time setup defines what percentage of each\n     *      sale will go to different recipients (e.g., platform fees, community treasury).\n     *      The sum of all fee shares must not exceed 100% (1,000,000 parts per million).\n     *\n     * @param _feeReceivers Array of fee receivers with their respective shares\n     * @custom:security Only callable by the contract owner\n     * @custom:restriction Can only be called once\n     */\n    function initializeMarketplace(\n        FeeReceiver[] memory _feeReceivers\n    ) external onlyOwner {\n        require(feeReceivers.length == 0, \"Marketplace already initialized\");\n        uint256 totalShares = 0;\n        for (uint256 i = 0; i < _feeReceivers.length; i++) {\n            require(\n                _feeReceivers[i].receiver != address(0),\n                \"Invalid fee receiver address\"\n            );\n            require(\n                _feeReceivers[i].sharePerMillion > 0,\n                \"Invalid share per million\"\n            );\n            totalShares += _feeReceivers[i].sharePerMillion;\n            feeReceivers.push(_feeReceivers[i]);\n        }\n        require(totalShares <= SHARE_PRECISION, \"Total shares exceed 100%\");\n        emit MarketplaceInitialized(_feeReceivers);\n    }\n\n    /**\n     * @notice List an NFT for sale in the marketplace\n     * @dev Creates a new market item listing for the specified NFT. The NFT can either\n     *      remain in the seller's wallet or be transferred to the contract based on\n     *      the transferNFT parameter. This function implements the nonReentrant modifier\n     *      to prevent potential reentrancy attacks during execution.\n     *      The first parameter is unused but kept for interface compatibility.\n     *\n     * @param receiver The address that will receive payment when item is sold\n     * @param tokenId The ID of the NFT being listed\n     * @param price The listing price (in ETH or ERC20 tokens)\n     * @param transferNFT If true, transfers the NFT to the contract; if false, keeps it with seller\n     * @param paymentToken Address of ERC20 token for payment, or address(0) for ETH\n     * @custom:security Uses nonReentrant modifier to prevent reentrancy attacks\n     * @custom:event Emits Listings event with listing details\n     */\n    function listItem(\n        address,\n        address payable receiver,\n        uint256 tokenId,\n        uint256 price,\n        bool transferNFT,\n        address paymentToken\n    ) external payable override nonReentrant {\n        require(price > 0, \"Price must be greater than 0\");\n\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n\n        require(\n            IERC721(address(this)).ownerOf(tokenId) == msg.sender,\n            \"MARKETPLACE: NOT_OWNER - Only the NFT owner can list the item\"\n        );\n        require(s.idToListed[tokenId] == false, \"Item is already listed\");\n\n        if (transferNFT) {\n            s._transfer(msg.sender, msg.sender, address(this), tokenId, true);\n        }\n\n        s.idToMarketItem[tokenId] = MarketItem(\n            address(this),\n            tokenId,\n            msg.sender,\n            msg.sender,\n            price,\n            false,\n            receiver,\n            paymentToken\n        );\n        s.idToListed[tokenId] = true;\n        s.items.push(s.idToMarketItem[tokenId]);\n        emit Listings(\n            address(this),\n            tokenId,\n            msg.sender,\n            receiver,\n            address(0),\n            price,\n            false,\n            paymentToken\n        );\n    }\n\n    /**\n     * @notice Purchase a listed NFT from the marketplace\n     * @dev Allows a registered user to purchase a listed NFT, handling both ETH and ERC20 payments.\n     *      The function follows the checks-effects-interactions pattern for security, updating\n     *      state variables before transferring tokens or NFTs. A portion of the payment is\n     *      distributed to configured fee receivers, with the remainder going to the listing's\n     *      payment receiver. The function implements nonReentrant modifier to prevent reentrancy attacks.\n     *\n     *      The purchase process:\n     *      1. Verifies the listing exists and hasn't been sold\n     *      2. Checks buyer is registered in the identity system\n     *      3. Validates sufficient payment was provided\n     *      4. Updates state to mark item as sold\n     *      5. Transfers NFT to buyer\n     *      6. Distributes payment to fee receivers and seller\n     *\n     *      The first parameter (address) is unused but kept for interface compatibility.\n     *\n     * @param tokenId The ID of the NFT to purchase\n     * @custom:security Uses nonReentrant modifier and checks-effects-interactions pattern\n     * @custom:payment Accepts ETH (if paymentToken is address(0)) or ERC20 tokens\n     * @custom:event Emits Sales event upon successful purchase\n     */\n    function purchaseItem(\n        address,\n        uint256 tokenId,\n        uint256 maxPrice // Added maxPrice parameter\n    ) external payable nonReentrant {\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n\n        require(\n            s.idToMarketItem[tokenId].sold != true,\n            \"MARKETPLACE: SALE_COMPLETED - This item has already been sold\"\n        );\n        require(\n            s.idToListed[tokenId] == true,\n            \"MARKETPLACE: INVALID_LISTING - This listing does not exist or is no longer active\"\n        );\n\n        // buyer must be in the registry\n        require(\n            s.isRegistered(msg.sender),\n            \"MARKETPLACE: UNREGISTERED_BUYER - Buyer must be registered in the identity system\"\n        );\n\n        MarketItem storage item = s.idToMarketItem[tokenId];\n        uint256 price = item.price;\n        address paymentToken = item.paymentToken;\n        address receiver = item.receiver;\n\n        // Validate payment amount\n        // Validate payment amount and max price\n        if (paymentToken == address(0)) {\n            require(\n                msg.value >= price,\n                \"MARKETPLACE: INSUFFICIENT_ETH - Not enough ETH sent for purchase\"\n            );\n            require(\n                price <= maxPrice,\n                \"MARKETPLACE: PRICE_TOO_HIGH - Listing price exceeds maximum acceptable price\"\n            ); // Added maxPrice check\n        } else {\n            IERC20 token = IERC20(paymentToken);\n            require(\n                token.balanceOf(msg.sender) >= price,\n                \"MARKETPLACE: INSUFFICIENT_TOKENS - Not enough token balance for purchase\"\n            );\n            require(\n                price <= maxPrice,\n                \"MARKETPLACE: PRICE_TOO_HIGH - Listing price exceeds maximum acceptable price\"\n            ); // Added maxPrice check\n        }\n\n        // Update state variables first (follow checks-effects-interactions pattern)\n        item.owner = payable(msg.sender);\n        item.sold = true;\n        s.idToListed[tokenId] = false;\n        s.itemsSold = s.itemsSold + 1;\n\n        for (uint256 i = 0; i < s.items.length; i++) {\n            if (\n                s.items[i].nftContract == address(this) &&\n                s.items[i].tokenId == tokenId\n            ) {\n                s.items[i] = s.items[s.items.length - 1];\n                s.items.pop();\n                break;\n            }\n        }\n\n        // Transfer NFT to buyer\n        s._transfer(address(this), address(this), msg.sender, tokenId, false);\n\n        // Process payment after all state changes\n        if (paymentToken == address(0)) {\n            distributePaymentETH(payable(receiver), price);\n            if (msg.value > price) {\n                (bool success, ) = payable(msg.sender).call{\n                    value: msg.value - price\n                }(\"\");\n                require(success, \"ETH transfer failed\");\n            }\n        } else {\n            IERC20 token = IERC20(paymentToken);\n            distributePaymentERC20(token, receiver, price);\n        }\n\n        emit Sales(address(this), tokenId, msg.sender);\n    }\n\n    function purchaseItem(address, uint256 itemId) external payable {\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n        MarketItem storage item = s.idToMarketItem[itemId];\n        uint256 price = item.price;\n\n        this.purchaseItem(\n            address(this),\n            itemId,\n            price\n        );\n    }\n\n    /**\n     * @notice Distribute ETH payment between fee receivers and the original receiver\n     * @dev Internal function that handles ETH payment distribution according to configured fee shares.\n     *      This function is called during NFT purchases when the payment token is ETH.\n     *      It calculates each fee receiver's share based on their sharePerMillion value,\n     *      transfers those amounts, and sends any remaining amount to the original recipient\n     *      (typically the NFT seller). For each transfer, a PaymentDistributed event is emitted.\n     *\n     * @param originalReceiver The address that should receive payment after fees (typically the NFT seller)\n     * @param amount The total amount of ETH to distribute\n     * @custom:security Direct ETH transfers are used, so recipients must be able to receive ETH\n     * @custom:event Emits PaymentDistributed events for each recipient with their portion\n     */\n    function distributePaymentETH(\n        address payable originalReceiver,\n        uint256 amount\n    ) private {\n        uint256 remainingAmount = amount;\n        for (uint256 i = 0; i < feeReceivers.length; i++) {\n            uint256 feeAmount = (amount * feeReceivers[i].sharePerMillion) /\n                SHARE_PRECISION;\n            if (feeAmount > 0) {\n                (bool success, ) = feeReceivers[i].receiver.call{\n                    value: feeAmount\n                }(\"\");\n                require(success, \"ETH transfer failed\");\n                remainingAmount -= feeAmount;\n                emit PaymentDistributed(\n                    address(0),\n                    feeReceivers[i].receiver,\n                    feeAmount\n                );\n            }\n        }\n        if (remainingAmount > 0) {\n            (bool success, ) = originalReceiver.call{value: remainingAmount}(\n                \"\"\n            );\n            require(success, \"ETH transfer failed\");\n            emit PaymentDistributed(\n                address(0),\n                originalReceiver,\n                remainingAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Distribute ERC20 token payment between fee receivers and the original receiver\n     * @dev Internal function that handles ERC20 token payment distribution according to configured fee shares.\n     *      This function is called during NFT purchases when using ERC20 tokens as payment.\n     *      It calculates each fee receiver's share based on their sharePerMillion value,\n     *      transfers those tokens via safeTransferFrom, and sends any remaining tokens to the\n     *      original recipient (typically the NFT seller). Unlike ETH distribution, this function\n     *      requires the buyer to have approved the marketplace contract to spend their tokens.\n     *\n     * @param token The ERC20 token contract used for payment\n     * @param originalReceiver The address that should receive payment after fees (typically the NFT seller)\n     * @param amount The total amount of tokens to distribute\n     * @custom:security Uses SafeERC20 for transfers to prevent silent failures\n     * @custom:event Emits PaymentDistributed events for each recipient with their portion\n     */\n    function distributePaymentERC20(\n        IERC20 token,\n        address originalReceiver,\n        uint256 amount\n    ) private {\n        uint256 remainingAmount = amount;\n        for (uint256 i = 0; i < feeReceivers.length; i++) {\n            uint256 feeAmount = (amount * feeReceivers[i].sharePerMillion) /\n                SHARE_PRECISION;\n            if (feeAmount > 0) {\n                token.safeTransferFrom(\n                    msg.sender,\n                    feeReceivers[i].receiver,\n                    feeAmount\n                );\n                remainingAmount -= feeAmount;\n                emit PaymentDistributed(\n                    address(token),\n                    feeReceivers[i].receiver,\n                    feeAmount\n                );\n            }\n        }\n        if (remainingAmount > 0) {\n            token.safeTransferFrom(\n                msg.sender,\n                originalReceiver,\n                remainingAmount\n            );\n            emit PaymentDistributed(\n                address(token),\n                originalReceiver,\n                remainingAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Remove an NFT from the marketplace listings\n     * @dev Allows the seller of a listed NFT to delist it, canceling the sale.\n     *      This function returns ownership and control of the NFT to the seller\n     *      if it was previously transferred to the contract. Only the original\n     *      seller or the contract itself can delist an item, and it must not have\n     *      been sold already. The function implements nonReentrant modifier to\n     *      prevent potential reentrancy attacks during execution.\n     *\n     *      The delisting process:\n     *      1. Verifies the item exists and hasn't been sold\n     *      2. Checks caller is the seller or the contract itself\n     *      3. Resets listing variables and removes from active listings\n     *      4. Transfers NFT back to seller if it was held by the contract\n     *\n     * The first parameter (address) is unused but kept for interface compatibility.\n     *\n     * @param tokenId The ID of the NFT to delist\n     * @custom:security Uses nonReentrant modifier to prevent reentrancy attacks\n     * @custom:event Emits Delisted event upon successful delisting\n     */\n    function delistItem(\n        address,\n        uint256 tokenId\n    ) external override nonReentrant {\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n\n        require(s.idToMarketItem[tokenId].sold == false, \"Item already sold\");\n        require(\n            IERC721(s.idToMarketItem[tokenId].nftContract).ownerOf(tokenId) ==\n                msg.sender,\n            \"MARKETPLACE: NOT_OWNER - Only the NFT owner can delist the item\"\n        );\n        require(s.idToMarketItem[tokenId].sold == false, \"Item already sold\");\n\n        s.idToMarketItem[tokenId].owner = payable(0);\n        s.idToMarketItem[tokenId].price = 0;\n        s.idToMarketItem[tokenId].sold = false;\n        s.idToListed[tokenId] = false;\n\n        for (uint256 i = 0; i < s.items.length; i++) {\n            if (\n                s.items[i].nftContract == address(this) &&\n                s.items[i].tokenId == tokenId\n            ) {\n                s.items[i] = s.items[s.items.length - 1];\n                s.items.pop();\n                break;\n            }\n        }\n\n        s._transfer(address(this), address(this), msg.sender, tokenId, true);\n\n        emit Delisted(tokenId);\n    }\n\n    function fetchItem(\n        address,\n        uint256 tokenId\n    ) external view override returns (MarketItem memory) {\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n        require(\n            s.idToMarketItem[tokenId].owner != address(0),\n            \"This item is not for sale\"\n        );\n        return s.idToMarketItem[tokenId];\n    }\n\n    function fetchItems() external view override returns (MarketItem[] memory) {\n        IdentitySystemStorage.IdentitySystem storage s = IdentitySystemStorage\n            .diamondStorage();\n        return s.items;\n    }\n\n    /**\n     * @notice Get the fee receivers configured specifically for this marketplace\n     * @return Array of marketplace fee receivers with their shares\n     */\n    function getMarketplaceFeeReceivers()\n        external\n        view\n        returns (FeeReceiver[] memory)\n    {\n        return feeReceivers;\n    }\n}\n"
    },
    "contracts/facets/MultiSaleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IMultiSale.sol\";\nimport \"../interfaces/IERC20Mint.sol\";\nimport \"../interfaces/IERC721Mint.sol\";\nimport \"../interfaces/IERC1155Mint.sol\";\n\nimport \"../utilities/InterfaceChecker.sol\";\nimport \"../utilities/Controllable.sol\";\nimport \"../utilities/Modifiers.sol\";\n\nimport \"../libraries/UInt256Set.sol\";\nimport \"../libraries/MultiSaleLib.sol\";\nimport \"../libraries/VariablePriceLib.sol\";\nimport \"../identity/IdentityStorage.sol\";\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title MultiSaleFacet\n * @dev A facet for managing token sales with support for multiple token types (ERC20, ERC721, ERC1155).\n *      This contract allows creating, managing, and executing token sales with various payment methods,\n *      including ETH and ERC20 tokens. It supports both direct purchases and purchases that require\n *      off-chain proofs (e.g., allowlists, presales).\n *\n *      The facet integrates with the diamond storage pattern via MultiSaleLib and uses VariablePriceLib\n *      for price calculations. It includes reentrancy protection for all payment-handling functions\n *      and maintains state for token sales, including purchased quantities per account.\n */\ncontract MultiSaleFacet is IMultiSale, Modifiers, ReentrancyGuard {\n\n    using UInt256Set for UInt256Set.Set;\n    using MultiSaleLib for MultiSaleContract;\n    using VariablePriceLib for VariablePriceContract;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    /**\n     * @notice Initialize the MultiSaleFacet\n     * @dev This function is called once when the facet is added to the diamond.\n     *      Currently this is a placeholder for initialization logic that might\n     *      be needed in the future. The function is intentionally empty but\n     *      can be extended if initialization requirements arise.\n     */\n    function initializeMultiSaleFacet() external {\n        // Initialization logic would go here if needed\n    }\n\n    /**\n     * @notice Create a new token sale with specified settings\n     * @dev Creates a new token sale entry in the diamond storage with the provided configuration.\n     *      Each token sale is assigned a unique ID that can be used for subsequent operations.\n     *      The function stores the complete sale configuration including token type, price,\n     *      payment methods, and constraints. The token sale is tracked in the system and an\n     *      event is emitted to notify listeners of the new sale.\n     *\n     *      Only the contract owner can create new token sales, which is enforced by the onlyOwner modifier.\n     *      The function is marked as virtual to allow extending contracts to override its behavior.\n     *\n     * @param tokenSaleInit A struct containing all token sale configuration including:\n     *        - token: Address of the token being sold\n     *        - tokenType: Type of token (ERC20, ERC721, ERC1155)\n     *        - owner: Address of the sale owner (receives funds)\n     *        - price: Price configuration for the token\n     *        - paymentMethod: Method of payment (ETH or ERC20)\n     *        - paymentToken: Token address used for payment (if ERC20)\n     *        - maxQuantityPerAccount: Maximum tokens an account can purchase (0 for unlimited)\n     *        - Additional sale constraints and metadata\n     *\n     * @return tokenSaleId The unique identifier for the newly created token sale\n     * @custom:access Restricted to contract owner\n     * @custom:event Emits MultiSaleCreated with the sale ID and complete settings\n     */\n    function createTokenSale(MultiSaleSettings memory tokenSaleInit)\n        external\n        virtual\n        onlyOwner\n        returns (uint256 tokenSaleId) {\n\n        tokenSaleId = MultiSaleLib._createTokenSale();\n\n        IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings = tokenSaleInit;\n        IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings.owner = tokenSaleInit.owner;\n        IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings.paymentMethod = tokenSaleInit.paymentMethod;\n        IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings.paymentToken = tokenSaleInit.paymentToken;\n        IdentitySystemStorage.multiSaleStorage()._tokenSaleIds.push(tokenSaleId);\n        \n        // emit event\n        emit MultiSaleCreated(tokenSaleId, IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings);\n    }\n\n    /**\n     * @notice Update the settings for an existing token sale\n     * @dev Allows the token sale owner or the contract owner to modify the settings\n     *      of an existing sale. This provides flexibility to adjust parameters like\n     *      price, maximum quantities, or other settings after a sale has been created.\n     *\n     *      Access control ensures only authorized addresses can update sale settings.\n     *      The function completely replaces the existing settings with the new ones\n     *      and emits an event to notify listeners of the change.\n     *\n     * @param tokenSaleId The ID of the token sale to update\n     * @param settings The new settings to apply to the token sale\n     * @custom:access Restricted to the token sale owner or contract owner\n     * @custom:event Emits MultiSaleUpdated with the sale ID and the new settings\n     */\n    function updateTokenSaleSettings(\n        uint256 tokenSaleId,\n        MultiSaleSettings memory settings\n    ) external {\n        // check that this is the token sale owner or the contract owner\n        require(msg.sender == IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings.owner\n            || msg.sender == LibDiamond.contractOwner(), \"notowner\");\n        IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleId].settings = settings;\n\n        // emit event\n        emit MultiSaleUpdated(tokenSaleId, settings);\n    }\n\n    /**\n     * @notice Purchase tokens from a token sale using a cryptographic proof\n     * @dev Allows users to purchase tokens from a specific sale using a cryptographic\n     *      proof (e.g., a Merkle proof for allowlists). This function implements the\n     *      nonReentrant modifier to prevent reentrancy attacks during payment processing.\n     *\n     *      The purchase process:\n     *      1. Retrieves the token sale from storage\n     *      2. Sets default purchaser/receiver to msg.sender if not provided\n     *      3. Validates the purchase and proof via MultiSaleLib\n     *      4. Mints the purchased tokens to the receiver\n     *      5. Updates the sale state (total purchased, per-account record)\n     *      6. Emits an event with purchase details\n     *\n     * @param purchaseInfo A struct containing purchase information:\n     *        - multiSaleId: ID of the token sale\n     *        - purchaser: Address making the purchase (defaults to msg.sender if zero)\n     *        - receiver: Address receiving the tokens (defaults to msg.sender if zero)\n     *        - quantity: Number of tokens to purchase\n     * @param purchaseProofParam The cryptographic proof required for the purchase:\n     *        - proof: The proof data (e.g., Merkle proof bytes)\n     *        - data: Additional data related to the proof or purchase\n     * @return ids Array of token IDs that were minted to the receiver\n     * @custom:security Uses nonReentrant modifier to prevent reentrancy attacks\n     * @custom:event Emits MultiSaleSold event upon successful purchase\n     */\n    function purchaseProof(\n        MultiSalePurchase memory purchaseInfo,\n        MultiSaleProof memory purchaseProofParam\n    ) external payable nonReentrant returns (uint256[] memory ids) {\n\n        //  get the token sale\n        MultiSaleContract storage multiSaleContract  = IdentitySystemStorage\n            .multiSaleStorage()\n            ._tokenSales[purchaseInfo.multiSaleId];\n\n        uint256 mqpa = multiSaleContract.settings.maxQuantityPerAccount;\n\n        // check max qty per account to make sure we are below it\n        require(mqpa == 0 ||(mqpa != 0 &&\n            purchaseInfo.quantity + multiSaleContract._accountQuantities[purchaseInfo.receiver] <= mqpa), // Check against receiver\n            \"maxperaccount\");\n\n        // if the purchaser isn't set then set it to the msg.sender\n        if(purchaseInfo.purchaser == address(0)) {\n            purchaseInfo.purchaser = msg.sender;\n        }\n        if(purchaseInfo.receiver == address(0)) {\n            purchaseInfo.receiver = msg.sender;\n        }\n        // Validate payment amount and handle excess ETH\n        uint256 totalPrice = multiSaleContract.settings.price.price * purchaseInfo.quantity;\n        if (multiSaleContract.settings.paymentMethod == PaymentMethod.ERC20) {\n            require(msg.value == 0, \"Do not send ETH for ERC20 payments\");\n        } else {\n            require(msg.value >= totalPrice, \"Insufficient ETH sent\");\n            if (msg.value > totalPrice) {\n                (bool success, ) = payable(msg.sender).call{value: msg.value - totalPrice}(\"\");\n                require(success, \"ETH transfer failed\");\n            }\n        }\n\n        // purchase token with proof\n        multiSaleContract._purchaseToken(\n            multiSaleContract.settings.price,\n            purchaseInfo,\n            purchaseProofParam,\n            (multiSaleContract.settings.paymentMethod == PaymentMethod.ERC20) ? totalPrice : msg.value // Pass correct value based on payment method\n        );\n\n        //  mint the newly-purchased tokens\n        ids = _mintPurchasedTokens(\n            purchaseInfo.multiSaleId,\n            purchaseInfo.receiver,\n            purchaseInfo.quantity,\n            purchaseProofParam.data\n        );\n        // 4. update the token sale settings\n        multiSaleContract.totalPurchased += purchaseInfo.quantity;\n        multiSaleContract.purchased[purchaseInfo.receiver] += purchaseInfo.quantity;\n        multiSaleContract._accountQuantities[purchaseInfo.receiver] += purchaseInfo.quantity; // Increment by quantity and use receiver\n\n        // emit an event\n        emit MultiSaleSold(\n            purchaseInfo.multiSaleId,\n            purchaseInfo.purchaser,\n            ids,\n            purchaseProofParam.data\n        );\n    }\n\n    /**\n     * @notice Purchase tokens from a token sale without requiring a cryptographic proof\n     * @dev Allows users to purchase tokens from a specific sale with direct payment.\n     *      This is a simpler alternative to purchaseProof for sales that don't require\n     *      allowlist verification. The function implements the nonReentrant modifier\n     *      to prevent reentrancy attacks during payment processing.\n     *\n     *      The purchase process:\n     *      1. Retrieves the token sale from storage and calculates total price\n     *      2. Validates and processes payment (ETH or ERC20 tokens)\n     *      3. Sets default purchaser/receiver to msg.sender if not provided\n     *      4. Checks purchase limits (maxQuantityPerAccount)\n     *      5. Calls MultiSaleLib to process the purchase\n     *      6. Mints the purchased tokens to the receiver\n     *      7. Updates the sale state and tracked quantities\n     *      8. Emits an event with purchase details\n     *\n     * @param multiSaleId ID of the token sale to purchase from\n     * @param purchaser Address making the purchase (defaults to msg.sender if zero)\n     * @param receiver Address receiving the tokens (defaults to msg.sender if zero)\n     * @param quantity Number of tokens to purchase\n     * @param data Additional data to pass to the token minting process\n     * @return ids Array of token IDs that were minted to the receiver\n     * @custom:security Uses nonReentrant modifier to prevent reentrancy attacks\n     * @custom:event Emits MultiSaleSold event upon successful purchase\n     */\n    function purchase(\n        uint256 multiSaleId,\n        address purchaser,\n        address receiver,\n        uint256 quantity,\n        bytes memory data) external payable nonReentrant returns (uint256[] memory ids) {\n\n        // get the multisale contract\n        MultiSaleContract storage multiSaleContract = IdentitySystemStorage\n            .multiSaleStorage()\n            ._tokenSales[multiSaleId];\n        uint256 totalPrice = multiSaleContract.settings.price.price * quantity;\n\n        // check the payment method\n        if (multiSaleContract.settings.paymentMethod == PaymentMethod.ERC20) {\n            require(msg.value == 0, \"Do not send ETH for ERC20 payments\");\n            IERC20 paymentToken = IERC20(multiSaleContract.settings.paymentToken);\n            // Removed duplicate ERC20 transfer\n        } else {\n            require(msg.value >= totalPrice, \"Insufficient ETH sent\");\n            if (msg.value > totalPrice) {\n                (bool success, ) = payable(msg.sender).call{value: msg.value - totalPrice}(\"\");\n                require(success, \"ETH transfer failed\");\n            }\n        }\n\n        // if the purchaser isn't set then set it to the msg.sender\n        if(purchaser == address(0)) {\n            purchaser = msg.sender;\n        }\n        if(receiver == address(0)) {\n            receiver = msg.sender;\n        }\n\n        uint256 mqpa = multiSaleContract.settings.maxQuantityPerAccount;\n\n        // check max qty per account to make sure we are below it\n        // check max qty per account to make sure we are below it\n        require(mqpa == 0 ||(mqpa != 0 &&\n            quantity + multiSaleContract._accountQuantities[purchaser] <= mqpa), // Check against purchaser\n            \"maxperaccount\");\n\n        MultiSalePurchase memory purchaseInfo = MultiSalePurchase(\n            multiSaleId,\n            purchaser,\n            receiver,\n            quantity\n        );\n\n        // get the token sale    \n        // get the token sale\n        // Pass totalPrice for ERC20 payments, msg.value for ETH\n        if (multiSaleContract.settings.paymentMethod == PaymentMethod.ERC20) {\n            multiSaleContract._purchaseToken(\n                multiSaleContract.settings.price,\n                purchaseInfo,\n                totalPrice); // Pass totalPrice for ERC20\n        } else {\n             multiSaleContract._purchaseToken(\n                multiSaleContract.settings.price,\n                purchaseInfo,\n                msg.value); // Pass msg.value for ETH\n        }\n\n        //  mint the tokens\n        ids = _mintPurchasedTokens(\n            multiSaleId,\n            receiver,\n            quantity,\n            data\n        );\n        // 4. update the token sale settings\n        multiSaleContract.totalPurchased += quantity;\n        multiSaleContract.purchased[receiver] += quantity;\n        multiSaleContract._accountQuantities[purchaser] += quantity; // Increment by quantity and use purchaser\n\n        // emit an event\n        emit MultiSaleSold(\n            multiSaleId,\n            receiver,\n            ids,\n            data\n        );\n    }\n\n\n    /**\n     * @notice Mint tokens that have been purchased in a token sale\n     * @dev Internal function that handles the actual minting process based on token type.\n     *      This function is called by both purchase and purchaseProof functions.\n     *      It supports different token types including ERC20, ERC721, and ERC1155,\n     *      and uses appropriate minting mechanisms for each type.\n     *\n     *      The function uses type detection through InterfaceChecker to determine\n     *      the appropriate minting approach:\n     *      - For ERC20: Uses mintTo to mint fungible tokens\n     *      - For ERC721: Mints individual NFTs with unique IDs\n     *      - For ERC1155: Mints semi-fungible tokens with the same ID\n     *\n     * @param multiSaleId The ID of the token sale the tokens were purchased from\n     * @param recipient The address that will receive the minted tokens\n     * @param amount The quantity of tokens to mint\n     * @param data Additional data to pass to the minting function (e.g., for ERC721 metadata)\n     * @return tokenHash_ Array of token IDs that were minted. For ERC721, this will contain\n     *         the IDs of each minted token; for ERC1155, it will contain a single token ID;\n     *         for ERC20, it will be empty.\n     */\n    function _mintPurchasedTokens(\n        uint256 multiSaleId,\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) internal returns (uint256[] memory tokenHash_) {\n        \n        // get the token sale\n        MultiSaleContract storage multiSaleContract = IdentitySystemStorage\n            .multiSaleStorage()\n            ._tokenSales[multiSaleId];\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n\n\n        if (multiSaleContract.settings.tokenType == TokenType.ERC20) {\n            IERC20Mint(multiSaleContract.settings.token).mintTo(recipient, amount);\n        } else if (InterfaceChecker.isERC721(multiSaleContract.settings.token)) {\n            tokenHash_ = new uint256[](amount);\n            for (uint256 i = 0; i < amount; i++) {\n                uint256 nextId = identitySystem.erc721Contract._currentIndex;\n                IERC721Mint(address(this)).mintTo(recipient, 1, data); // Mint 1 ERC721 token at a time\n                tokenHash_[i] = nextId;\n            }\n        } else if (multiSaleContract.settings.tokenType == TokenType.ERC1155) { // Corrected order and check\n            tokenHash_ = new uint256[](1);\n            tokenHash_[0] = multiSaleContract.nonce++;\n            IERC1155Mint(address(this)).mintTo(\n                recipient,\n                tokenHash_[0],\n                amount,\n                \"\"\n            );\n        } else {\n            require(false, \"Token not supported\");\n        }\n    }\n\n    /**\n     * @notice Retrieve the complete settings for a specific token sale\n     * @dev Returns the full MultiSaleSettings struct for a given token sale ID.\n     *      This function provides a way to inspect all configuration parameters\n     *      of an existing token sale, including token information, price settings,\n     *      and purchase constraints. The function is marked as virtual to allow\n     *      extending contracts to override its behavior if needed.\n     *\n     * @param tokenSaleId The unique identifier of the token sale to query\n     * @return settings A complete MultiSaleSettings struct containing all configuration\n     *         parameters for the specified token sale\n     */\n    function getTokenSaleSettings(uint256 tokenSaleId)\n        external\n        view\n        virtual\n        returns (MultiSaleSettings memory settings) {\n\n        settings = IdentitySystemStorage\n            .multiSaleStorage()\n            ._tokenSales[tokenSaleId].settings;\n    }\n\n    /**\n     * @notice Retrieve all token sale IDs in the system\n     * @dev Returns an array containing all token sale IDs currently registered\n     *      in the diamond storage. This can be used to enumerate all active token\n     *      sales, which is useful for UIs and integrations that need to display\n     *      or work with all available sales.\n     *\n     * @return Array of uint256 token sale IDs\n     */\n    function getTokenSaleIds() external view returns (uint256[] memory) {\n        return IdentitySystemStorage.multiSaleStorage()._tokenSaleIds;\n    }\n\n    /**\n     * @notice Get complete settings for all token sales in the system\n     * @dev Returns an array of MultiSaleSettings structs containing all configuration\n     *      information for every registered token sale. This is a more comprehensive\n     *      version of getTokenSaleIds() that includes the full settings of each token sale,\n     *      not just their IDs. This is particularly useful for UIs that need to display\n     *      all sale details without making multiple contract calls.\n     *\n     * @return Array of MultiSaleSettings structs containing complete configuration information\n     *         for all token sales\n     */\n    function listTokenSales() external view returns (MultiSaleSettings[] memory) {\n        uint256[] memory tokenSaleIds = IdentitySystemStorage.multiSaleStorage()._tokenSaleIds;\n        MultiSaleSettings[] memory tokenSales = new MultiSaleSettings[](tokenSaleIds.length);\n        for (uint256 i = 0; i < tokenSaleIds.length; i++) {\n            tokenSales[i] = IdentitySystemStorage.multiSaleStorage()._tokenSales[tokenSaleIds[i]].settings;\n        }\n        return tokenSales;\n    }\n\n}\n\n"
    },
    "contracts/facets/TradeDealFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title TradeDealFacet\n * @dev A Diamond facet that provides functionality for creating and managing trade deals.\n * Trade deals allow users to participate in funding opportunities where invoices are used as collateral.\n * The facet handles the creation, funding, repayment, and redemption processes for trade deals,\n * as well as managing the associated Collateral and VABI tokens.\n */\n\nimport \"../utilities/Modifiers.sol\";\nimport \"../libraries/TradeDealLib.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/ITradeDeal.sol\";\n\ncontract TradeDealFacet is Modifiers, ITradeDeal {\n  \n    /**\n     * @notice Create a new trade deal with specified parameters and operation mode\n     * @param name Name of the trade deal\n     * @param symbol Symbol for the trade deal tokens\n     * @param interestRate Interest rate in basis points (100 = 1%)\n     * @param collateralToInterestRatio Ratio for converting Collateral to VABI tokens\n     * @param requiredClaimTopics Array of claim topics required for participation\n     * @param collateralAddress Address of existing Collateral token (or zero to create new)\n     * @param interestAddress Address of VABI token\n     * @param usdcAddress Address of USDC token\n     * @param operationMode The operation mode (CENTRALIZED or SELF_SERVICE)\n     * @return The ID of the created trade deal\n     */\n    function createTradeDeal(\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        uint256[] memory requiredClaimTopics,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress,\n        TradeDealLib.OperationMode operationMode\n    ) public override onlyOwner returns (uint256) {\n        // Validate input parameters\n        require(bytes(name).length > 0, \"TRADE_DEAL: INVALID_NAME - Name cannot be empty\");\n        require(bytes(symbol).length > 0, \"TRADE_DEAL: INVALID_SYMBOL - Symbol cannot be empty\");\n        require(interestRate >= 0 && interestRate <= 10000, \"TRADE_DEAL: INVALID_INTEREST_RATE - Must be between 1 and 10000 basis points (0.01% to 100%)\");\n        require(collateralToInterestRatio > 0, \"TRADE_DEAL: INVALID_RATIO - Collateral to VABI ratio must be greater than zero\");\n        \n        // If interestAddress is provided, it must be a valid address\n        if(interestAddress != address(0)) {\n            require(interestAddress != collateralAddress, \"TRADE_DEAL: INVALID_ADDRESSES - VABI and Collateral addresses cannot be the same\");\n        }\n        \n        // If usdcAddress is provided, it must be a valid address\n        if(usdcAddress != address(0)) {\n            require(usdcAddress != collateralAddress && usdcAddress != interestAddress,\n                \"TRADE_DEAL: INVALID_ADDRESSES - USDC address cannot be the same as Collateral or VABI\");\n        }\n        \n        // Create parameters struct\n        TradeDealLib.CreateTradeDealParams memory params = TradeDealLib.CreateTradeDealParams({\n            name: name,\n            symbol: symbol,\n            interestRate: interestRate,\n            collateralToInterestRatio: collateralToInterestRatio,\n            requiredClaimTopics: requiredClaimTopics,\n            collateralAddress: collateralAddress,\n            interestAddress: interestAddress,\n            usdcAddress: usdcAddress,\n            operationMode: operationMode\n        });\n        \n        TradeDealLib.CreateTradeDealResult memory result = TradeDealLib._createTradeDeal(params);\n        \n        // Emit events with the returned data\n        emit TradeDealCreated(\n            result.tradeDealId,\n            result.name,\n            result.symbol,\n            result.interestRate,\n            result.collateralToInterestRatio,\n            result.active,\n            result.nftAddress,\n            result.collateralAddress,\n            result.interestAddress,\n            result.usdcAddress,\n            result.operationMode\n        );\n        \n        // If claim topics were set, emit that event too\n        if (result.hasClaimTopics) {\n            emit TradeDealRequiredClaimTopicsSet(result.tradeDealId, result.requiredClaimTopics);\n        }\n        \n        return result.tradeDealId;\n    }\n    \n    /**\n     * @notice Update an existing trade deal's properties\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to update\n     * @param name New name for the trade deal\n     * @param symbol New symbol for the trade deal tokens\n     * @param interestRate New interest rate in basis points (100 = 1%)\n     * @param collateralToInterestRatio New ratio for converting Collateral to VABI tokens\n     * @param collateralAddress New Collateral token address\n     * @param interestAddress New VABI token address\n     * @param usdcAddress New USDC token address\n     */\n    function updateTradeDeal(\n        uint256 tradeDealId,\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) external onlyOwner {\n        TradeDealLib.UpdateTradeDealResult memory result = TradeDealLib._updateTradeDeal(\n            tradeDealId,\n            name,\n            symbol,\n            interestRate,\n            collateralToInterestRatio,\n            collateralAddress,\n            interestAddress,\n            usdcAddress\n        );\n        \n        // Emit event with the returned data\n        emit TradeDealUpdated(\n            result.tradeDealId,\n            result.name,\n            result.symbol,\n            result.interestRate,\n            result.collateralToInterestRatio,\n            result.active,\n            result.collateralAddress,\n            result.interestAddress,\n            result.usdcAddress\n        );\n    }\n    \n    /**\n     * @notice Activate a trade deal that was previously deactivated\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to activate\n     */\n    function activateTradeDeal(uint256 tradeDealId) external onlyOwner {\n        TradeDealLib.TradeDealStateChangeResult memory result = TradeDealLib._activateTradeDeal(tradeDealId);\n        \n        // Emit event with the returned data\n        emit TradeDealActivated(result.tradeDealId);\n    }\n    \n    /**\n     * @notice Deactivate an active trade deal to prevent further deposits\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to deactivate\n     */\n    function deactivateTradeDeal(uint256 tradeDealId) external onlyOwner {\n        TradeDealLib.TradeDealStateChangeResult memory result = TradeDealLib._deactivateTradeDeal(tradeDealId);\n        \n        // Emit event with the returned data\n        emit TradeDealDeactivated(result.tradeDealId);\n    }\n    \n    /**\n     * @notice Get basic information about a trade deal\n     * @param tradeDealId ID of the trade deal to query\n     * @return name The name of the trade deal\n     * @return symbol The symbol of the trade deal tokens\n     * @return interestRate The interest rate in basis points\n     * @return collateralToInterestRatio The conversion ratio for Collateral to VABI tokens\n     * @return active Whether the trade deal is currently active\n     * @return operationMode The operation mode (CENTRALIZED or SELF_SERVICE)\n     */\n    function getTradeDealInfo(uint256 tradeDealId) external view returns (\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        bool active,\n        TradeDealLib.OperationMode operationMode\n    ) {\n        TradeDealLib.TradeDeal memory tradeDeal = TradeDealLib._getTradeDealInfo(tradeDealId);\n        return (\n            tradeDeal.name,\n            tradeDeal.symbol,\n            tradeDeal.interestRate,\n            tradeDeal.collateralToInterestRatio,\n            tradeDeal.active,\n            tradeDeal.operationMode\n        );\n    }\n    \n    /**\n     * @notice Get the IDs of all trade deals in the system\n     * @return Array of all trade deal IDs\n     */\n    function getAllTradeDealIds() external view returns (uint256[] memory) {\n        return TradeDealLib._getAllTradeDealIds();\n    }\n    \n    /**\n     * @notice Check if a user is a participant in a trade deal\n     * @param tradeDealId ID of the trade deal to check\n     * @param user Address of the user to check\n     * @return True if the user is a participant, false otherwise\n     */\n    function isTradeDealParticipant(uint256 tradeDealId, address user) external view returns (bool) {\n        return TradeDealLib._isTradeDealParticipant(tradeDealId, user);\n    }\n\n    /**\n     * @notice Add a participant to a trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to add participant to\n     * @param participant Address of the participant to add\n     */\n    function addTradeDealParticipant(uint256 tradeDealId, address participant) external onlyOwner {\n        TradeDealLib.TradeDealParticipantResult memory result = TradeDealLib._addTradeDealParticipant(tradeDealId, participant);\n        emit TradeDealParticipantAdded(result.tradeDealId, result.participant);\n    }\n\n    /**\n     * @notice Remove a participant from a trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to remove participant from\n     * @param participant Address of the participant to remove\n     */\n    function removeTradeDealParticipant(uint256 tradeDealId, address participant) external onlyOwner {\n        TradeDealLib.TradeDealParticipantResult memory result = TradeDealLib._removeTradeDealParticipant(tradeDealId, participant);\n        emit TradeDealParticipantRemoved(result.tradeDealId, result.participant);\n    }\n    \n    /**\n     * @notice Deposit an invoice NFT as collateral into a trade deal\n     * @dev Caller must be a participant in the trade deal or the contract owner\n     * @dev The NFT must have totalAmount set in its metadata\n     * @param tradeDealId ID of the trade deal to deposit to\n     * @param tokenId Token ID of the invoice NFT to deposit\n     */\n    function tdDepositInvoice(uint256 tradeDealId, uint256 tokenId) external {\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) || msg.sender == LibDiamond.contractOwner(), \"Not a participant in this trade deal\");\n        \n        // Check that the NFT has totalAmount set in its metadata\n        uint256 totalAmount = TradeDealLib._getNFTInvoiceTotalAmount(tokenId);\n        require(totalAmount > 0, \"TRADE_DEAL: INVALID_NFT - Invoice NFT must have totalAmount set\");\n        \n        TradeDealLib.InvoiceActionResult memory result = TradeDealLib._depositInvoiceToTradeDeal(tradeDealId, tokenId);\n        \n        // Emit event with the returned data\n        emit InvoiceDepositedToTradeDeal(result.tradeDealId, result.tokenId);\n    }\n    \n    /**\n     * @notice Get the total amount from an NFT invoice's metadata\n     * @param tokenId The token ID of the NFT invoice\n     * @return The totalAmount value from the metadata\n     */\n    function getNFTInvoiceTotalAmount(uint256 tokenId) external view returns (uint256) {\n        return TradeDealLib._getNFTInvoiceTotalAmount(tokenId);\n    }\n    \n    /**\n     * @notice Withdraw a previously deposited invoice NFT from a trade deal\n     * @dev Caller must be the original depositor of the invoice or the contract owner\n     * @param tradeDealId ID of the trade deal to withdraw from\n     * @param tokenId Token ID of the invoice NFT to withdraw\n     */\n    function tdWithdrawInvoice(uint256 tradeDealId, uint256 tokenId) external {\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) || msg.sender == LibDiamond.contractOwner(), \"Not a participant in this trade deal\");\n        TradeDealLib.InvoiceActionResult memory result = TradeDealLib._withdrawInvoiceFromTradeDeal(tradeDealId, tokenId);\n        \n        // Emit event with the returned data\n        emit InvoiceWithdrawnFromTradeDeal(result.tradeDealId, result.tokenId);\n    }\n    \n    /**\n     * @notice Deposit USDC to a trade deal as funding\n     * @dev Caller must be a participant in the trade deal or the contract owner\n     * @dev If this deposit completes the funding target, the TradeDealFullyFunded event is emitted\n     * @param tradeDealId ID of the trade deal to deposit to\n     * @param amount Amount of USDC to deposit\n     */\n    function tdDepositUSDC(uint256 tradeDealId, uint256 amount) external {\n        TradeDealLib.USDCActionResult memory result = TradeDealLib._depositUSDCToTradeDeal(tradeDealId, amount);\n        \n        // Emit event with the returned data\n        emit USDCDepositedToTradeDeal(result.tradeDealId, result.amount, msg.sender);\n        \n        // If deposit completes the funding, emit the fully funded event too\n        if (result.isFullyFunded) {\n            emit TradeDealFullyFunded(result.tradeDealId, result.fundingTarget);\n        }\n    }\n    \n    /**\n     * @notice Withdraw USDC from a trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to withdraw from\n     * @param amount Amount of USDC to withdraw\n     */\n    function tdWithdrawUSDC(uint256 tradeDealId, uint256 amount) external onlyOwner {\n        TradeDealLib.USDCActionResult memory result = TradeDealLib._withdrawUSDCFromTradeDeal(tradeDealId, amount);\n        \n        // Emit event with the returned data\n        emit USDCWithdrawnFromTradeDeal(result.tradeDealId, result.amount);\n    }\n    \n    /**\n     * @notice Distribute interest for a trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to distribute interest for\n     */\n    function tdDistributeInterest(uint256 tradeDealId) external onlyOwner {\n        TradeDealLib.InterestDistributionResult memory result = TradeDealLib._distributeInterestForTradeDeal(tradeDealId);\n        \n        // Emit event with the returned data\n        emit InterestDistributedForTradeDeal(\n            result.tradeDealId,\n            result.totalInterest,\n            result.invoicePoolInterest,\n            result.interestInterest,\n            result.interestTokensMinted\n        );\n    }\n    \n    /**\n     * @notice Set the required claim topics for participation in a trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to set claim topics for\n     * @param claimTopics Array of claim topic IDs required for participation\n     */\n    function setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) external onlyOwner {\n        TradeDealLib.ClaimTopicsResult memory result = TradeDealLib._setTradeDealRequiredClaimTopics(tradeDealId, claimTopics);\n        \n        // Emit event with the returned data\n        emit TradeDealRequiredClaimTopicsSet(result.tradeDealId, result.claimTopics);\n    }\n    \n    /**\n     * @notice Get the required claim topics for participation in a trade deal\n     * @param tradeDealId ID of the trade deal to query\n     * @return Array of claim topic IDs required for participation\n     */\n    function getTradeDealRequiredClaimTopics(uint256 tradeDealId) external view returns (uint256[] memory) {\n        return TradeDealLib._getTradeDealRequiredClaimTopics(tradeDealId);\n    }\n    \n    /**\n     * @notice Set the token addresses for a specific trade deal\n     * @dev Only callable by the contract owner\n     * @param tradeDealId ID of the trade deal to set token addresses for\n     * @param collateralAddress Address of the Collateral token contract (cannot be zero)\n     * @param interestAddress Address of the VABI token contract (cannot be zero)\n     * @param usdcAddress Address of the USDC token contract (cannot be zero)\n     */\n    function setTradeDealTokenAddresses(\n        uint256 tradeDealId,\n        address /* nftAddress */, // This parameter is kept for backward compatibility but not used\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) external onlyOwner {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealLib.TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(TradeDealLib._tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(collateralAddress != address(0), \"Collateral address cannot be zero\");\n        require(interestAddress != address(0), \"VABI address cannot be zero\");\n        require(usdcAddress != address(0), \"USDC address cannot be zero\");\n        \n        TradeDealLib.TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        tradeDeal.collateralAddress = collateralAddress;\n        tradeDeal.interestAddress = interestAddress;\n        tradeDeal.usdcAddress = usdcAddress;\n        \n        // Emit event with updated token addresses\n        // Note: The interface ITradeDeal does not define TradeDealUpdated event anymore.\n        // Assuming the event should be emitted from the library or another mechanism.\n        // If TradeDealUpdated event is needed, it should be defined in this contract or imported correctly.\n        // For now, commenting out the problematic emit statement.\n        emit TradeDealUpdated(\n            tradeDealId,\n            tradeDeal.name,\n            tradeDeal.symbol,\n            tradeDeal.interestRate,\n            tradeDeal.collateralToInterestRatio,\n            tradeDeal.active,\n            collateralAddress,\n            interestAddress,\n            usdcAddress\n        );\n        // TODO: Revisit event emission strategy for TradeDealUpdated after token address changes.\n    }\n    \n    /**\n     * @notice Get the token addresses associated with a trade deal\n     * @param tradeDealId ID of the trade deal to query\n     * @return nftAddress Address of the NFT contract (this contract's address)\n     * @return collateralAddress Address of the Collateral token contract\n     * @return interestAddress Address of the VABI token contract\n     * @return usdcAddress Address of the USDC token contract\n     */\n    function getTradeDealTokenAddresses(uint256 tradeDealId) external view returns (\n        address nftAddress,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) {\n        TradeDealLib.TradeDeal memory tradeDeal = TradeDealLib._getTradeDealInfo(tradeDealId);\n        return (\n            address(this), // Return the Diamond address as the NFT address since we're using the Diamond's ERC721PermissionedTokenFacet\n            tradeDeal.collateralAddress,\n            tradeDeal.interestAddress,\n            tradeDeal.usdcAddress\n        );\n    }\n    \n    /**\n     * @notice This function is deprecated and has no effect\n     * @dev Kept as a no-op for backward compatibility since we're using the Diamond's ERC721PermissionedTokenFacet\n     */\n    function setTradeDealNFTAddress(uint256 /* tradeDealId */, address /* nftAddress */) external onlyOwner {\n        // No-op\n    }\n    \n    /**\n     * @notice Check if a trade deal has reached its funding target\n     * @param tradeDealId ID of the trade deal to check\n     * @return True if the trade deal is fully funded, false otherwise\n     */\n    function isTradeDealFunded(uint256 tradeDealId) external view returns (bool) {\n        return TradeDealLib._isTradeDealFunded(tradeDealId);\n    }\n    \n    /**\n     * @notice Check if a trade deal has been fully repaid\n     * @param tradeDealId ID of the trade deal to check\n     * @return True if the trade deal is fully repaid, false otherwise\n     */\n    function isTradeDealRepaid(uint256 tradeDealId) external view returns (bool) {\n        return TradeDealLib._isTradeDealRepaid(tradeDealId);\n    }\n    \n    /**\n     * @notice Allow fundees to withdraw USDC once the trade deal is fully funded (centrally-assisted mode)\n     * @param tradeDealId The ID of the trade deal to withdraw funding from\n     */\n    function withdrawTradeDealFundingForBorrower(uint256 tradeDealId, address borrowerAddress) external onlyOwner {\n        require(TradeDealLib._tradeDealExists(tradeDealId), \"TRADE_DEAL: NONEXISTENT - Trade deal does not exist\");\n        require(borrowerAddress != address(0), \"TRADE_DEAL: INVALID_BORROWER - Borrower address cannot be zero\");\n                \n        TradeDealLib.FundingWithdrawalResult memory result = TradeDealLib._withdrawTradeDealFunding(tradeDealId, borrowerAddress);\n        \n        // Emit event with the returned data\n        emit TradeDealFundingWithdrawn(result.tradeDealId, result.recipient, result.amount);\n    }\n    \n    /**\n     * @notice Allow borrowers to withdraw funds directly in self-service mode\n     * @param tradeDealId The ID of the trade deal to withdraw funding from\n     */\n    function withdrawTradeDealFundingSelf(uint256 tradeDealId) external {\n        require(tradeDealId >= 0, \"TRADE_DEAL: INVALID_ID - Trade deal ID must be greater than zero\");\n        require(TradeDealLib._tradeDealExists(tradeDealId), \"TRADE_DEAL: NONEXISTENT - Trade deal does not exist\");\n        \n        // Check if the trade deal is in self-service mode\n        TradeDealLib.TradeDeal memory tradeDeal = TradeDealLib._getTradeDealInfo(tradeDealId);\n        require(tradeDeal.operationMode == TradeDealLib.OperationMode.SELF_SERVICE,\n                \"TRADE_DEAL: INVALID_MODE - Trade deal is not in self-service mode\");\n        \n        // Call the library function to process the withdrawal\n        TradeDealLib.FundingWithdrawalResult memory result = TradeDealLib._withdrawTradeDealFundingSelf(tradeDealId, msg.sender);\n        \n        // Emit event with the returned data\n        emit TradeDealFundingWithdrawn(result.tradeDealId, result.recipient, result.amount);\n    }\n    \n    /**\n     * @notice Allow fundees to repay their debt\n     * @param tradeDealId The ID of the trade deal to repay\n     * @param amount The amount to repay\n     */\n    function repayTradeDeal(uint256 tradeDealId, uint256 amount) external {\n        require(tradeDealId >= 0, \"TRADE_DEAL: INVALID_ID - Trade deal ID must be greater than zero\");\n        require(amount > 0, \"TRADE_DEAL: INVALID_AMOUNT - Repayment amount must be greater than zero\");\n        require(TradeDealLib._tradeDealExists(tradeDealId), \"TRADE_DEAL: NONEXISTENT - Trade deal does not exist\");\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender),\n                \"TRADE_DEAL: UNAUTHORIZED - Caller is not a participant in this trade deal\");\n                \n        TradeDealLib.RepaymentResult memory result = TradeDealLib._repayTradeDeal(tradeDealId, amount);\n        \n        // Emit event with the returned data\n        emit TradeDealRepaid(result.tradeDealId, result.repayer, result.amount, result.fullyRepaid);\n    }\n\n    function repayTradeDealForBorrower(uint256 tradeDealId, address borrower, uint256 amount) external onlyOwner {\n        require(amount > 0, \"TRADE_DEAL: INVALID_AMOUNT - Repayment amount must be greater than zero\");\n        require(TradeDealLib._tradeDealExists(tradeDealId), \"TRADE_DEAL: NONEXISTENT - Trade deal does not exist\");\n                \n        TradeDealLib.RepaymentResult memory result = TradeDealLib._repayTradeDealForBorrower(tradeDealId, borrower, amount);\n        \n        // Emit event with the returned data\n        emit TradeDealRepaid(result.tradeDealId, result.repayer, result.amount, result.fullyRepaid);\n    }\n    \n    /**\n     * @notice Allow funders to redeem their Collateral tokens for USDC after the trade deal is repaid\n     * @param tradeDealId The ID of the trade deal\n     * @param collateralAmount The amount of Collateral tokens to redeem\n     */\n    function redeemCollateralTokens(uint256 tradeDealId, uint256 collateralAmount) external {\n        require(collateralAmount > 0, \"TRADE_DEAL: INVALID_AMOUNT - Collateral amount must be greater than zero\");\n        require(TradeDealLib._tradeDealExists(tradeDealId), \"TRADE_DEAL: NONEXISTENT - Trade deal does not exist\");\n        require(TradeDealLib._isTradeDealRepaid(tradeDealId), \"TRADE_DEAL: NOT_REPAID - Trade deal must be fully repaid\");\n        \n        // Verify the caller is a participant or has a valid Collateral token balance\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) ||\n                TradeDealLib._hasCollateralTokenBalance(tradeDealId, msg.sender, collateralAmount),\n                \"TRADE_DEAL: UNAUTHORIZED - Not authorized to redeem these tokens\");\n                \n        TradeDealLib.CollateralRedemptionResult memory result = TradeDealLib._redeemCollateralTokens(tradeDealId, collateralAmount);\n        \n        // Emit event with the returned data\n        emit CollateralTokensRedeemed(result.tradeDealId, result.redeemer, result.collateralAmount, result.usdcAmount);\n    }\n    \n    /**\n     * @notice Get comprehensive status information about a trade deal\n     * @dev Returns all relevant financial and status information about a trade deal in one call\n     * @param tradeDealId ID of the trade deal to get status for\n     * @return fundingTarget The target amount of funding in USDC\n     * @return currentBalance The current USDC balance of the trade deal\n     * @return isFunded Whether the trade deal has reached its funding target\n     * @return isFundingWithdrawn Whether the funding has been withdrawn by the fundee\n     * @return totalDebt The total debt including principal and interest\n     * @return repaidAmount The amount that has been repaid so far\n     * @return isRepaid Whether the trade deal has been fully repaid\n     */\n    function getTradeDealFullStatus(uint256 tradeDealId) external view returns (\n        uint256 fundingTarget,\n        uint256 currentBalance,\n        bool isFunded,\n        bool isFundingWithdrawn,\n        uint256 totalDebt,\n        uint256 repaidAmount,\n        bool isRepaid\n    ) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealLib.TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(TradeDealLib._tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\n        currentBalance = tds.tradeDealUsdcBalances[tradeDealId];\n        isFunded = TradeDealLib._isTradeDealFunded(tradeDealId);\n        isFundingWithdrawn = tds.tradeDealFundingWithdrawn[tradeDealId];\n        totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        repaidAmount = tds.tradeDealRepaidAmounts[tradeDealId];\n        isRepaid = TradeDealLib._isTradeDealRepaid(tradeDealId);\n    }\n}"
    },
    "contracts/facets/TrustedIssuersRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"../interfaces/IClaimIssuer.sol\";\nimport { ITrustedIssuersRegistry } from \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport { TrustedIssuer } from \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport { Modifiers } from \"../utilities/Modifiers.sol\";\n\nimport \"../identity/IdentityStorage.sol\";\n\n/// @title TrustedIssuersRegistryFacet\n/// @notice This contract is used to manage the trusted issuers registry\ncontract TrustedIssuersRegistryFacet is ITrustedIssuersRegistry, Modifiers {\n\tusing IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\tevent ClaimTopicRemoved(address indexed issuer, uint claimTopic);\n\n\t/// @notice get the trusted issuer struct given the trusted issuer address\n\t/// @param issuerAddress The address of the trusted issuer\n\t/// @return trustedIssuer The trusted issuer struct\n\tfunction getTrustedIssuer(address issuerAddress) external view override returns (TrustedIssuer memory) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\treturn _storage.trustedIssuers[issuerAddress];\n\t}\n\n\tfunction addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external override onlyOwner {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(!_storage.isTrustedIssuer(_trustedIssuer), \"Trusted issuer already exists\");\n\t\t_storage.addTrustedIssuer(_trustedIssuer, _claimTopics);\n\t\temit TrustedIssuerAdded(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction removeTrustedIssuer(address _trustedIssuer) external override onlyOwner {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\t// Change this line:\n\t\trequire(_storage.isTrustedIssuer(_trustedIssuer), \"Trusted issuer does not exist\");\n\t\t_storage.removeTrustedIssuer(_trustedIssuer);\n\t\temit TrustedIssuerRemoved(_trustedIssuer);\n\t}\n\n\tfunction updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external override onlyOwner {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(_storage.isTrustedIssuer(_trustedIssuer), \"Trusted issuer does not exist\");\n\t\t_storage.updateIssuerClaimTopics(_trustedIssuer, _claimTopics);\n\t\temit ClaimTopicsUpdated(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction getTrustedIssuers() external view override returns (TrustedIssuer[] memory) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\tTrustedIssuer[] memory trustedIssuers = new TrustedIssuer[](_storage.trustedIssuerAddresses.length);\n\t\tfor (uint256 i = 0; i < _storage.trustedIssuerAddresses.length; i++) {\n\t\t\ttrustedIssuers[i] = _storage.trustedIssuers[_storage.trustedIssuerAddresses[i]];\n\t\t}\n\t\treturn trustedIssuers;\n\t}\n\n\tfunction isTrustedIssuer(address _issuer) external view override returns (bool) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\treturn _storage.isTrustedIssuer(_issuer);\n\t}\n\n\tfunction getTrustedIssuerClaimTopics(address _trustedIssuer) external view override returns (uint[] memory) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\treturn _storage.trustedIssuers[_trustedIssuer].claimTopics;\n\t}\n\n\tfunction hasTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external view override returns (bool) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\treturn _storage.hasTrustedIssuerClaimTopic(_issuer, _claimTopic);\n\t}\n\n\tfunction addTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external onlyOwner {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(_storage.isTrustedIssuer(_issuer), \"Trusted issuer does not exist\");\n\t\t_storage.addTrustedIssuerClaimTopic(_issuer, _claimTopic);\n\t}\n\n\tfunction removeTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external onlyOwner {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(_storage.isTrustedIssuer(_issuer), \"Trusted issuer does not exist\");\n\t\t_storage.removeTrustedIssuerClaimTopic(_issuer, _claimTopic);\n\t\temit ClaimTopicRemoved(_issuer, _claimTopic);\n\t}\n}\n"
    },
    "contracts/identity/Identity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IIdentity } from \"../interfaces/IIdentity.sol\";\nimport { Controllable } from \"../utilities/Controllable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IAttribute, Attribute, AttributeType } from \"../interfaces/IAttribute.sol\";\n\nimport \"../identity/IdentityStorage.sol\";\n\n/// @title Identity\n/// @notice This contract represents an identity of a user\n/// @dev This contract is used to store the claims of a user\ncontract Identity is IIdentity, Controllable, Initializable {\n\t\n\tusing IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n\tmapping(bytes32 => Key) keys;\n\tmapping(uint256 => bytes32[]) keysByPurpose;\n\n\tmapping(string => Attribute) attributes;\n\tmapping(uint256 => string[]) attributeKeys;\n\n\taddress identityRegistry;\n\taddress trustedIssuerRegistry;\n\t\n\t// Events\n\tevent AttributeSet(string key, AttributeType attributeType, string value);\n\n\t// modifier checks if the sender is a trusted issuer\n\tmodifier onlyTrustedIssuer() {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(\n\t\t\tmsg.sender == address(this) ||\n\t\t\t_storage.isTrustedIssuer(msg.sender),\n\t\t\t\"Sender is not a trusted issuer\"\n\t\t);\n\t\t_;\n\t}\n\n\t// modifier checks if the sender is a trusted issuer for a specific claim topic\n\tmodifier isTrustedForClaimTopic(uint256 _claimTopic) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\trequire(_storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopic), \"Issuer not authorized for claim topic\");\n\t\t_;\n\t}\n\n\t// modifier checks if the sender is a trusted issuer for a set of claim topics\n\tmodifier isTrustedForClaimTopics( bool[] memory _claimTopics, uint256[] memory _allclaimTopics) {\n\t\tIdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\t\tfor (uint256 i = 0; i < _allclaimTopics.length; i++) {\n\t\t\tif (_claimTopics[i]) {\n\t\t\t\trequire(_storage.hasTrustedIssuerClaimTopic(msg.sender, _allclaimTopics[i]), \"Issuer not authorized for claim topic\");\n\t\t\t}\n\t\t}\n\t\t_;\n\t}\n\n    /// @notice get an attribute for a tokenid keyed by string\n    function getAttribute(\n        string memory _key\n    ) external view returns (Attribute memory _attrib) {\n\t\treturn attributes[_key];\n\t}\n\n\tfunction setAttribute(\n\t        string memory key,\n\t\t\tAttributeType attributeType,\n\t\t\tstring memory value\n\t    ) external onlyTrustedIssuer {\n\t\t\tattributes[key] = Attribute(key, attributeType, value);\n\t\t\tattributeKeys[uint256(attributeType)].push(key);\n\t\t\temit AttributeSet(key, attributeType, value);\n\t\t}\n\n\t/**\n\t * initialize the contract\n\t * @param _owner the owner of the contract\n\t * @param _identityRegistry the identity registry\n\t * @param _trustedIssuerRegistry the trusted issuer registry\n\t */\n\tfunction initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) external initializer {\n\t\t_addController(_owner);\n\t\tidentityRegistry = _identityRegistry;\n\t\ttrustedIssuerRegistry = _trustedIssuerRegistry;\n\t}\n\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\t/**\n\t * @notice add a key to the identity\n\t */\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external override onlyTrustedIssuer {\n\t\trequire(keys[_key].key != _key, \"Key already exists\");\n\n\t\tkeys[_key].key = _key;\n\t\tkeys[_key].purposes.push(_purpose);\n\t\tkeys[_key].keyType = _keyType;\n\n\t\tkeysByPurpose[_purpose].push(_key);\n\n\t\temit KeyAdded(_key, _purpose, _keyType);\n\t}\n\n\t/**\n\t * @notice remove a key from the identity\n\t */\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external override onlyTrustedIssuer {\n\t\trequire(keys[_key].key == _key, \"No such key\");\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\tdelete keys[_key].purposes[i];\n\t\t\t}\n\t\t}\n\n\t\temit KeyRemoved(_key, _purpose, keys[_key].keyType);\n\n\t\tdelete keys[_key];\n\t}\n\n\t/**\n\t * @notice get a key from the identity\n\t */\n\tfunction getKey(\n\t\tbytes32 _key\n\t) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n\t\treturn (keys[_key].purposes, keys[_key].keyType, keys[_key].key);\n\t}\n\n\t/**\n\t * @notice get the purposes of a key\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n\t\treturn (keys[_key].purposes);\n\t}\n\n\t/**\n\t * @notice get the keys of a purpose\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory _keys) {\n\t\treturn (keysByPurpose[_purpose]);\n\t}\n\n\t/**\n\t * @notice check if a key has a purpose\n\t */\n\tfunction _keyHasPurpose(bytes32 _key, uint256 _purpose) internal view returns (bool exists) {\n\t\tif (keys[_key].key == 0) return false;\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @notice check if a key has a purpose\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists) {\n\t\treturn _keyHasPurpose(_key, _purpose);\n\t}\n\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable onlyTrustedIssuer returns (uint256 executionId) {\n\t        require(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management rights\");\n\t        \n\t        executionId = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, _to, _value, _data)));\n\t        \n\t        (bool success, ) = _to.call{value: _value}(_data);\n\t        require(success, \"ETH transfer failed\"); // Added require statement\n\t        if (success) {\n\t            emit Executed(executionId, _to, _value, _data);\n\t        } else {\n\t            emit ExecutionFailed(executionId, _to, _value, _data);\n\t        }\n\t        \n\t        return executionId;\n\t    }\n\n\tfunction approve(uint256 _id, bool _approve) external override onlyTrustedIssuer {\n\t\t// require(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have rights\");\n\t\t// if (_approve) {\n\t\t// \temit Approved(_id, true);\n\t\t// } else {\n\t\t// \temit Approved(_id, false);\n\t\t// }\n\t}\n\n\tmapping(bytes32 => Claim) internal claims;\n\tbytes32[] internal claimIds;\n\n\tmapping(uint256 => bytes32[]) internal claimsByTopic;\n\tbytes32[] internal claimTopics;\n\n\t/**\n\t * @notice get the claim of an identity\n\t */\n\tfunction getClaim(bytes32 _claimId)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t) {\n\t\tClaim storage claim = claims[_claimId];\n\t\treturn (claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t}\n\n\t/**\n\t * @notice get the claim ids of an identity\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds_) {\n\t\tclaimIds_ = claimsByTopic[_topic];\n\t}\n\n\t/**\n\t * @notice add a claim to the identity\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) external override isTrustedForClaimTopic(_topic) returns (uint256 claimRequestId) {\n\n\t\tbytes32 claimId = keccak256(abi.encodePacked(_issuer, _topic));\n\n\t\tClaim storage claim = claims[claimId];\n\t\tclaim.topic = _topic;\n\t\tclaim.scheme = _scheme;\n\t\tclaim.issuer = _issuer;\n\t\tclaim.signature = _signature;\n\t\tclaim.data = _data;\n\t\tclaim.uri = _uri;\n\n\t\tclaimsByTopic[_topic].push(claimId);\n\t\tclaimTopics.push(claimId);\n\n\t\tclaims[claimId] = claim;\n\t\tclaimIds.push(claimId);\n\n\t\temit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\n\t\treturn _topic;\n\t}\n\n\t/**\n\t * @notice Change an existing claim\n\t * @dev Implementation is minimal to satisfy the interface requirement\n\t */\n\tfunction changeClaim(\n\t\tbytes32 _claimId,\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) external override isTrustedForClaimTopic(_topic) returns (bool) {\n\t\t// Verify the claim exists before attempting to change it\n\t\tClaim storage claim = claims[_claimId];\n\t\trequire(claim.issuer != address(0), \"Claim does not exist\");\n\t\t\n\t\t// Update the claim directly instead of removing and re-adding\n\t\tclaim.topic = _topic;\n\t\tclaim.scheme = _scheme;\n\t\tclaim.issuer = _issuer;\n\t\tclaim.signature = _signature;\n\t\tclaim.data = _data;\n\t\tclaim.uri = _uri;\n\t\t\n\t\temit ClaimChanged(_claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\t\t\n\t\treturn true;\n\t}\n\n\tfunction removeClaim(bytes32 _claimId) external override onlyTrustedIssuer returns (bool success) {\n\t\tClaim storage claim = claims[_claimId];\n\t\trequire(claim.issuer != address(0), \"Claim does not exist\");\n\t\tdelete claims[_claimId];\n\t\temit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t\treturn true;\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n\t\treturn interfaceId == type(IIdentity).interfaceId;\n\t}\n\n\t/**\n\t * @notice Get execution details for a given execution ID\n\t * @dev This function is part of the ERC734 interface but not implemented in this version\n\t */\n\tfunction getExecution(\n\t\tuint256\n\t)\n\t\texternal\n\t\tpure\n\t\toverride\n\t\treturns (address _addr, uint256 _value, bytes memory _data, bool _executed, uint256 _approved)\n\t{\n\t\t// Use descriptive variables to match return values\n\t\t_addr = address(0);\n\t\t_value = 0;\n\t\t_data = \"\";\n\t\t_executed = false;\n\t\t_approved = 0;\n\t\t\n\t\t// Descriptive error message explaining why it's not implemented and what to use instead\n\t\trevert(\"IDENTITY_EXECUTION_NOT_IMPLEMENTED: Execution functionality is not supported in this implementation. Use direct function calls instead.\");\n\t}\n\n\t function getClaimTopics() external view override returns (uint256[] memory) {\n\t\t uint256[] memory _claimTopics = new uint256[](claimTopics.length);\n\t\t for (uint256 i = 0; i < claimTopics.length; i++) {\n\t\t\t _claimTopics[i] = claims[claimTopics[i]].topic;\n\t\t }\n\t\t return _claimTopics;\n\t }\n\n\t /**\n\t  * @notice Check if this identity has been verified\n\t  * @return true if the identity has at least one valid claim, false otherwise\n\t  */\n\t function isVerified() external view returns (bool) {\n\t  // An identity is considered verified if it has at least one claim\n\t  return claimIds.length > 0;\n\t }\n}\n"
    },
    "contracts/identity/IdentityStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721A.sol\";\nimport {TrustedIssuer} from \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport {IIdentity} from \"../interfaces/IIdentity.sol\";\nimport {Claim} from \"../interfaces/IClaim.sol\";\nimport \"../interfaces/IMarketplace.sol\";\nimport {MultiSaleStorage} from \"../interfaces/IMultiSale.sol\";\nimport \"../libraries/TradeDealLib.sol\";\nimport \"../libraries/FeeDistributorLib.sol\"; // Add import for FeeDistributorLib\n\nimport \"hardhat/console.sol\";\n\nlibrary IdentitySystemStorage {\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n    using Address for address;\nbytes32 internal constant MULTISALE_STORAGE_POSITION =\n        keccak256(\"diamond.nextblock.bitgem.app.MultiSaleStorage.storage\");\n\n    function multiSaleStorage()\n        internal\n        pure\n        returns (MultiSaleStorage storage ds)\n    {\n        bytes32 position = MULTISALE_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    // CollateralStorage struct definition\n    struct CollateralStorage {\n        address nft;\n        address invoicePool;\n        address vabb;\n        address usdcPool;\n        address interest;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n    }\n\n    error ApprovalCallerNotOwnerNorApproved();\n    error ApprovalQueryForNonexistentToken();\n    error ApproveToCaller();\n    error ApprovalToCurrentOwner();\n    error BalanceQueryForZeroAddress();\n    error MintedQueryForZeroAddress();\n    error BurnedQueryForZeroAddress();\n    error AuxQueryForZeroAddress();\n    error MintToZeroAddress();\n    error MintZeroQuantity();\n    error OwnerIndexOutOfBounds();\n    error OwnerQueryForNonexistentToken();\n    error TokenIndexOutOfBounds();\n    error TransferCallerNotOwnerNorApproved();\n    error TransferFromIncorrectOwner();\n    error TransferToNonERC721ReceiverImplementer();\n    error TransferToZeroAddress();\n    error URIQueryForNonexistentToken();\n\n    struct IdentitySystem {\n        // ERC721A storage\n        ERC721AContract erc721Contract;\n        // TrustedIssuer storage\n        mapping(address => TrustedIssuer) trustedIssuers;\n        address[] trustedIssuerAddresses;\n        mapping(address => mapping(uint256 => bool)) trustedIssuerClaimTopics;\n        mapping(address => uint256[]) trustedIssuerClaimTopicsList;\n        mapping(uint256 => bool) topics;\n        uint256[] topicList;\n        // Identity storage\n        mapping(address => address) identities;\n        mapping(address => address) identityOwnersMap;\n        address[] identityOwners;\n        // Claim storage\n        mapping(address => mapping(uint256 => uint256)) claims;\n        mapping(address => uint256[]) claimList;\n        // Claim storage\n        mapping(uint256 => Claim) tokenClaims;\n        Claim[] tokenClaimList;\n        // ERC721Permissioned storage\n        address delegatedMinter;\n        mapping(uint256 => bool) frozen;\n\n        uint256 itemIds;\n        uint256 itemsSold;\n        mapping(uint256 => MarketItem) idToMarketItem;\n        mapping(uint256 => bool) idToListed;\n        MarketItem[] items;\n\n        // Merkle proof tracking for MultiSale\n        mapping(bytes32 => bool) usedMerkleLeaves;\n        \n        // Collateral storage\n        CollateralStorage collateralStorage;\n        \n        // Trade Deal storage\n        TradeDealLib.TradeDealStorage tradeDealStorage;\n\n        // Fee Distributor storage\n        FeeDistributorLib.FeeDistributorStorage feeDistributorStorage;\n    }\n\n    bytes32 constant IDENTITY_SYSTEM_STORAGE_POSITION =\n        keccak256(\"diamond.identity.system.storage\");\n\n    function diamondStorage()\n        internal\n        pure\n        returns (IdentitySystemStorage.IdentitySystem storage ds)\n    {\n        bytes32 position = IDENTITY_SYSTEM_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function _tokenExists(\n        IdentitySystem storage self,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        return self.erc721Contract._ownerships[_tokenId].addr != address(0);\n    }\n\n    function _getIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (address addr) {\n        return self.identities[_userAddress];\n    }\n\n    function getIdentityOwner(\n        IdentitySystem storage self,\n        address _identity\n    ) internal view returns (address) {\n        return self.identityOwnersMap[_identity];\n    }\n\n    function isIdentityAddress(\n        IdentitySystem storage self,\n        address _identity\n    ) internal view returns (bool) {\n        return self.identityOwnersMap[_identity] != address(0);\n    }\n\n    function isRegistered(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return self.identities[_userAddress] != address(0);\n    }\n\n    function isIdentityOwner(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return\n            self.identityOwnersMap[self.identities[_userAddress]] ==\n            _userAddress;\n    }\n\n    // trusted issuer\n\n    function isTrustedIssuer(\n        IdentitySystem storage self,\n        address _issuer\n    ) internal view returns (bool) {\n        return self.trustedIssuers[_issuer].claimIssuer != address(0);\n    }\n\n    function addTrustedIssuer(\n        IdentitySystem storage self,\n        address _trustedIssuer,\n        uint[] calldata _claimTopics\n    ) internal {\n        self.trustedIssuers[_trustedIssuer] = TrustedIssuer({\n            claimIssuer: _trustedIssuer,\n            claimTopics: _claimTopics\n        });\n        self.trustedIssuerAddresses.push(_trustedIssuer);\n    }\n\n    function removeTrustedIssuer(\n        IdentitySystem storage self,\n        address _trustedIssuer\n    ) internal {\n        delete self.trustedIssuers[_trustedIssuer];\n        for (uint256 i = 0; i < self.trustedIssuerAddresses.length; i++) {\n            if (self.trustedIssuerAddresses[i] == _trustedIssuer) {\n                self.trustedIssuerAddresses[i] = self.trustedIssuerAddresses[\n                    self.trustedIssuerAddresses.length - 1\n                ];\n                self.trustedIssuerAddresses.pop();\n                break;\n            }\n        }\n    }\n\n    // claim topics\n\n    function addClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal {\n        self.topics[_claimTopic] = true;\n        self.topicList.push(_claimTopic);\n    }\n\n    function removeClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal {\n        delete self.topics[_claimTopic];\n        for (uint256 i = 0; i < self.topicList.length; i++) {\n            if (self.topicList[i] == _claimTopic) {\n                self.topicList[i] = self.topicList[self.topicList.length - 1];\n                self.topicList.pop();\n                break;\n            }\n        }\n    }\n\n    function getClaimTopics(\n        IdentitySystem storage self\n    ) internal view returns (uint256[] memory) {\n        return self.topicList;\n    }\n\n    function hasClaimTopic(\n        IdentitySystem storage self,\n        uint256 _claimTopic\n    ) internal view returns (bool) {\n        return self.topics[_claimTopic];\n    }\n\n    // trusted issuer / claim topics\n\n    function updateIssuerClaimTopics(\n        IdentitySystem storage self,\n        address _trustedIssuer,\n        uint[] calldata _claimTopics\n    ) internal {\n        self.trustedIssuers[_trustedIssuer].claimTopics = _claimTopics;\n        for (\n            uint256 i = 0;\n            i < self.trustedIssuerClaimTopicsList[_trustedIssuer].length;\n            i++\n        ) {\n            delete self.trustedIssuerClaimTopics[_trustedIssuer][\n                self.trustedIssuerClaimTopicsList[_trustedIssuer][i]\n            ];\n        }\n    }\n\n    function addTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint _claimTopic\n    ) internal {\n        self.trustedIssuerClaimTopics[_issuer][_claimTopic] = true;\n        self.trustedIssuerClaimTopicsList[_issuer].push(_claimTopic);\n    }\n\n    function removeTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint _claimTopic\n    ) internal {\n        delete self.trustedIssuerClaimTopics[_issuer][_claimTopic];\n        for (\n            uint256 i = 0;\n            i < self.trustedIssuerClaimTopicsList[_issuer].length;\n            i++\n        ) {\n            if (self.trustedIssuerClaimTopicsList[_issuer][i] == _claimTopic) {\n                self.trustedIssuerClaimTopicsList[_issuer][i] = self\n                    .trustedIssuerClaimTopicsList[_issuer][\n                        self.trustedIssuerClaimTopicsList[_issuer].length - 1\n                    ];\n                self.trustedIssuerClaimTopicsList[_issuer].pop();\n                break;\n            }\n        }\n    }\n\n    modifier isTrustedIssuerForClaimTopic(uint256 _claimTopic) {\n        IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        require(_storage.isTrustedIssuer(msg.sender), \"Not a trusted issuer\");\n        require(\n            _storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopic),\n            \"Issuer not authorized for claim topic\"\n        );\n        _;\n    }\n\n    function hasTrustedIssuerClaimTopic(\n        IdentitySystem storage self,\n        address _issuer,\n        uint256 _claimTopic\n    ) internal view returns (bool) {\n        if (!self.isTrustedIssuer(_issuer)) return false;\n        uint256[] storage claimTopics = self\n            .trustedIssuers[_issuer]\n            .claimTopics;\n        for (uint256 i = 0; i < claimTopics.length; i++) {\n            if (claimTopics[i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function addIdentity(\n        IdentitySystem storage self,\n        address _userAddress,\n        address _identity\n    ) internal {\n        self.identities[_userAddress] = _identity;\n        self.identityOwners.push(_userAddress);\n        self.identityOwnersMap[_identity] = _userAddress;\n    }\n\n    function removeIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal {\n        address identityAddress = self.identities[_userAddress]; // Capture identity address before deletion\n        delete self.identities[_userAddress];\n        for (uint256 i = 0; i < self.identityOwners.length; i++) {\n            if (self.identityOwners[i] == _userAddress) {\n                self.identityOwners[i] = self.identityOwners[\n                    self.identityOwners.length - 1\n                ];\n                self.identityOwners.pop();\n                self.identityOwnersMap[identityAddress] = address(0); // Use captured identityAddress\n                break;\n            }\n        }\n    }\n\n    function hasIdentity(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        address identity = self.identities[_userAddress];\n        return identity != address(0);\n    }\n\n    function hasClaims(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return self.identities[_userAddress] != address(0);\n    }\n\n    function isVerified(\n        IdentitySystem storage self,\n        address _userAddress\n    ) internal view returns (bool) {\n        return hasIdentity(self, _userAddress) && hasClaims(self, _userAddress);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        IdentitySystem storage self,\n        address msgSender,\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        uint256 startTokenId = self.erc721Contract._currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        self._beforeTokenTransfer(address(0), to, startTokenId, true);\n\n        unchecked {\n            self.erc721Contract._addressData[to].balance += uint64(quantity);\n            self.erc721Contract._addressData[to].numberMinted += uint64(quantity);\n\n            self.erc721Contract._ownerships[startTokenId].addr = to;\n            self.erc721Contract._ownerships[startTokenId].startTimestamp = uint64(\n                block.timestamp\n            );\n\n            uint256 updatedIndex = startTokenId;\n\n            // log quantity\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (\n                    safe &&\n                    !_checkOnERC721Received(\n                        msgSender,\n                        address(0),\n                        to,\n                        updatedIndex,\n                        _data\n                    )\n                ) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                }\n                self.erc721Contract._currentIndex = updatedIndex + 1;\n                updatedIndex++;\n                self._addTokenToAllTokensEnumeration(updatedIndex); // Add this line\n            }\n        }\n\n        _afterTokenTransfer(self, address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256) {\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\n        return uint256(self.erc721Contract._addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint64) {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        return self.erc721Contract._addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(\n        IdentitySystem storage self,\n        address owner,\n        uint64 aux\n    ) internal {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        self.erc721Contract._addressData[owner].aux = aux;\n    }\n\n    function ownershipOf(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n        unchecked {\n            if (curr < self.erc721Contract._currentIndex) {\n                TokenOwnership memory ownership = self.erc721Contract._ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = self.erc721Contract._ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (bool) {\n        return\n            tokenId < self.erc721Contract._currentIndex && !self.erc721Contract._ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (address) {\n        if (!_exists(self, tokenId)) revert ApprovalQueryForNonexistentToken();\n        return self.erc721Contract._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(\n        IdentitySystem storage self,\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        self.erc721Contract._operatorApprovals[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        IdentitySystem storage self,\n        address owner,\n        address operator\n    ) internal view returns (bool) {\n        return self.erc721Contract._operatorApprovals[owner][operator];\n    }\n\n    function currentIndex(\n        IdentitySystem storage self\n    ) internal view returns (uint256) {\n        return self.erc721Contract._currentIndex;\n    }\n    \n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        IdentitySystem storage self,\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bool _force\n    ) internal {\n        TokenOwnership memory prevOwnership = self.ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (msgSender == prevOwnership.addr ||\n            self.isApprovedForAll(prevOwnership.addr, msgSender) ||\n            self.getApproved(tokenId) == msgSender);\n\n        if (!isApprovedOrOwner && !_force)\n            revert TransferCallerNotOwnerNorApproved();\n        if (prevOwnership.addr != from && !_force) revert TransferFromIncorrectOwner();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        self._beforeTokenTransfer(from, to, tokenId, _force);\n\n        if (from == address(0)) {\n            self._addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            self._removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            self._removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            self._addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        // Clear approvals from the previous owner\n        self._approve(address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self.erc721Contract._addressData[from].balance -= 1;\n            self.erc721Contract._addressData[to].balance += 1;\n\n            self.erc721Contract._ownerships[tokenId].addr = to;\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self.erc721Contract._currentIndex) {\n                    self.erc721Contract._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = prevOwnership\n                        .startTimestamp;\n                }\n            }\n        }\n        \n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(self, from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(IdentitySystem storage self, address from, uint256 tokenId) internal {\n        self._beforeTokenTransfer(from, address(0), tokenId, true);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, from);\n\n        self._removeTokenFromOwnerEnumeration(from, tokenId);\n        self._removeTokenFromAllTokensEnumeration(tokenId);\n\n        unchecked {\n            self.erc721Contract._addressData[from].balance -= 1;\n            self.erc721Contract._addressData[from].numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            self.erc721Contract._ownerships[tokenId].addr = from;\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n            self.erc721Contract._ownerships[tokenId].burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self.erc721Contract._currentIndex) {\n                    self.erc721Contract._ownerships[nextTokenId].addr = from;\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = self.erc721Contract._ownerships[tokenId].startTimestamp;\n                }\n            }\n        }\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfer(self, from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self.erc721Contract._burnCounter++;\n        }\n    }\n\n    function exists(IdentitySystem storage self, uint256 tokenId) internal view returns (bool) {\n        return _exists(self, tokenId);\n    }\n\n\n    function setTokenClaimTopics(IdentitySystem storage self, uint256 tokenId, uint256[] memory claimTopics) internal {\n        require(self.exists(tokenId), \"ERC721: token does not exist\");\n        for (uint256 i = 0; i < claimTopics.length; i++) {\n            self.tokenClaims[tokenId] = Claim({\n                topic: claimTopics[i],\n                scheme: 0,\n                issuer: address(this),\n                signature: \"\",\n                data: \"\",\n                uri: \"\"\n            });\n        }\n    }\n\n    function getTokenClaimTopics(uint256 tokenId) public view returns (Claim[] memory) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(identitySystem._exists(tokenId), \"ERC721: token does not exist\");\n        Claim[] memory claimTopics = new Claim[](identitySystem.tokenClaimList.length);\n        for (uint256 i = 0; i < identitySystem.tokenClaimList.length; i++) {\n            claimTopics[i] = identitySystem.tokenClaims[tokenId];\n        }\n        return claimTopics;\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        IdentitySystem storage self,\n        address to,\n        uint256 tokenId,\n        address owner\n    ) internal {\n        self.erc721Contract._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function _ownerOf(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal view returns (address) {\n        return ownershipOf(self, tokenId).addr;\n    }\n\n    function _isContract(\n        address account\n    ) internal view returns (bool) {\n        // According to EIP-1052, an address is a contract if it has code.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (_isContract(to)) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msgSender,\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function tokensOfOwner(\n        IdentitySystem storage self,\n        address owner\n    ) internal view returns (uint256[] memory) {\n        require(owner != address(0), \"IdentityStorage: owner query for zero address\");\n        \n        uint256 ownerTokenCount = IERC721(address(this)).balanceOf(owner);\n        if (ownerTokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        }\n        \n        uint256[] memory tokens = new uint256[](ownerTokenCount);\n        for (uint256 i = 0; i < ownerTokenCount; i++) {\n            tokens[i] = self.erc721Contract._ownedTokens[owner][i];\n        }\n        \n        return tokens;\n    }\n\n    function tokenOfOwnerByIndex(\n        IdentitySystem storage self,\n        address owner, \n        uint256 index) internal view returns (uint256) {\n        require(index < IERC721(address(this)).balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return self.erc721Contract._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply(\n        IdentitySystem storage self\n    ) internal view returns (uint256) {\n        return self.erc721Contract._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(\n        IdentitySystem storage self,\n        uint256 index\n    ) internal view returns (uint256) {\n        require(index < totalSupply(self), \"ERC721Enumerable: global index out of bounds\");\n        return self.erc721Contract._allTokens[index];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(\n        IdentitySystem storage self,\n        address to, \n        uint256 tokenId) internal {\n        uint256 length = IERC721(address(this)).balanceOf(to);\n        self.erc721Contract._ownedTokens[to][length] = tokenId;\n        self.erc721Contract._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(\n        IdentitySystem storage self,\n        uint256 tokenId) internal {\n        self.erc721Contract._allTokensIndex[tokenId] = self.erc721Contract._allTokens.length + 1;\n        self.erc721Contract._allTokens.push(tokenId);\n    }\n\n    function _getIdentityAddress(IdentitySystem storage self, address _address) internal view returns (address) {\n        address identityAddress = self._getIdentity(_address);\n        return identityAddress != address(0) ? identityAddress : _address;\n    }\n\n    function _hasClaim(IdentitySystem storage self, address _address, uint256 _claimTopic) internal view returns (bool) {\n        address idObj = self._getIdentityAddress(_address);\n        for (uint256 i = 0; i < self.claimList[idObj].length; i++) {\n            if (self.claimList[idObj][i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(\n        IdentitySystem storage self,\n        address from,\n        uint256 tokenId\n    ) internal {\n        // address owner = IERC721(address(this)).ownerOf(tokenId);\n        address thisAddress = address(this);\n\n\n        // require(owner == thisAddress, \"ERC721: transfer of token that is not own\");\n        uint256 lastTokenIndex = IERC721(thisAddress).balanceOf(from) - 1; \n        uint256 tokenIndex = self.erc721Contract._ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = self.erc721Contract._ownedTokens[from][lastTokenIndex];\n\n            self.erc721Contract._ownedTokens[from][tokenIndex] = lastTokenId;\n            self.erc721Contract._ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete self.erc721Contract._ownedTokensIndex[tokenId];\n        delete self.erc721Contract._ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(\n        IdentitySystem storage self,\n        uint256 tokenId\n    ) internal {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = self.erc721Contract._allTokens.length - 1;\n        uint256 tokenIndex = self.erc721Contract._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = self.erc721Contract._allTokens[lastTokenIndex];\n\n        self.erc721Contract._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        self.erc721Contract._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete self.erc721Contract._allTokensIndex[tokenId];\n        self.erc721Contract._allTokens.pop();\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n\n    function _beforeTokenTransfer(\n        IdentitySystem storage self,\n        address from,\n        address to,\n        uint256,\n        bool force\n    ) internal view {\n        // Allow transfers from or to the contract itself without additional checks\n        if(force) return;\n\n        bool hasCommonClaim = false;\n        uint256 claimType = 1; // Start from claim type 1\n\n        while (!hasCommonClaim) {\n            bool hasFromClaim = self._hasClaim(from, claimType) ||\n                from == address(this);\n            if (hasFromClaim && self._hasClaim(to, claimType)) {\n                hasCommonClaim = true;\n            } else {\n                claimType++;\n                if (claimType == 0) {\n                    // Overflow, we've checked all possible claim types\n                    break;\n                }\n            }\n        }\n\n        require(\n            hasCommonClaim,\n            \"ERC721: sender and receiver do not have a common claim\"\n        );\n    }\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfer(\n        IdentitySystem storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal {}\n}\n"
    },
    "contracts/IdentityFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./identity/Identity.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./identity/IdentityStorage.sol\";\nimport \"./interfaces/ITrustedIssuersRegistry.sol\";\nimport { IERC173 } from \"./interfaces/IERC173.sol\";\n\n\ncontract IdentityFactory is Initializable {\n\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    address private _template;\n    address private _trustedIssuerRegistry;\n    address private _identityRegistry;\n\n    mapping(address => address) private _identities;\n    address[] private _identityList;\n\n    event IdentityCreated(address indexed owner, address indexed identity);\n\n    modifier onlyOwnerOrTrustedIssuer() {\n        require(\n            msg.sender == owner() || // Delegate ownership check to the diamond\n            ITrustedIssuersRegistry(_identityRegistry).isTrustedIssuer(msg.sender), // Use TrustedIssuersRegistryFacet\n            \"Sender is not a trusted issuer\"\n        );\n        _;\n    }\n\n    constructor() {\n        _template = address(new Identity());\n    }\n\n    /**\n     * init the fdactory with the registries\n     * @param identityRegistry the identity registry\n     * @param trustedIssuerRegistry the trusted issuer registry\n     */\n    function initialize(address identityRegistry, address trustedIssuerRegistry) external initializer {\n\t\t_identityRegistry = identityRegistry;\n\t\t_trustedIssuerRegistry = trustedIssuerRegistry;\n\t}\n\n    /**\n     * @notice Delegate ownership check to the diamond\n     * @return The owner of the diamond\n     */\n    function owner() public view returns (address) {\n        return IERC173(_identityRegistry).owner();\n    }\n\n    /** \n     * create a new identity\n     */\n    function createIdentity(address ownerAddress) public onlyOwnerOrTrustedIssuer {\n        require(ownerAddress != address(0), \"Invalid owner address\");\n        require(address(_identities[ownerAddress]) == address(0), \"Identity already exists\");\n        address addr = Clones.clone(_template);\n        Identity(addr).initialize(ownerAddress, _identityRegistry, _trustedIssuerRegistry);\n        _identities[ownerAddress] = addr;\n        _identityList.push(addr);\n        emit IdentityCreated(ownerAddress, addr);\n    }\n\n    function removeIdentity(address ownerAddress) public onlyOwnerOrTrustedIssuer {\n        require(_identities[ownerAddress] != address(0), \"Identity does not exist\");\n        // remove from the mapping\n        delete _identities[ownerAddress];\n        \n        // Remove from the array\n        for (uint i = 0; i < _identityList.length; i++) {\n            if (_identityList[i] == _identities[ownerAddress]) {\n                _identityList[i] = _identityList[_identityList.length - 1];\n                _identityList.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * get the identity of an owner\n     * @param identityOwner the owner of the identity\n     * @return the identity\n     */\n    function getIdentity(address identityOwner) public view returns (address) {\n        return _identities[identityOwner];\n    }\n\n    /**\n     * get the list of identities\n     * @return the list of identities\n     */\n    function getIdentityUsers() public view returns (address[] memory) {\n        return _identityList;\n    }\n}\n"
    },
    "contracts/interfaces/IAttribute.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nenum AttributeType {\r\n    Unknown,\r\n    String ,\r\n    Bytes32,\r\n    Uint256,\r\n    Uint8,\r\n    Uint256Array,\r\n    Uint8Array\r\n}\r\n\r\nstruct Attribute {\r\n    string key;\r\n    AttributeType attributeType;\r\n    string value;\r\n}\r\n\r\n// attribute storage\r\nstruct AttributeContract {\r\n    mapping(uint256 => bool)  burnedIds;\r\n    mapping(uint256 => mapping(string => Attribute))  attributes;\r\n    mapping(uint256 => string[]) attributeKeys;\r\n    mapping(uint256 =>  mapping(string => uint256)) attributeKeysIndexes;\r\n}\r\n\r\n\r\n/// @notice a pool of tokens that users can deposit into and withdraw from\r\ninterface IAttribute {\r\n    /// @notice get an attribute for a tokenid keyed by string\r\n    function getAttribute(\r\n        uint256 id,\r\n        string memory key\r\n    ) external view returns (Attribute calldata _attrib);\r\n}\r\n"
    },
    "contracts/interfaces/ICarbonCredit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { CarbonCreditStatus } from \"../libraries/CarbonCreditLib.sol\";\n\n/// @title ICarbonCredit\n/// @notice Interface for managing carbon credits associated with ERC721 tokens\ninterface ICarbonCredit {\n    /// @notice Event emitted when carbon credits are initialized\n    /// @param tokenId The ID of the ERC721 token\n    /// @param initialBalance The initial balance of carbon credits\n    event CarbonCreditsInitialized(uint256 indexed tokenId, uint256 initialBalance);\n\n    /// @notice Event emitted when carbon credits are retired\n    /// @param tokenId The ID of the ERC721 token\n    /// @param amount The amount of carbon credits retired\n    /// @param remainingBalance The remaining balance of carbon credits for the token\n    event CarbonCreditsRetired(uint256 indexed tokenId, uint256 amount, uint256 remainingBalance);\n\n    /// @notice Initialize carbon credit balance for an ERC721 token\n    /// @param tokenId The ID of the ERC721 token\n    /// @param initialBalance The initial balance of carbon credits\n    function initializeCarbonCredit(uint256 tokenId, uint256 initialBalance) external;\n\n    /// @notice Retire carbon credits for an ERC721 token\n    /// @param tokenId The ID of the ERC721 token\n    /// @param amount The amount of carbon credits to retire (must be a whole number)\n    function retireCarbonCredits(uint256 tokenId, uint256 amount) external;\n\n    /// @notice Get the current carbon credit balance for an ERC721 token\n    /// @param tokenId The ID of the ERC721 token\n    /// @return The current balance of carbon credits for the token\n    function getCarbonCreditStatus(uint256 tokenId) external view returns (CarbonCreditStatus);\n\n    /// @notice Get the current carbon credit balance for an ERC721 token\n    /// @param tokenId The ID of the ERC721 token\n    /// @return The current balance of carbon credits for the token\n    function getCarbonCreditBalance(uint256 tokenId) external view returns (uint256);\n\n    /// @notice Initialize carbon credit balances for multiple ERC721 tokens\n    /// @param tokenIds An array of ERC721 token IDs\n    /// @param initialBalances An array of initial balances corresponding to the token IDs\n    function batchInitializeCarbonCredits(uint256[] calldata tokenIds, uint256[] calldata initialBalances) external;\n\n    /// @notice Get the carbon credit balances for multiple ERC721 tokens\n    /// @param tokenIds An array of ERC721 token IDs\n    /// @return An array of carbon credit balances corresponding to the token IDs\n    function getAllCarbonCreditBalances(uint256[] calldata tokenIds) external view returns (uint256[] memory);\n}"
    },
    "contracts/interfaces/IClaim.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n}"
    },
    "contracts/interfaces/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IIdentity.sol\";\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n    bool isRemoved;\n}\n\ninterface IClaimIssuer is IIdentity {\n\n    event ClaimRevoked(bytes indexed signature);\n\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n    function revokeClaimBySignature(bytes calldata signature) external;\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\n    \n}"
    },
    "contracts/interfaces/IClaimTopicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IClaimTopicsRegistry {\n\n    // events\n    event ClaimTopicAdded(uint256 indexed claimTopic);\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\n\n    // functions\n    // setters\n    function addClaimTopic(uint256 _claimTopic) external;\n    function removeClaimTopic(uint256 _claimTopic) external;\n\n    // getter\n    function getClaimTopics() external view returns (uint256[] memory);\n\n}"
    },
    "contracts/interfaces/ICollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICollateral {\n    function mint(address to, uint256 amount) external;\n    function burn(address from, uint256 amount) external;\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice a controllable contract interface. allows for controllers to perform privileged actions. controllera can other controllers and remove themselves.\r\ninterface IControllable {\r\n\r\n    /// @notice emitted when a controller is added.\r\n    event ControllerAdded(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice emitted when a controller is removed.\r\n    event ControllerRemoved(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice adds a controller.\r\n    /// @param controller the controller to add.\r\n    function addController(address controller) external;\r\n\r\n    /// @notice removes a controller.\r\n    /// @param controller the address to check\r\n    /// @return true if the address is a controller\r\n    function isController(address controller) external view returns (bool);\r\n\r\n    /// @notice remove ourselves from the list of controllers.\r\n    function relinquishControl() external;\r\n}\r\n"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\nstruct DiamondSettings {\n  address owner;\n  address factory;\n  address svgManager;\n  string symbol;\n  string name;\n}\n\nstruct DiamondContract {\n  DiamondSettings settings;\n  mapping(string=>string) metadata;\n}\n\nstruct DiamondStorage {\n  DiamondContract diamondContract;\n}\n\n\ninterface IDiamond {\n  function getDiamondAddress() external view returns (address);\n}\n\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Propose an upgrade to be executed after the timelock period\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    function proposeDiamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Execute a previously proposed upgrade after the timelock period\r\n    function executeDiamondCut() external;\r\n    \r\n    /// @notice Cancel a proposed upgrade\r\n    function cancelDiamondCut() external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n    event DiamondCutProposed(address indexed proposer, uint256 indexed proposalTime, uint256 executionTime);\r\n    event DiamondCutCancelled(address indexed canceller);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\n\nstruct DiamondFactoryInit {\n    string setName;\n    IDiamondCut.FacetCut[] facetAddresses;\n    bytes diamondBytecode;\n}\n\nstruct DiamondFactoryContract {\n    string[] diamondSymbols;\n    mapping(string => address) diamondAddresses;\n    mapping(string => IDiamondCut.FacetCut[]) facetsToAdd;\n    string[] facetSets;\n    string defaultFacetSet;\n    address diamondInit_;\n    bytes calldata_;\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC173 } from \"./IERC173.sol\";\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"./IDiamondLoupe.sol\";\nimport { IClaimTopicsRegistry } from \"./IClaimTopicsRegistry.sol\";\nimport { IIdentityRegistry } from \"./IIdentityRegistry.sol\";\nimport { ITrustedIssuersRegistry } from \"./ITrustedIssuersRegistry.sol\";\nimport { IERC721Permissioned } from \"./IERC721Permissioned.sol\";\nimport { IERC721Enumerable } from \"./IERC721Enumerable.sol\";\n// import { ICustomerMinterFacet } from \"./ICustomerMinterFacet.sol\"; // Removed - Not in facetsList\nimport { IERC721MetadataFacet } from \"./IERC721MetadataFacet.sol\";\n// import { ERC721AMetadataFacet } from \"../tokens/ERC721/ERC721AMetadataFacet.sol\"; // Removed - Incorrect import (implementation instead of interface)\nimport { IERC721AAttributesFacet } from \"./IERC721AAttributesFacet.sol\";\nimport { IMarketplace } from \"./IMarketplace.sol\";\nimport { IGemforceMinterFacet } from \"./IGemforceMinterFacet.sol\";\nimport { IMultiSale } from \"./IMultiSale.sol\";\nimport { ISVG } from \"./ISVG.sol\";\nimport { ICarbonCredit } from \"./ICarbonCredit.sol\";\nimport { ITradeDeal } from \"./ITradeDeal.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\n\n\ninterface IDiamondToken is\n    IERC721, // Base ERC721\n    IERC173, // OwnershipFacet\n    IDiamondCut, // DiamondCutFacet\n    IDiamondLoupe, // DiamondLoupeFacet\n    IClaimTopicsRegistry, // ClaimTopicsRegistryFacet\n    IIdentityRegistry, // IdentityRegistryFacet\n    ITrustedIssuersRegistry, // TrustedIssuersRegistryFacet\n    IERC721Permissioned, // ERC721PermissionedTokenFacet\n    IERC721Enumerable, // ERC721EnumerableFacet\n    IERC721MetadataFacet, // ERC721AMetadataFacet\n    IERC721AAttributesFacet, // ERC721AAttributesFacet\n    IMarketplace, // MarketplaceFacet\n    IGemforceMinterFacet, // GemforceMinterFacet\n    IMultiSale, // MultiSaleFacet\n    ISVG, // SVGTemplatesFacet\n    ICarbonCredit, // CarbonCreditFacet\n    ITradeDeal, // TradeDealFacet\n    IFeeDistributor // FeeDistributorFacet\n{\n    // function initialize(address delegatedMinter_) external; // Initialization might be handled by DiamondInit now\n}"
    },
    "contracts/interfaces/IERC1155Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// implemented by erc1155 tokens to allow mminting\ninterface IERC1155Mint {\n\n    /// @notice event emitted when tokens are minted\n    event ERC1155TokenMinted(\n        address minter,\n        uint256 id,\n        uint256 quantity\n    );\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param quantity the amount to mint\n    function mint(\n        uint256 id,\n        uint256 quantity,\n        bytes memory data\n    ) external;\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param recipient the mint target\n    /// @param quantity the amount to mint\n    function mintTo(\n        address recipient,\n        uint256 id,\n        uint256 quantity,\n        bytes memory data\n    ) external;\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param recipient the mint target\n    /// @param quantities the quantity to mint\n    /// @param data transfer bytes data\n    function batchMintTo(\n        address recipient,\n        uint256[] memory ids,\n        uint256[] calldata quantities,\n        bytes memory data\n    ) external;\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC20Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// implemented by erc1155 tokens to allow mminting\ninterface IERC20Mint {\n\n    /// @notice event emitted when tokens are minted\n    event ERC20Minted(\n        address token,\n        address receiver,\n        uint256 amount\n    );\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param amount the amount to mint\n    function mint(\n        uint256 amount\n    ) external;\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param recipient the mint target\n    /// @param amount the amount to mint\n    function mintTo(\n        address recipient,\n        uint256 amount\n    ) external;\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param recipients the mint target\n    /// @param amount the amount to mint\n    function batchMintTo(\n        address[] memory recipients,\n        uint256[] memory amount\n    ) external;\n\n}\n"
    },
    "contracts/interfaces/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/* solhint-disable indent */\n\n// Compiler will pack this into a single 256bit word.\nstruct TokenOwnership {\n    address addr; // The address of the owner.\n    uint64 startTimestamp; // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n    bool burned; // Whether the token has been burned.\n}\n\n// Compiler will pack this into a single 256bit word.\nstruct AddressData {\n    \n    uint64 balance; // Realistically, 2**64-1 is more than enough.\n    uint64 numberMinted; // Keeps track of mint count with minimal overhead for tokenomics.\n    uint64 numberBurned; // Keeps track of burn count with minimal overhead for tokenomics.\n    // For miscellaneous variable(s) pertaining to the address\n    // (e.g. number of whitelist mint slots used).\n    // If there are multiple variables, please pack them into a uint64.\n    uint64 aux;\n}\n\nstruct ERC721AContract {\n    // The tokenId of the next token to be minted.\n    uint256 _currentIndex;\n\n    // The number of tokens burned.\n    uint256 _burnCounter;\n\n    // Token name\n    string _name;\n\n    // Token symbol\n    string _symbol;\n\n    // the base uri\n    string __uri;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) _operatorApprovals;\n    \n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) _allTokensIndex;\n}\n\n/// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\nevent Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n);\n\n/// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\nevent ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n);\n\n/**\n * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n */\nevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n"
    },
    "contracts/interfaces/IERC721AAttributesFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./IAttribute.sol\";\n\ninterface IERC721AAttributesFacet {\n    /// @notice Get a list of keys of attributes assigned to this token ID\n    /// @param id The token ID\n    /// @return An array of attribute keys\n    function getAttributeKeys(uint256 id) external view returns (string[] memory);\n\n    /// @notice Get an attribute for a token ID keyed by string\n    /// @param id The token ID\n    /// @param key The key of the attribute\n    /// @return The attribute\n    function getAttribute(uint256 id, string memory key) external view returns (Attribute memory);\n\n    /// @notice Set an attribute value\n    /// @param id The token ID\n    /// @param attrib The attribute to set\n    function setAttribute(uint256 id, Attribute memory attrib) external;\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nstruct ERC721EnumerableContract {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) _allTokensIndex;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC721MetadataFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport { MetadataSource, MetadataContract } from \"./IMetadata.sol\";\n\n/// implemented by erc1155 tokens to allow mminting\ninterface IERC721MetadataFacet {\n\n    /// @notice mint tokens of specified amount to the specified address\n    function setMetadataSource(MetadataSource _source) external;\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    /// @notice mint tokens of specified amount to the specified address\n    function setBaseUri(string memory _baseUri) external;\n\n    function setMetadata(MetadataContract memory _contract) external;\n}\n"
    },
    "contracts/interfaces/IERC721Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// implemented by erc1155 tokens to allow mminting\ninterface IERC721Mint {\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mint(\n        uint256 quantity,\n        bytes calldata data\n    ) external returns (uint256 tokenId);\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mintTo(\n        address receiver,\n        uint256 quantity,\n        bytes calldata data\n    ) external returns (uint256 tokenId);\n\n}\n"
    },
    "contracts/interfaces/IERC721Permissioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC721Permissioned {\n\n    event TransferForced(address indexed from, address indexed to, uint256 indexed tokenId);\n    event DelegatedMinterSet(address indexed newDelegatedMinter);\n    event Mint(address indexed to, uint256 indexed tokenId);\n    event Burn(address indexed from, uint256 indexed tokenId);\n    event Freeze(address indexed from, uint256 indexed tokenId);\n    event FreezeBatch(address indexed from, uint256[] tokenIds);\n    event Release(address indexed from, uint256 indexed tokenId);\n\n    // force a transfer from the user to the to address irrepective of registry\n    // TODO: Does this mean that the transfer will go even if both addresses aren't\n    //      registered? If so, this is a security issue.\n    function forcedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external returns (bool);\n\n    function setDelegatedMinter(address _newDelegatedMinter) external returns (bool);\n    function delegatedMinter() external view returns (address);\n\n    function mint(address _to, bytes calldata data) external returns (uint256);\n    function burn(uint256 _tokenId) external returns (bool);\n\n    function freeze(uint256 tokenID) external;\n    function release(uint256 tokenID) external;\n\n}\n"
    },
    "contracts/interfaces/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\ninterface IERC734 is IERC165 {\n    // events\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(\n        uint256 indexed executionId,\n        address indexed to,\n        uint256 indexed value,\n        bytes data\n    );\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    // functions\n    // setters\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external;\n    function removeKey(bytes32 _key, uint256 _purpose) external;\n    function approve(uint256 _id, bool _approve) external;\n\n    // getters\n    function getKey(bytes32 _key) external view returns(uint256[] memory purposes, uint256 keyType, bytes32 key);\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory);\n    function getKeysByPurpose(uint256 _purpose) external view returns(bytes32[] memory);\n    function getExecution(uint256 _id) external view returns(address to, uint256 value, bytes memory data, bool approved, uint256 executionType);\n}\n"
    },
    "contracts/interfaces/IERC735.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IERC735 {\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    function getClaim(bytes32 _claimId) external returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\n    function getClaimIdsByTopic(uint256 _topic) external returns(bytes32[] memory claimIds);\n    function addClaim(\n        uint256 _topic, \n        uint256 _scheme, \n        address _issuer, \n        bytes memory _signature, \n        bytes memory _data, \n        string memory _uri) external returns (uint256 claimRequestId);\n    function changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (bool success);\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n}\n\n/*\nHow IdentityRegistry works:\n\n1. User creates an Identity contract\n2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData)\n3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity)\n4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim)\n5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID)\n\n*/"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IFeeDistributor\n * @dev Interface for a fee distribution system.\n */\ninterface IFeeDistributor {\n    /**\n     * @notice Sets the addresses that will receive fees and their corresponding weights.\n     * @dev Weights determine the proportion of fees each receiver gets.\n     * @param _feeReceivers Array of addresses to receive fees.\n     * @param _feeWeights Array of weights corresponding to each receiver. Must sum to a specific value (e.g., 10000 for basis points).\n     */\n    function setFeeReceivers(\n        address[] calldata _feeReceivers,\n        uint256[] calldata _feeWeights\n    ) external;\n\n    /**\n     * @notice Gets the current fee receivers and their weights.\n     * @return feeReceivers Array of addresses currently set to receive fees.\n     * @return feeWeights Array of weights corresponding to each receiver.\n     */\n    function getFeeReceivers()\n        external\n        view\n        returns (\n            address[] memory feeReceivers,\n            uint256[] memory feeWeights\n        );\n\n    /**\n     * @notice Calculates the adjusted principal amount and individual fee amounts based on the total principal.\n     * @dev This function is view-only and does not perform any state changes or transfers.\n     * @param principalAmount The total amount before fee deduction.\n     * @return adjustedAmount The principal amount remaining after deducting total fees.\n     * @return feeAmounts Array of individual fee amounts calculated for each receiver.\n     */\n    function calculateAmounts(uint256 principalAmount) \n        external\n        view\n        returns (\n            uint256 adjustedAmount,\n            uint256[] memory feeAmounts\n        );\n\n    /**\n     * @notice Distributes a principal amount, sending calculated fees to receivers and the adjusted amount to the principal receiver.\n     * @dev Requires the contract to hold sufficient funds (e.g., USDC) to perform the transfers.\n     * @param principalAmountReceiver The address to receive the adjusted principal amount.\n     * @param _principalAmount The total amount to be distributed.\n     * @return adjustedAmountReceiver The address that received the adjusted principal amount.\n     * @return adjustedAmount The adjusted principal amount transferred.\n     * @return feeReceivers The addresses that received the fee amounts.\n     * @return feeAmounts The individual fee amounts transferred.\n     */\n    function distributeAmounts(\n        address principalAmountReceiver,\n        uint256 _principalAmount\n    ) external returns (\n        address adjustedAmountReceiver,\n        uint256 adjustedAmount,\n        address[] memory feeReceivers,\n        uint256[] memory feeAmounts\n    );\n\n    /**\n     * @dev Emitted when the fee receivers and weights are updated.\n     * @param feeReceivers The new array of fee receiver addresses.\n     * @param feeWeights The new array of corresponding fee weights.\n     */\n    event FeeReceiversSet(\n        address[] feeReceivers,\n        uint256[] feeWeights\n    );\n\n    /**\n     * @dev Emitted when principal and fee amounts are successfully distributed.\n     * @param principalAmountReceiver The address that received the adjusted principal amount.\n     * @param principalAmount The original principal amount before fee deduction.\n     * @param adjustedAmountReceiver The address that received the adjusted principal amount (same as principalAmountReceiver).\n     * @param adjustedAmount The adjusted principal amount transferred.\n     * @param feeReceivers The addresses that received the fee amounts.\n     * @param feeAmounts The individual fee amounts transferred.\n     */\n    event AmountsDistributed(\n        address principalAmountReceiver,\n        uint256 principalAmount,\n        address adjustedAmountReceiver,\n        uint256 adjustedAmount,\n        address[] feeReceivers,\n        uint256[] feeAmounts\n    );\n\n    /**\n     * @dev Emitted when the Fee Distributor is initialized.\n     * @param distributionToken The address of the ERC20 token set for distribution.\n     * @param totalWeightBasis The basis used for calculating fee weights (e.g., 10000).\n     */\n    event FeeDistributorInitialized(\n        address indexed distributionToken,\n        uint256 totalWeightBasis\n    );\n}"
    },
    "contracts/interfaces/IGemforceMinterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Attribute} from \"../interfaces/IAttribute.sol\";\n\ninterface IGemforceMinterFacet {\n\n    event GemforceMinted(uint256 indexed tokenId, address indexed owner, Attribute [] attributes);\n\n    /// @notice Mint a new token with the provided IAttribute struct metadata\n    /// @return tokenId The ID of the newly minted token\n    function gemforceMint(Attribute[] calldata metadata) external returns (uint256 tokenId);\n}\n"
    },
    "contracts/interfaces/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC734 } from \"./IERC734.sol\";\nimport { IERC735 } from \"./IERC735.sol\";\n\ninterface IIdentity is IERC734, IERC735 {\n    function isVerified() external view returns (bool);\n    function getClaimTopics() external view returns (uint256[] memory);\n}"
    },
    "contracts/interfaces/IIdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport { IIdentity } from \"./IIdentity.sol\";\n\ninterface IIdentityRegistry {\n    // events\n    event IdentityAdded(address trustedIssuer, address indexed _address, IIdentity identity);\n    event IdentityRemoved(address trustedIssuer, address indexed _address, IIdentity identity);\n    event IdentityCountryUpdated(address trustedIssuer, address indexed identity, uint16 indexed country);\n\n    event ClaimAdded(address trustedIssuer, address indexed identity, uint256 indexed claimTopic, bytes claim);\n    event ClaimsSet(address trustedIssuer, address indexed identity, uint256[] claims);\n    event ClaimsRemoved(address trustedIssuer, address indexed identity, uint256[] claimTopics);\n    event ClaimRemoved(address trustedIssuer, address indexed identity, uint256 indexed claimTopic);\n    event WalletLinked(address trustedIssuer, address indexed walletAddress, bytes32 indexed onchainID);\n    event WalletUnlinked(address trustedIssuer, address indexed walletAddress, bytes32 indexed onchainID);\n\n    // functions\n    function addIdentity(address _identity, IIdentity identityData) external;\n    function batchAddIdentity(address[] calldata _identities, IIdentity[] calldata identityDatas) external;\n    function removeIdentity(address _identity) external;\n    function addClaim(address _identity, uint256 _claimTopic, bytes calldata _claim) external;\n    function setClaims(address _identity, uint256[] memory _claims) external;\n    function unsetClaims(address _identity, uint256[] memory _claims) external;\n    function removeClaim(address _identity, uint256 _claimTopic) external;\n\n    // registry consultation\n    function contains(address _userAddress) external view returns (bool);\n    function isVerified(address _userAddress) external view returns (bool);\n    function identity(address _userAddress) external view returns (address);\n\n    // getters\n    function getRegistryUsers() external view returns (address[] memory);\n    function isRegistryUser(address _registryUser) external view returns(bool);\n    function getClaims(address _registryUser) external view returns(uint256[] memory);\n    function getClaim(address _registryUser, uint256 _claimTopic) external view returns(uint256);\n    function hasClaim(address _registryUser, uint256 _claimTopic) external view returns(bool);\n}\n"
    },
    "contracts/interfaces/IInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IInterest {\n    function mint(address to, uint256 amount) external;\n    function burn(address from, uint256 amount) external;\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Structure defining a fee receiver for marketplace sales\n * @param receiver The address that will receive the fee\n * @param sharePerMillion The fee share in parts per million (e.g., 10,000 = 1%)\n */\nstruct FeeReceiver {\n    address payable receiver;\n    uint256 sharePerMillion;\n}\n\nstruct MarketItem {\n    address nftContract;\n    uint256 tokenId;\n    address seller;\n    address owner;\n    uint256 price;\n    bool sold;\n    address receiver;\n    address paymentToken;\n}\n\ninterface IMarketplace {\n\n    event Bids(uint256 indexed itemId, address bidder, uint256 amount);\n    event Sales(address indexed tokenAddress, uint256 indexed tokenId, address indexed owner);\n\n    event Listings(\n        address indexed nftContract,\n        uint256 indexed tokenId,\n        address seller,\n        address receiver,\n        address owner,\n        uint256 price,\n        bool sold,\n        address paymentToken\n    );\n    event Delisted(uint256 indexed itemId);\n\n    function listItem(\n        address nftContract,\n        address payable receiver,\n        uint256 tokenId,\n        uint256 price,\n        bool transferNFT,\n        address paymentToken\n    ) external payable;\n\n    function delistItem(address nftContract, uint256 itemId) external;\n\n    function purchaseItem(address nftContract, uint256 itemId) external payable;\n\n    function fetchItems() external view returns (MarketItem[] memory);\n\n    function fetchItem(address nftContract, uint256 tokenId) external view returns (MarketItem memory);\n\n    function getMarketplaceFeeReceivers() external view returns (FeeReceiver[] memory);\n}\n"
    },
    "contracts/interfaces/IMetadata.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\n/* solhint-disable indent */\n\n// enum metadatasource\nenum MetadataSource {\n    EXTERNAL, INTERNAL\n}\n\nstruct Trait {\n    string displayType;\n    string key;\n    string value;\n}\n\nstruct MetadataContract {\n    string _name;\n    string _symbol;\n    string _description;\n    string _imageName;\n    string[] _imageColors;\n    string _externalUri;\n    MetadataSource _metadataSource;\n    string _baseUri;\n}\n"
    },
    "contracts/interfaces/IMultiPart.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\n/* solhint-disable indent */\n\n\nstruct MultiPartContract {\n    string name_;\n    bytes[] data_;\n}\n"
    },
    "contracts/interfaces/IMultiSale.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { TokenType } from \"./IToken.sol\";\nimport { VariablePriceContract } from \"./IVariablePrice.sol\";\nimport { Attribute } from \"./IAttribute.sol\";\n\n/// @Nnotice the payment type for the token\nenum PaymentType {\n    Ether,\n    ERC20\n}\n\n/// @notice the multisale purchase\nstruct MultiSalePurchase {\n    uint256 multiSaleId;\n    address purchaser;\n    address receiver;\n    uint256 quantity;\n}\n    \n/// @notice the merkle proof for the token sale\nstruct MultiSaleProof {\n    uint256 leaf;\n    uint256 total;\n    bytes32[] merkleProof;\n    bytes data;\n}\n\nenum PaymentMethod {\n    Native, // Payment with the native currency (e.g., ETH)\n    ERC20 // Payment with an ERC20 token\n}\n\n/// @notice the settings for the token sale,\nstruct MultiSaleSettings {\n\n    TokenType tokenType; // the type of token being sold\n    address token; // the token being sold\n    uint256 tokenHash; // the token hash being sold. set to 0 to autocreate hash\n\n    uint256 whitelistHash; // the whitelist hash. set to 0 for owhitelist\n    bool whitelistOnly; // if true, only whitelisted addresses can purchase\n\n    PaymentMethod paymentMethod; // New field to indicate payment method\n    address paymentToken; // New field to store the ERC20 token address for payments\n\n    // owner and payee\n    address owner; // the owner of the contract\n    address payee; // the payee of the co ntract\n\n    string symbol; // the symbol of the token\n    string name; // the name of the token\n    string description; // the description of the token\n\n    // open state\n    bool openState; // open or closed\n    uint256 startTime; // block number when the sale starts\n    uint256 endTime; // block number when the sale ends\n\n    // quantitiesp\n    uint256 maxQuantity; // max number of tokens that can be sold\n    uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\n    uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\n    uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\n\n    PaymentType paymentType; // the type of payment that is being used\n    address tokenAddress; // the address of the payment token, if payment type is TOKEN\n\n    uint256 nextSaleId; // the next sale id\n    VariablePriceContract price; // the variable prices\n\n}\n\n/// @notice the multi sale contract\nstruct MultiSaleContract {\n    MultiSaleSettings settings;\n\n    uint256 nonce;\n    uint256 totalPurchased;\n        \n    mapping(address => uint256) purchased;\n    mapping(uint256 => uint256) _redeemedData;\n    mapping(address => uint256) _redeemedDataQuantities;\n    mapping(address => uint256) _totalDataQuantities;\n    mapping(address => uint256) _accountQuantities;\n}\n\n/// @notice the multi sale storage\nstruct MultiSaleStorage {\n    // the nonce\n    uint256 tsnonce;\n    mapping(uint256 => MultiSaleContract) _tokenSales; // token sale settings\n    uint256[] _tokenSaleIds;\n}\n\n\ninterface IMultiSale {\n\n    // @notice emitted when a token sale is created\n    event MultiSaleCreated(uint256 indexed tokenSaleId, MultiSaleSettings settings);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleOpen (uint256 indexed tokenSaleId, MultiSaleSettings tokenSale);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleClosed (uint256 indexed tokenSaleId);\n\n    /// @notice emitted when a token is opened\n    event MultiSaleSold (uint256 indexed tokenSaleId, address indexed purchaser, uint256[] tokenIds, bytes data);\n\n    // token settings were updated\n    event MultiSaleUpdated (uint256 indexed tokenSaleId, MultiSaleSettings tokenSale );\n\n}\n"
    },
    "contracts/interfaces/IStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nstruct Replacement {\n    string matchString;\n    string replaceString;\n}\n"
    },
    "contracts/interfaces/ISVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../interfaces/IStrings.sol\";\n\nstruct SVGTemplatesContract {\n    mapping(string => address) _templates;\n    string[] _templateNames;\n}\n\ninterface ISVG {\n    function getSVG() external view returns (string memory);\n}\n\ninterface ISVGTemplate {\n    function createSVG(address sender, string memory _name) external returns (address _tplAddress);\n    function svgs() external view returns (string[] memory);\n    function svgName() external view returns (string memory _name);\n    function svgString(string memory name) external view returns (string memory _data);\n    function svgAddress(string memory name) external view returns (address _data);\n    function svgBytes() external view returns (bytes[] memory _data);\n    function clear() external;\n    function add(string memory _data) external returns (uint256 _index);\n    function addAll(string[] memory _data) external returns (uint256 _count);\n    function buildSVG(Replacement[] memory replacements) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice the definition for a token.\r\nstruct TokenDefinition {\r\n    address token;\r\n    string name;\r\n    string symbol;\r\n    string description;\r\n    uint256 totalSupply;\r\n    string imageName;\r\n    string[] imagePalette;\r\n    string externalUrl;\r\n}\r\n\r\nenum TokenType {\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}"
    },
    "contracts/interfaces/ITradeDeal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/TradeDealLib.sol\"; // Added import\n/**\n * @title ITradeDeal\n * @dev Interface for the TradeDeal system, defining events and external functions.\n */\ninterface ITradeDeal {\n    /**\n     * @dev Emitted when a new trade deal is created\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param name Human-readable name of the trade deal\n     * @param symbol Symbol for the trade deal's Collateral token\n     * @param interestRate Interest rate in basis points (100 = 1%)\n     * @param collateralToInterestRatio Conversion ratio for Collateral to Interest tokens\n     * @param active Whether the trade deal is active upon creation\n     * @param nftAddress Address of the NFT contract for invoices\n     * @param collateralAddress Address of the Collateral token contract\n     * @param interestAddress Address of the Interest token contract\n     * @param usdcAddress Address of the USDC token contract\n     */\n    event TradeDealCreated(\n        uint256 indexed tradeDealId,\n        string name,\n        string symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        bool active,\n        address nftAddress,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress,\n        TradeDealLib.OperationMode operationMode // Added operationMode\n    );\n/**\n * @dev Emitted when a trade deal's core details are updated\n * @param tradeDealId Unique identifier for the trade deal\n * @param name Updated human-readable name\n * @param symbol Updated symbol for the Collateral token\n * @param interestRate Updated interest rate in basis points\n * @param collateralToInterestRatio Updated conversion ratio\n * @param active Updated active status\n * @param collateralAddress Updated Collateral token address\n * @param interestAddress Updated Interest token address\n * @param usdcAddress Updated USDC token address\n */\nevent TradeDealUpdated(\n    uint256 indexed tradeDealId,\n    string name,\n    string symbol,\n    uint256 interestRate,\n    uint256 collateralToInterestRatio,\n    bool active,\n    address collateralAddress,\n    address interestAddress,\n    address usdcAddress\n);\n\n// Removed duplicate TradeDealUpdated event definition (Comment kept for history, event re-added)\n\n\n    /**\n     * @dev Emitted when a trade deal is activated\n     * @param tradeDealId Unique identifier for the trade deal being activated\n     */\n    event TradeDealActivated(uint256 indexed tradeDealId);\n\n    /**\n     * @dev Emitted when a trade deal is deactivated\n     * @param tradeDealId Unique identifier for the trade deal being deactivated\n     */\n    event TradeDealDeactivated(uint256 indexed tradeDealId);\n\n    /**\n     * @dev Emitted when a participant is added to a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param participant Address of the participant being added\n     */\n    event TradeDealParticipantAdded(uint256 indexed tradeDealId, address indexed participant);\n\n    /**\n     * @dev Emitted when a participant is removed from a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param participant Address of the participant being removed\n     */\n    event TradeDealParticipantRemoved(uint256 indexed tradeDealId, address indexed participant);\n\n    event TradeDealFeesDistributed(\n        uint256 indexed tradeDealId,\n        address[] feeReceivers,\n        uint256[] feeAmounts\n    );\n\n    /**\n     * @dev Emitted when an invoice is deposited to a trade deal as collateral\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param tokenId NFT token ID of the invoice being deposited\n     */\n    event InvoiceDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when an invoice is withdrawn from a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param tokenId NFT token ID of the invoice being withdrawn\n     */\n    event InvoiceWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when USDC is deposited to a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param amount Amount of USDC being deposited\n     * @param depositor Address of the depositor\n     */\n    event USDCDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 amount, address depositor);\n\n    /**\n     * @dev Emitted when USDC is withdrawn from a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param amount Amount of USDC being withdrawn\n     */\n    event USDCWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 amount);\n\n    /**\n     * @dev Emitted when interest is distributed for a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param totalInterest Total interest calculated for distribution\n     * @param invoicePoolInterest Amount of interest distributed to invoice pool\n     * @param interestInterest Amount of interest distributed as Interest tokens\n     * @param interestTokensMinted Number of Interest tokens minted for interest\n     */\n    event InterestDistributedForTradeDeal(uint256 indexed tradeDealId, uint256 totalInterest, uint256 invoicePoolInterest, uint256 interestInterest, uint256 interestTokensMinted);\n\n    /**\n     * @dev Emitted when required claim topics are set for a trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param claimTopics Array of claim topic IDs required for participation\n     */\n    event TradeDealRequiredClaimTopicsSet(uint256 indexed tradeDealId, uint256[] claimTopics);\n\n    /**\n     * @dev Emitted when a trade deal reaches its funding target and becomes fully funded\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param fundingTarget The total amount of USDC required to fully fund the deal\n     */\n    event TradeDealFullyFunded(uint256 indexed tradeDealId, uint256 fundingTarget);\n\n    /**\n     * @dev Emitted when funding is withdrawn from a fully funded trade deal\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param recipient Address receiving the withdrawn funds\n     * @param amount Amount of USDC being withdrawn\n     */\n    event TradeDealFundingWithdrawn(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\n\n    /**\n     * @dev Emitted when a trade deal is repaid\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param repayer Address making the repayment\n     * @param amount Amount of USDC being repaid\n     * @param fullyRepaid Boolean indicating if the trade deal is now fully repaid\n     */\n    event TradeDealRepaid(uint256 indexed tradeDealId, address indexed repayer, uint256 amount, bool fullyRepaid);\n\n    /**\n     * @dev Emitted when Collateral tokens are redeemed for USDC\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param redeemer Address redeeming the Collateral tokens\n     * @param collateralAmount Amount of Collateral tokens being redeemed\n     * @param usdcAmount Amount of USDC received in exchange\n     */\n    event CollateralTokensRedeemed(uint256 indexed tradeDealId, address indexed redeemer, uint256 collateralAmount, uint256 usdcAmount);\n\n    /**\n     * @dev Emitted when Collateral tokens are distributed (minted) to a participant upon USDC deposit\n     * @param tradeDealId Unique identifier for the trade deal\n     * @param recipient Address receiving the Collateral tokens\n     * @param amount Amount of Collateral tokens distributed\n     */\n    event CollateralTokensDistributed(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\n\n\n    function createTradeDeal(\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        uint256[] memory requiredClaimTopics,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress,\n        TradeDealLib.OperationMode operationMode // Added operationMode\n    ) external returns (uint256);\n\n    function updateTradeDeal( // Corrected typo from updateTradeDeall\n        uint256 tradeDealId,\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) external;\n\n    function activateTradeDeal(uint256 tradeDealId) external;\n\n    function deactivateTradeDeal(uint256 tradeDealId) external;\n\n    function getTradeDealInfo(uint256 tradeDealId) external view returns (\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        bool active,\n        TradeDealLib.OperationMode operationMode // Added operationMode\n    );\n\n    function getAllTradeDealIds() external view returns (uint256[] memory);\n\n    function isTradeDealParticipant(uint256 tradeDealId, address user) external view returns (bool);\n\n    function tdDepositInvoice(uint256 tradeDealId, uint256 tokenId) external;\n\n    function tdWithdrawInvoice(uint256 tradeDealId, uint256 tokenId) external;\n\n    function tdDepositUSDC(uint256 tradeDealId, uint256 amount) external;\n\n    function tdWithdrawUSDC(uint256 tradeDealId, uint256 amount) external;\n\n    function tdDistributeInterest(uint256 tradeDealId) external;\n\n    function setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) external;\n\n    function getTradeDealRequiredClaimTopics(uint256 tradeDealId) external view returns (uint256[] memory);\n\n    function setTradeDealTokenAddresses(\n        uint256 tradeDealId,\n        address nftAddress, // Kept for signature compatibility\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) external;\n\n    function getTradeDealTokenAddresses(uint256 tradeDealId) external view returns (\n        address nftAddress,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    );\n\n    function setTradeDealNFTAddress(uint256 tradeDealId, address nftAddress) external; // Kept for signature compatibility\n\n    function isTradeDealFunded(uint256 tradeDealId) external view returns (bool);\n\n    function isTradeDealRepaid(uint256 tradeDealId) external view returns (bool);\n\n    function withdrawTradeDealFundingForBorrower(uint256 tradeDealId, address borrowerAddress) external; // Added borrowerAddress\n\n    function repayTradeDeal(uint256 tradeDealId, uint256 amount) external;\n\n    function repayTradeDealForBorrower(uint256 tradeDealId, address borrower, uint256 amount) external;\n\n    function redeemCollateralTokens(uint256 tradeDealId, uint256 collateralAmount) external;\n\n    function getTradeDealFullStatus(uint256 tradeDealId) external view returns (\n        uint256 fundingTarget,\n        uint256 currentBalance,\n        bool isFunded,\n        bool isFundingWithdrawn,\n        uint256 totalDebt,\n        uint256 repaidAmount,\n        bool isRepaid\n    );\n}"
    },
    "contracts/interfaces/ITrustedIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"./IClaimIssuer.sol\";\n\nstruct TrustedIssuer {\n    address claimIssuer;\n    uint[] claimTopics;\n}\n\ninterface ITrustedIssuersRegistry {\n\n    // events\n    event TrustedIssuerAdded(address indexed trustedIssuer, uint[] claimTopics);\n    event TrustedIssuerRemoved(address indexed trustedIssuer);\n    event ClaimTopicsUpdated(address indexed trustedIssuer, uint[] claimTopics);\n\n    // functions\n    // setters\n    function addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external;\n    function removeTrustedIssuer(address _trustedIssuer) external;\n    function updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external;\n\n    // getters\n    function getTrustedIssuer(address issuerAddress) external view returns (TrustedIssuer memory);\n    function getTrustedIssuers() external view returns (TrustedIssuer[] memory);\n    function isTrustedIssuer(address _issuer) external view returns(bool);\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory);\n    function hasTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);\n\n}"
    },
    "contracts/interfaces/IUSDCPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUSDCPool {\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getBalance() external view returns (uint256);\n    function distributeInterest() external;\n}"
    },
    "contracts/interfaces/IVariablePrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\n/// @notice DIctates how the price of the token is increased post every sale\nenum PriceModifier {\n    None,\n    Fixed,\n    Exponential,\n    InverseLog\n}\n\nstruct VariablePriceContract {\n    // the price of the token\n    uint256 price;\n        // how the price is modified\n    PriceModifier priceModifier;\n    // only used if priceModifier is EXPONENTIAL or INVERSELOG or FIXED\n    uint256 priceModifierFactor;\n    // max price for the token\n    uint256 maxPrice;\n}\n\nstruct VariablePriceStorage {\n    // the price of the token\n    VariablePriceContract variablePrices;\n}\n\n/// @notice common struct definitions for tokens\ninterface IVariablePrice {\n    /// @notice get the increased price of the token\n    function getIncreasedPrice() external view returns (uint256);\n\n    /// @notice get the increased price of the token\n    function getTokenPrice() external view returns (VariablePriceContract memory);\n}\n"
    },
    "contracts/libraries/AttributeLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../interfaces/IAttribute.sol\";\n\nstruct AttributeStorage {\n    AttributeContract attributes;\n}\n\nlibrary AttributeLib {\n    event AttributeSet(address indexed tokenAddress, uint256 tokenId, Attribute attribute);\n    event AttributeRemoved(address indexed tokenAddress, uint256 tokenId, string attributeKey);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.AttributeStorage.storage\");\n\n    function attributeStorage() internal pure returns (AttributeStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice set an attribute for a tokenid keyed by string\n    function _getAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal view returns (Attribute memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributes[tokenId][key];\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeValues(\n        uint256 id\n    ) internal view returns (string[] memory) {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        string[] memory keys = ct.attributeKeys[id];\n        string[] memory values = new string[](keys.length);\n        uint256 keysLength = keys.length;\n        for (uint256 i = 0; i < keysLength; i++) {\n            values[i] = ct.attributes[id][keys[i]].value;\n        }\n        return values;\n    }\n    \n    /// @notice set an attribute to a tokenid keyed by string\n    function _setAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        Attribute memory attribute\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        if (self.attributeKeysIndexes[tokenId][attribute.key] == 0 \n            && bytes(self.attributes[tokenId][attribute.key].value).length == 0) {\n            self.attributeKeys[tokenId].push(attribute.key);\n            self.attributeKeysIndexes[tokenId][attribute.key] = self.attributeKeys[tokenId].length - 1;\n        }\n        self.attributes[tokenId][attribute.key] = attribute;\n    }\n    \n    /// @notice set multiple  attributes for the token\n    function _setAttributes(\n        AttributeContract storage self,\n        uint256 tokenId, \n        Attribute[] memory _attributes)\n        internal\n    {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        uint256 attributesLength = _attributes.length;\n        for (uint256 i = 0; i < attributesLength; i++) {\n            _setAttribute(self, tokenId, _attributes[i]);\n        }\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeKeys(\n        AttributeContract storage self,\n        uint256 tokenId\n    ) internal view returns (string[] memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributeKeys[tokenId];\n    }\n\n    /// @notice remove the attribute for a tokenid keyed by string\n    function _removeAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        delete self.attributes[tokenId][key];\n        uint256 ndx = self.attributeKeysIndexes[tokenId][key];\n        for (uint256 i = ndx; i < self.attributeKeys[tokenId].length - 1; i++) {\n            self.attributeKeys[tokenId][i] = self.attributeKeys[tokenId][i + 1];\n            self.attributeKeysIndexes[tokenId][self.attributeKeys[tokenId][i]] = i;\n        }\n        delete self.attributeKeys[tokenId][self.attributeKeys[tokenId].length - 1];\n        emit AttributeRemoved(address(this), tokenId, key);\n    }\n\n    // @notice set multiple attributes for the token\n    function _burn(\n        AttributeContract storage self,\n        uint256 tokenId)\n        internal\n    {\n        self.burnedIds[tokenId] = true;\n    }\n}\n"
    },
    "contracts/libraries/CarbonCreditLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum CarbonCreditStatus {\n    ACTIVE,\n    RETIRED\n}\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nlibrary CarbonCreditLib {\n    struct CarbonCreditStorage {\n        mapping(uint256 => uint256) tokenBalances;\n    }\n\n    bytes32 constant CARBON_CREDIT_STORAGE_POSITION = keccak256(\"diamond.standard.carbon.credit.storage\");\n\n    function carbonCreditStorage() internal pure returns (CarbonCreditStorage storage cs) {\n        bytes32 position = CARBON_CREDIT_STORAGE_POSITION;\n        assembly {\n            cs.slot := position\n        }\n    }\n\n    /**\n     * @notice Check if a token exists by verifying it has an owner\n     * @param tokenId The ID of the token to check\n     * @return true if the token exists, false otherwise\n     */\n    function _tokenExists(uint256 tokenId) internal view returns (bool) {\n        try IERC721(address(this)).ownerOf(tokenId) returns (address owner) {\n            return owner != address(0);\n        } catch {\n            return false;\n        }\n    }\n\n    function initializeBalance(CarbonCreditStorage storage self, uint256 tokenId, uint256 initialBalance) internal {\n        require(self.tokenBalances[tokenId] == 0, \"Carbon credits already initialized\");\n        require(_tokenExists(tokenId), \"Token does not exist\");\n        require(initialBalance > 0, \"Initial balance must be greater than zero\");\n        self.tokenBalances[tokenId] = initialBalance;\n    }\n\n    function retireCredits(CarbonCreditStorage storage self, uint256 tokenId, uint256 amount) internal {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(self.tokenBalances[tokenId] >= amount, \"Insufficient balance\");\n        self.tokenBalances[tokenId] -= amount;\n    }\n\n    function getBalance(CarbonCreditStorage storage self, uint256 tokenId) internal view returns (uint256) {\n        return self.tokenBalances[tokenId];\n    }\n\n    function getCarbonCreditStatus(CarbonCreditStorage storage self, uint256 tokenId) internal view returns (CarbonCreditStatus) {\n        return self.tokenBalances[tokenId] == 0 ? CarbonCreditStatus.RETIRED : CarbonCreditStatus.ACTIVE;\n    }\n}"
    },
    "contracts/libraries/DiamondFactoryLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { TokenDefinition } from \"../interfaces/IToken.sol\";\n\nimport \"../interfaces/IDiamondFactory.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\ninterface IDiamondElement {\n  function initialize(\n    address, \n    DiamondSettings memory,\n    IDiamondCut.FacetCut[] calldata,\n    address,\n    bytes calldata) external payable;\n}\n\nlibrary DiamondFactoryLib {\n\n  struct ContractData {\n    mapping(string => address) diamondAddresses;\n    string[] diamondSymbols;\n    mapping(string => IDiamondCut.FacetCut[]) facetsToAdd;\n    string[] facetSets;\n    string defaultFacetSet;\n    bytes diamondBytecode;\n  }\n\n  struct DiamondFactoryStorage {\n    ContractData contractData;\n  }\n\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\n    keccak256(\"diamond.nextblock.bitgem.app.DiamondFactoryStorage.storage\");\n\n  /// @notice get the storage for the diamond factory\n  /// @return ds DiamondFactoryStorage the storage for the diamond factory\n  function diamondFactoryStorage() internal pure returns (DiamondFactoryStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  /// @notice add a set of facets to the factory and associate with a string name\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @param facets the facets to add\n  function _addFacetSet(DiamondFactoryStorage storage self, string memory setName, IDiamondCut.FacetCut[] memory facets) internal {\n    // add the facets to the diamond\n    uint256 facetsLength = facets.length;\n    for (uint256 i = 0; i < facetsLength; i++) {\n      self.contractData.facetsToAdd[setName].push(facets[i]);\n    }\n    // add the facet set name to the list of facet sets\n    bool found = false;\n    uint256 facetSetsLength = self.contractData.facetSets.length;\n    for (uint256 i = 0; i < facetSetsLength; i++) {\n      if (keccak256(bytes(self.contractData.facetSets[i])) == keccak256(bytes(setName))) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      self.contractData.facetSets.push(setName);\n    }\n  }\n\n  /// @notice get all the facets for a particular set name\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @return IDiamondCut.FacetCut[] the facets for the set name\n  function _getFacets(DiamondFactoryStorage storage self, string memory setName) internal view returns (IDiamondCut.FacetCut[] memory) {\n    return self.contractData.facetsToAdd[setName];\n  }\n\n  /// @notice set a facet for facet set name at a particular index\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @param idx the index of the facet to set\n  /// @param facet the facet to set\n  function _setFacet(DiamondFactoryStorage storage self, string memory setName, uint256 idx, IDiamondCut.FacetCut memory facet) internal {\n    self.contractData.facetsToAdd[setName][idx] = facet;\n    // add the facet set name to the list of facet sets\n    bool found = false;\n    uint256 facetSetsLength = self.contractData.facetSets.length;\n    for (uint256 i = 0; i < facetSetsLength; i++) {\n      if (keccak256(bytes(self.contractData.facetSets[i])) == keccak256(bytes(setName))) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      self.contractData.facetSets.push(setName);\n    }  \n  }\n\n  /// @notice get an address for the given diamond\n  /// @param factoryAddress the diamond factory\n  /// @param symbol the symbol of the  diamond\n  /// @param creationCode the creation code for the diamond\n  function _getDiamondAddress(DiamondFactoryStorage storage, address factoryAddress, string memory symbol, bytes memory creationCode)\n    internal\n    view\n    returns (address) {\n    return Create2.computeAddress(\n      keccak256(abi.encodePacked(factoryAddress, symbol)),\n      keccak256(creationCode)\n    );\n  }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param self the storage for the diamond factory\n    /// @param diamondAddress the diamond address\n    /// @param diamondInit the diamond init data\n    /// @param _calldata  the calldata for the diamond\n    /// @param _creationCode the creation code for the diamond\n    function create(\n        DiamondFactoryStorage storage self,\n        address diamondAddress,\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        bytes memory _creationCode,\n        IDiamondCut.FacetCut[] memory facets\n    ) internal returns (address payable _diamondAddress) {\n        // use create2 to create the token\n        _diamondAddress = payable(\n            Create2.deploy(\n                0,\n                keccak256(abi.encodePacked(diamondAddress, params.symbol)),\n                _creationCode\n            )\n        );\n        require(_diamondAddress != address(0), \"create_failed\");\n        \n        // update storage with the new data\n        self.contractData.diamondAddresses[params.symbol] = _diamondAddress;\n        self.contractData.diamondSymbols.push(params.symbol);\n\n        // initialize the diamond contract\n        IDiamondElement(_diamondAddress).initialize(\n            msg.sender,\n            params,\n            facets,\n            diamondInit,\n            _calldata\n        );\n    }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param self the storage for the diamond factory\n    /// @param diamondAddress the diamond address\n    /// @param diamondInit the diamond init data\n    /// @param _calldata  the calldata for the diamond\n    /// @param _creationCode the creation code for the diamond\n    function createFromSet(\n        DiamondFactoryStorage storage self,\n        address diamondAddress,\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        bytes memory _creationCode,\n        string memory facetSet\n    ) internal returns (address payable _diamondAddress) {\n        // use create2 to create the token\n        _diamondAddress = payable(\n            Create2.deploy(\n                0,\n                keccak256(abi.encodePacked(diamondAddress, params.symbol)),\n                _creationCode\n            )\n        );\n        require(_diamondAddress != address(0), \"create_failed\");\n        \n        // update storage with the new data\n        self.contractData.diamondAddresses[params.symbol] = _diamondAddress;\n        self.contractData.diamondSymbols.push(params.symbol);\n\n        // initialize the diamond contract\n        IDiamondElement(_diamondAddress).initialize(\n            msg.sender,\n            params,\n            self.contractData.facetsToAdd[facetSet],\n            diamondInit,\n            _calldata\n        );\n    }\n\n    /// @notice add an existing diamond to this factory\n    /// @param self the storage for the diamond factory\n    /// @param symbol the symbol of the diamond\n    /// @param diamondAddress the address of the diamond\n    function add(\n        DiamondFactoryStorage storage self,\n        string memory symbol,\n        address payable diamondAddress\n    ) internal {\n        // update storage with the new data\n        self.contractData.diamondAddresses[symbol] = diamondAddress;\n        self.contractData.diamondSymbols.push(symbol);\n    }\n\n    /// @notice remove a diamond from this factory\n    /// @param self the storage for the diamond factory\n    /// @param symbol the symbol of the diamond\n    function remove(\n      DiamondFactoryStorage storage self,\n      string memory symbol\n    ) internal {\n        self.contractData.diamondAddresses[symbol] = address(0);\n        for(uint256 i = 0; i < self.contractData.diamondSymbols.length; i++) {\n            if ( keccak256(bytes(self.contractData.diamondSymbols[i] ) ) == keccak256(bytes(symbol)) ) {\n                self.contractData.diamondSymbols[i] = self.contractData.diamondSymbols[self.contractData.diamondSymbols.length - 1];\n                self.contractData.diamondSymbols.pop();\n                break;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/DiamondLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { DiamondStorage } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { TokenDefinition } from \"../interfaces/IToken.sol\";\n\nimport \"./LibDiamond.sol\";\nimport \"./ERC721ALib.sol\";\n\nimport \"../upgradeInitializers/DiamondInit.sol\";\n\nlibrary DiamondLib {\n\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\n    keccak256(\"diamond.nextblock.bitgem.app.DiamondStorage.storage\");\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n}\n"
    },
    "contracts/libraries/ERC721AEnumerationLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../interfaces/IERC721Enumerable.sol\";\n\n\nlibrary ERC721AEnumerationLib {\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(ERC721EnumerableContract storage self, address owner, uint256 index) internal view returns (uint256) {\n        require(index < IERC721(address(this)).balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return self._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply(ERC721EnumerableContract storage self) internal view returns (uint256) {\n        return self._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(ERC721EnumerableContract storage self, uint256 index) internal view returns (uint256) {\n        require(index < totalSupply(self), \"ERC721Enumerable: global index out of bounds\");\n        return self._allTokens[index];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(ERC721EnumerableContract storage self, address to, uint256 tokenId) internal {\n        uint256 length = IERC721(address(this)).balanceOf(to);\n        self._ownedTokens[to][length] = tokenId;\n        self._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(ERC721EnumerableContract storage self, uint256 tokenId) internal {\n        self._allTokensIndex[tokenId] = self._allTokens.length;\n        self._allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(ERC721EnumerableContract storage self, address from, uint256 tokenId) internal {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = IERC721(address(this)).balanceOf(from) - 1;\n        uint256 tokenIndex = self._ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = self._ownedTokens[from][lastTokenIndex];\n\n            self._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            self._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete self._ownedTokensIndex[tokenId];\n        delete self._ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(ERC721EnumerableContract storage self, uint256 tokenId) internal {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = self._allTokens.length - 1;\n        uint256 tokenIndex = self._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = self._allTokens[lastTokenIndex];\n\n        self._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        self._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete self._allTokensIndex[tokenId];\n        self._allTokens.pop();\n    }\n\n}"
    },
    "contracts/libraries/ERC721ALib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Creator: Chiru Labs\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"../interfaces/IERC721A.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\n\n\n/* solhint-disable indent */\n/* solhint-disable mark-callable-contracts */\n\nerror ApprovalCallerNotOwnerNorApproved();\nerror ApprovalQueryForNonexistentToken();\nerror ApproveToCaller();\nerror ApprovalToCurrentOwner();\nerror BalanceQueryForZeroAddress();\nerror MintedQueryForZeroAddress();\nerror BurnedQueryForZeroAddress();\nerror AuxQueryForZeroAddress();\nerror MintToZeroAddress();\nerror MintZeroQuantity();\nerror OwnerIndexOutOfBounds();\nerror OwnerQueryForNonexistentToken();\nerror TokenIndexOutOfBounds();\nerror TransferCallerNotOwnerNorApproved();\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721ReceiverImplementer();\nerror TransferToZeroAddress();\nerror URIQueryForNonexistentToken();\n\nstruct ERC721AStorage {\n    ERC721EnumerableContract enumerations;\n    ERC721AContract erc721Contract;\n}\n\nlibrary ERC721ALib {\n\n    using Strings for uint256;\n    using Address for address;\n\n    /**\n     * Returns the total number of minted tokens\n     */\n    function totalSupply(ERC721AContract storage self) internal view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex times\n        unchecked {\n            return self._currentIndex - self._burnCounter;\n        }\n    }\n    \n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(self._addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\n        return uint256(self._addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\n        return uint256(self._addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(ERC721AContract storage self, address owner) internal view returns (uint64) {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        return self._addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(ERC721AContract storage self, address owner, uint64 aux) internal {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        self._addressData[owner].aux = aux;\n    }\n\n    function ownershipOf(ERC721AContract storage self, uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n        unchecked {\n            if (curr < self._currentIndex) {\n                TokenOwnership memory ownership = self._ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = self._ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(ERC721AContract storage self, uint256 tokenId) internal view returns (bool) {\n        return tokenId < self._currentIndex && !self._ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(ERC721AContract storage self, uint256 tokenId) internal view returns (address) {\n        if (!_exists(self, tokenId)) revert ApprovalQueryForNonexistentToken();\n        return self._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(ERC721AContract storage self, address sender, address operator, bool approved) internal {\n        self._operatorApprovals[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(ERC721AContract storage self, address owner, address operator) internal view returns (bool) {\n        return self._operatorApprovals[owner][operator];\n    }\n\n    function currentIndex(ERC721AContract storage self) internal view returns (uint256) {\n        return self._currentIndex;\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        ERC721AContract storage self,\n        address msgSender,\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        uint256 startTokenId = self._currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(self, address(0), to, startTokenId, quantity, false);\n\n        unchecked {\n            self._addressData[to].balance += uint64(quantity);\n            self._addressData[to].numberMinted += uint64(quantity);\n\n            self._ownerships[startTokenId].addr = to;\n            self._ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (safe && !_checkOnERC721Received(msgSender, address(0), to, updatedIndex, _data)) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                }\n                updatedIndex++;\n            }\n\n            self._currentIndex = updatedIndex;\n        }\n\n        _afterTokenTransfers(self, address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        ERC721AContract storage self,\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bool _force\n    ) internal {\n        TokenOwnership memory prevOwnership = ownershipOf(self, tokenId);\n\n        bool isApprovedOrOwner = (msgSender == prevOwnership.addr ||\n            isApprovedForAll(self, prevOwnership.addr, msgSender) ||\n            getApproved(self, tokenId) == msgSender);\n\n        if (!isApprovedOrOwner && !_force) revert TransferCallerNotOwnerNorApproved();\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(self, from, to, tokenId, 1, _force);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self._addressData[from].balance -= 1;\n            self._addressData[to].balance += 1;\n\n            self._ownerships[tokenId].addr = to;\n            self._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self._currentIndex) {\n                    self._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self._ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(self, from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(ERC721AContract storage self, uint256 tokenId) internal {\n        TokenOwnership memory prevOwnership = ownershipOf(self, tokenId);\n\n        _beforeTokenTransfers(self, prevOwnership.addr, address(0), tokenId, 1, false);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self._addressData[prevOwnership.addr].balance -= 1;\n            self._addressData[prevOwnership.addr].numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            self._ownerships[tokenId].addr = prevOwnership.addr;\n            self._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n            self._ownerships[tokenId].burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self._currentIndex) {\n                    self._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self._ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\n        _afterTokenTransfers(self, prevOwnership.addr, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self._burnCounter++;\n        }\n    }\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        ERC721AContract storage self,\n        address to,\n        uint256 tokenId,\n        address owner\n    ) internal {\n        self._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function _ownerOf(ERC721AContract storage self, uint256 tokenId) internal view returns (address) {\n        return ownershipOf(self, tokenId).addr;\n    }\n\n    function _isContract(\n        address account\n    ) internal view returns (bool) {\n        // According to EIP-1052, an address is a contract if it has code.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (_isContract(to)) {\n            try IERC721Receiver(to).onERC721Received(msgSender, from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        ERC721AContract storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity,\n        bool force\n    ) internal {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        ERC721AContract storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal {}\n}\n"
    },
    "contracts/libraries/FeeDistributorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary FeeDistributorLib {\n    using SafeERC20 for IERC20;\n\n    // Storage struct for Fee Distributor settings\n    struct FeeDistributorStorage {\n        address[] feeReceivers;\n        uint256[] feeWeights;\n        uint256 totalWeightBasis; // e.g., 10000 for basis points\n        address distributionToken; // Address of the ERC20 token to distribute (e.g., USDC)\n    }\n// --- Logic Functions (Implementations TBD) ---\n    // --- Logic Functions (Implementations TBD) ---\n\n    /**\n     * @notice Initializes the Fee Distributor settings. Should only be called once.\n     * @param ds Diamond storage pointer.\n     * @param _distributionToken Address of the ERC20 token to be distributed.\n     * @param _totalWeightBasis The basis for fee weights (e.g., 10000 for basis points).\n     */\n    function _initializeFeeDistributor(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address _distributionToken,\n        uint256 _totalWeightBasis\n    ) internal {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        require(fds.distributionToken == address(0), \"FeeDistributor: Already initialized\");\n        // Allow address(0) for native currency distribution\n        require(_totalWeightBasis > 0, \"FeeDistributor: Basis must be positive\");\n\n        fds.distributionToken = _distributionToken;\n        fds.totalWeightBasis = _totalWeightBasis;\n    }\n\n    /**\n     * @notice Sets the fee receivers and their weights.\n     * @param ds Diamond storage pointer.\n     * @param _feeReceivers Array of addresses to receive fees.\n     * @param _feeWeights Array of weights corresponding to each receiver.\n     */\n    function _setFeeReceivers(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address[] memory _feeReceivers,\n        uint256[] memory _feeWeights\n    ) internal returns (address[] memory, uint256[] memory) {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        require(_feeReceivers.length == _feeWeights.length, \"FeeDistributor: Array lengths mismatch\");\n        require(_feeReceivers.length > 0, \"FeeDistributor: Must provide at least one receiver\");\n\n        uint256 totalWeightSum = 0;\n        for (uint i = 0; i < _feeReceivers.length; i++) {\n            require(_feeReceivers[i] != address(0), \"FeeDistributor: Invalid receiver address\");\n            require(_feeWeights[i] > 0, \"FeeDistributor: Weight must be positive\");\n            totalWeightSum += _feeWeights[i];\n        }\n        require(totalWeightSum == fds.totalWeightBasis, \"FeeDistributor: Weights must sum to basis\");\n\n        fds.feeReceivers = _feeReceivers;\n        fds.feeWeights = _feeWeights;\n\n        return (_feeReceivers, _feeWeights); // Return for event emission in facet\n    }\n\n    /**\n     * @notice Gets the current fee receivers and their weights.\n     * @param ds Diamond storage pointer.\n     * @return feeReceivers_ Array of addresses currently set to receive fees.\n     * @return feeWeights_ Array of weights corresponding to each receiver.\n     */\n    function _getFeeReceivers(\n        IdentitySystemStorage.IdentitySystem storage ds\n    )\n        internal\n        view\n        returns (\n            address[] memory feeReceivers_,\n            uint256[] memory feeWeights_\n        )\n    {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        return (fds.feeReceivers, fds.feeWeights);\n    }\n\n    /**\n     * @notice Calculates the adjusted principal amount and individual fee amounts.\n     * @param ds Diamond storage pointer.\n     * @param principalAmount The total amount before fee deduction.\n     * @return adjustedAmount The principal amount remaining after deducting total fees.\n     * @return feeAmounts Array of individual fee amounts calculated for each receiver.\n     */\n    function _calculateAmounts(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        uint256 principalAmount\n    )\n        internal\n        view\n        returns (\n            uint256 adjustedAmount,\n            uint256[] memory feeAmounts\n        )\n    {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        address[] memory receivers = fds.feeReceivers;\n        uint256 numReceivers = receivers.length;\n\n        if (numReceivers == 0) {\n            // No fee receivers configured, return full principal (pass-through)\n            return (principalAmount, new uint256[](0));\n        }\n\n        // If fee receivers are configured, then the basis must be initialized.\n        require(fds.totalWeightBasis > 0, \"FeeDistributor: Not initialized or invalid basis\");\n        uint256[] memory weights = fds.feeWeights; // Get weights only if needed\n\n        feeAmounts = new uint256[](numReceivers);\n        uint256 totalFeeAmount = 0;\n\n        for (uint i = 0; i < numReceivers; i++) {\n            // Calculate fee: (principalAmount * weight) / basis\n            // Protect against overflow before division\n            uint256 fee = (principalAmount * weights[i]) / fds.totalWeightBasis;\n            feeAmounts[i] = fee;\n            totalFeeAmount += fee;\n        }\n\n        require(totalFeeAmount <= principalAmount, \"FeeDistributor: Total fees exceed principal\");\n        adjustedAmount = principalAmount - totalFeeAmount;\n\n        return (adjustedAmount, feeAmounts);\n    }\n\n    /**\n     * @notice Distributes a principal amount after deducting fees.\n     * @dev Can distribute either native currency (if distributionToken is address(0)) or a specified ERC20 token.\n     * @dev Assumes the contract holds sufficient balance of the currency/token to distribute.\n     * @param ds Diamond storage pointer.\n     * @param self The address of the calling contract (the diamond) for native transfers.\n     * @param principalAmountReceiver The address to receive the adjusted principal amount.\n     * @param _principalAmount The total amount to be distributed.\n     * @return adjustedAmountReceiver_ The address that received the adjusted principal amount.\n     * @return adjustedAmount_ The adjusted principal amount transferred.\n     * @return feeReceivers_ The addresses that received the fee amounts.\n     * @return feeAmounts_ The individual fee amounts transferred.\n     */\n    function _distributeAmounts(\n        IdentitySystemStorage.IdentitySystem storage ds,\n        address self, // Address of the diamond/calling contract\n        address principalAmountReceiver,\n        uint256 _principalAmount\n    ) internal returns (\n        address adjustedAmountReceiver_,\n        uint256 adjustedAmount_,\n        address[] memory feeReceivers_,\n        uint256[] memory feeAmounts_\n    ) {\n        FeeDistributorStorage storage fds = ds.feeDistributorStorage;\n        // No require for token != address(0) anymore, as address(0) signifies native currency\n        require(principalAmountReceiver != address(0), \"FeeDistributor: Invalid principal receiver\");\n\n        // Calculate amounts\n        (uint256 adjustedAmount, uint256[] memory feeAmounts) = _calculateAmounts(ds, _principalAmount);\n\n        address[] memory receivers = fds.feeReceivers;\n        bool isNative = fds.distributionToken == address(0);\n\n        if (isNative) {\n            // Native currency distribution\n            require(self.balance >= _principalAmount, \"FeeDistributor: Insufficient native balance\");\n            // Transfer fees\n            for (uint i = 0; i < receivers.length; i++) {\n                if (feeAmounts[i] > 0) {\n                    (bool success, ) = payable(receivers[i]).call{value: feeAmounts[i]}(\"\");\n                    require(success, \"FeeDistributor: Native fee transfer failed\");\n                }\n            }\n            // Transfer adjusted principal amount\n            if (adjustedAmount > 0) {\n                (bool success, ) = payable(principalAmountReceiver).call{value: adjustedAmount}(\"\");\n                require(success, \"FeeDistributor: Native principal transfer failed\");\n            }\n        } else {\n            // ERC20 token distribution\n            IERC20 token = IERC20(fds.distributionToken);\n            require(token.balanceOf(self) >= _principalAmount, \"FeeDistributor: Insufficient token balance\");\n            // Transfer fees\n            for (uint i = 0; i < receivers.length; i++) {\n                if (feeAmounts[i] > 0) {\n                    token.safeTransfer(receivers[i], feeAmounts[i]);\n                }\n            }\n            // Transfer adjusted principal amount\n            if (adjustedAmount > 0) {\n                token.safeTransfer(principalAmountReceiver, adjustedAmount);\n            }\n        }\n\n        // Return values for event emission\n        return (principalAmountReceiver, adjustedAmount, receivers, feeAmounts);\n    }\n\n}"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IERC173.sol\"; // for IERC173 interface\nimport \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    // Upgrade proposal struct for timelock functionality\n    struct UpgradeProposal {\n        IDiamondCut.FacetCut[] diamondCut;\n        address initAddress;\n        bytes initCalldata;\n        uint256 proposalTime;\n        bool exists;\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n        // Timelock for upgrades (in seconds)\n        uint256 upgradeTimelock;\n        // Storage for the current upgrade proposal\n        UpgradeProposal upgradeProposal;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit IERC173.OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    // Timelock constants\n    uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days;\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Initialize timelock settings for upgrade proposals\n    function initializeUpgradeTimelock(uint256 _timelock) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeTimelock == 0, \"LibDiamond: Timelock already initialized\");\n        ds.upgradeTimelock = _timelock > 0 ? _timelock : DEFAULT_UPGRADE_TIMELOCK;\n    }\n\n    // Propose a diamond cut to be executed after the timelock\n    function proposeDiamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(!ds.upgradeProposal.exists, \"LibDiamond: Upgrade already proposed\");\n        require(ds.upgradeTimelock > 0, \"LibDiamond: Timelock not initialized\");\n        \n        // Create a deep copy of the diamond cut to store in the proposal\n        IDiamondCut.FacetCut[] memory diamondCutCopy = new IDiamondCut.FacetCut[](_diamondCut.length);\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            diamondCutCopy[i] = _diamondCut[i];\n            \n            // Deep copy the function selectors array\n            bytes4[] memory selectors = new bytes4[](_diamondCut[i].functionSelectors.length);\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                selectors[j] = _diamondCut[i].functionSelectors[j];\n            }\n            diamondCutCopy[i].functionSelectors = selectors;\n        }\n        \n        // Store the proposal\n        // Create empty array in storage first\n        delete ds.upgradeProposal.diamondCut;\n        \n        // Manually copy each element and its nested arrays to storage\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            // Create a new struct in storage by pushing an empty element first\n            ds.upgradeProposal.diamondCut.push();\n            \n            // Now set the values for this element's fields\n            ds.upgradeProposal.diamondCut[i].facetAddress = _diamondCut[i].facetAddress;\n            ds.upgradeProposal.diamondCut[i].action = _diamondCut[i].action;\n            \n            // For the selectors array, we need to handle it separately\n            // Clear any existing selectors to ensure clean state\n            delete ds.upgradeProposal.diamondCut[i].functionSelectors;\n            \n            // Copy each selector individually\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                ds.upgradeProposal.diamondCut[i].functionSelectors.push(_diamondCut[i].functionSelectors[j]);\n            }\n        }\n        ds.upgradeProposal.initAddress = _init;\n        ds.upgradeProposal.initCalldata = _calldata;\n        ds.upgradeProposal.proposalTime = block.timestamp;\n        ds.upgradeProposal.exists = true;\n        \n        emit IDiamondCut.DiamondCutProposed(msg.sender, block.timestamp, block.timestamp + ds.upgradeTimelock);\n    }\n    \n    // Execute a proposed diamond cut after the timelock period\n    function executeDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        require(\n            block.timestamp >= ds.upgradeProposal.proposalTime + ds.upgradeTimelock,\n            \"LibDiamond: Timelock period not elapsed\"\n        );\n        \n        // Execute the diamond cut\n        diamondCut(\n            ds.upgradeProposal.diamondCut,\n            ds.upgradeProposal.initAddress,\n            ds.upgradeProposal.initCalldata\n        );\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n    }\n    \n    // Cancel a proposed diamond cut\n    function cancelDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n        \n        emit IDiamondCut.DiamondCutCancelled(msg.sender);\n    }\n}\n"
    },
    "contracts/libraries/MerkleProver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary MerkleProver {\n\n  function verify(\n    bytes32 root,\n    bytes32 leaf,\n    bytes32[] memory proof\n  )\n    public\n    pure\n    returns (bool)\n  {\n    // Added check for empty proof when leaf is root\n    if (leaf == root && proof.length == 0) {\n        return false;\n    }\n\n    bytes32 computedHash = leaf;\n\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n      }\n    }\n\n    // Check if the computed hash (root) is equal to the provided root\n    return computedHash == root;\n  }\n\n  function getHash(address a, uint256 b) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(a, b));\n  }\n\n}\n"
    },
    "contracts/libraries/MetadataLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\n\nimport \"./StringsLib.sol\";\n\nimport \"../interfaces/IMetadata.sol\";\nimport \"../interfaces/IAttribute.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\nimport \"./SVGTemplatesLib.sol\";\nimport \"./AttributeLib.sol\";\n\nimport \"../utilities/SVGManager.sol\";\n\nimport \"hardhat/console.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable quotes */\n/* solhint-disable indent */\n\nstruct MetadataStorage {\n    MetadataContract metadata;\n}\n\nlibrary MetadataLib {\n    using Strings for uint256;\n    using StringsLib for string;\n    using AttributeLib for AttributeContract;\n\n    bytes32 internal constant TYPE_HASH = keccak256(\"type\");\n    bytes32 internal constant CLAIM_HASH = keccak256(\"claim\");\n      \n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.MetadataStorage.storage\");\n\n    function metadataStorage() internal pure returns (MetadataStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setMetadata(MetadataContract storage, MetadataContract memory _contract) internal {\n        metadataStorage().metadata = _contract;\n    }\n\n    /// @notice return the name of the metadata\n    function name(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._name; }\n\n    /// @notice return the symnbol of the metadata\n    function symbol(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._symbol; }\n\n    /// @notice return the description of the metadata\n    function description(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._description; }\n\n    /// @notice return the image of the metadata\n    function image(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) {\n            (, string memory svg) = getContractImage(self);\n            return svg;\n        }\n\n    /// @notice get the image for the contract\n    function getContractImage(\n        MetadataContract storage self\n    ) internal view returns (address addr, string memory svg) {\n\n        // get the image, error if no image\n        SVGManager mgr = SVGManager(SVGTemplatesLib.svgStorage().svgManager);\n\n        try mgr.svgAddress(self._imageName) returns (address _addr) {\n            address imageAddress = addr = _addr;\n            require(imageAddress != address(0), \"no image hash been set\");   \n            \n            string[] memory cccc = new string[](4);\n            cccc[0] = \"CUT\";\n            cccc[1] = \"COLOR\";\n            cccc[2] = \"CARAT\";\n            cccc[3] = \"CLARITY\";\n            Replacement[] memory replacements =\n                _getReplacements(\n                    self._imageColors,\n                    cccc\n                );\n\n            svg = ISVGTemplate(imageAddress).buildSVG(replacements);\n        } catch(bytes memory) {\n            svg = self._imageName;\n        }\n    }\n\n    /// @notice get the image for the gem\n    function getTokenImage(\n        MetadataContract storage,\n        DiamondContract storage,\n        AttributeContract storage a,\n        uint256 tokenId\n    ) internal view returns (string memory svg, Attribute[] memory attributes) {\n\n        // get the attributes for the token\n        string[] memory attributeKeys = AttributeLib._getAttributeKeys(a, tokenId);\n        attributes = new Attribute[](attributeKeys.length);\n        string[] memory cccc = AttributeLib._getAttributeValues(tokenId);\n\n        for(uint256 i = 0; i < attributeKeys.length; i++) {\n            attributes[i] = Attribute({\n                key: attributeKeys[i],\n                attributeType: AttributeType.String,\n                value: cccc[i]\n            });\n        }\n\n        // get the image, error if no image\n        string memory key = string(abi.encodePacked(\"image_\", tokenId.toString()));\n        string memory val = AttributeLib._getAttribute(a, tokenId, key).value;\n        svg = val;\n        \n        // Replacement[] memory replacements;\n        // if (!val.startsWith('0x')) {\n        //     svg = val;\n        // } else {\n        //     SVGManager mgr = SVGManager(SVGTemplatesLib.svgStorage().svgManager);\n        //     address imageAddress = mgr.svgAddress(key);\n        //     if (imageAddress == address(0)) imageAddress = mgr.svgAddress(self._imageName);\n        //     replacements =\n        //     _getReplacements(\n        //         self._imageColors,\n        //         cccc);\n        //     svg = ISVGTemplate(imageAddress).buildSVG(replacements);\n        // }\n    }\n\n    function setTokenImage(\n        MetadataContract storage,\n        AttributeContract storage a,\n        uint256 tokenId,\n        string memory svg\n    ) internal {\n        string memory key = string(abi.encodePacked(\"image_\", tokenId.toString()));\n        a._setAttribute(tokenId, Attribute(\n            key,\n            AttributeType.String,\n            svg\n        ));\n    }\n\n    function _setMetadataSource(\n        MetadataContract storage self,\n        MetadataSource source\n    ) internal {\n        self._metadataSource = source;\n    }\n\n    function _setBaseURI(MetadataContract storage self, string memory baseURI)\n        internal {\n        self._baseUri = baseURI;\n    }\n\n    /// @notice get th replacement values for the svg\n    function _getReplacements(\n        string[] memory colorPalette,\n        string[] memory cccc\n    ) internal pure returns (Replacement[] memory) {\n        if(colorPalette.length == 0) {\n            return new Replacement[](4);\n        }\n        Replacement[] memory replacements = new Replacement[](\n            colorPalette.length + 4\n        );\n        for (uint256 i = 0; i < colorPalette.length; i++) {\n            replacements[i] = Replacement(\n                string(abi.encodePacked(\"COLOR \", Strings.toString(i))),\n                colorPalette[i]\n            );\n        }\n        uint256 l = colorPalette.length;\n        replacements[l] = Replacement(\"CUT\", cccc[0]);\n        replacements[l + 1] = Replacement(\"COLOR\", cccc[1]);\n        replacements[l + 2] = Replacement(\"CARAT\", cccc[2]);\n        replacements[l + 3] = Replacement(\"CLARITY\", cccc[3]);\n        return replacements;\n    }\n\n\n    /// @notice See {IERC721Metadata-tokenURI}.\n    function tokenURI(\n        MetadataContract storage self,\n        DiamondContract storage diamond,\n        AttributeContract storage attribs,\n        uint256 tokenId\n    ) internal view returns (string memory) {\n\n        // get the token image and attributes\n        (string memory svg, Attribute[] memory attributes) = getTokenImage(\n            self,\n            diamond,\n            attribs,\n            tokenId\n        );\n\n        // turn the attributes into traits\n        Trait[] memory traits = new Trait[](attributes.length);\n        string memory _name = diamond.settings.name;\n        for (uint256 i = 0; i < attributes.length; i++) {\n            traits[i] = Trait(\"\", attributes[i].key, attributes[i].value);\n            // add the word 'claim' to the name if the attribute is a claim\n            if (\n                TYPE_HASH == keccak256(bytes(attributes[i].key)) &&\n                CLAIM_HASH == keccak256(bytes(attributes[i].value))\n            ) {\n                _name = string(abi.encodePacked(_name, \" Claim\"));\n            }\n        }\n        // base64 encode the token data and return it\n        string memory json = Base64.encode(\n            bytes(getTokenMetadata(self, traits, svg))\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function contractURI(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) {\n        Trait[] memory dum;\n        (, string memory svg) = getContractImage(self);\n        string memory json = Base64.encode(\n            bytes(\n                getTokenMetadata(self, dum,  svg)\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice create a metadata trait\n    function createTrait(\n        string memory displayType,\n        string memory key,\n        string memory value\n    ) internal pure returns (string memory trait) {\n        // ensure key is not empty\n        require(bytes(key).length > 0, \"key cannot be empty\");\n        // if has a display type, then output the display type\n        bool hasDisplayType = bytes(displayType).length > 0;\n        if (hasDisplayType) {\n            displayType = string(\n                abi.encodePacked('\"display_type\": \"', displayType, '\",')\n            );\n            // if this is a number, then don't quote it, otherwise quote it\n            bool isNumber = StringsLib.startsWith(displayType, \"number\") ||\n                StringsLib.endsWith(displayType, \"percentage\");\n            if (!isNumber) value = string(abi.encodePacked('\"', value, '\"'));\n            else value = string(abi.encodePacked(value));\n        } else value = string(abi.encodePacked('\"', value, '\"'));\n        // return the trait\n        trait = string(\n            abi.encodePacked(\n                \"{\",\n                displayType,\n                '\"trait_type\": \"',\n                key,\n                '\", \"value\": ',\n                value,\n                \"}\"\n            )\n        );\n    }\n\n    /// @notice given an array of trait structs, create a metadata string\n    function arrayizeTraits(Trait[] memory _traits)\n        internal\n        pure\n        returns (string memory _traitsString)\n    {\n        bytes memory traitBytes = \"[\";\n        for (uint256 i = 0; i < _traits.length; i++) {\n            Trait memory traitObj = _traits[i];\n            string memory trait = createTrait(\n                traitObj.displayType,\n                traitObj.key,\n                traitObj.value\n            );\n            traitBytes = abi.encodePacked(traitBytes, trait);\n            if (i < _traits.length - 1) {\n                traitBytes = abi.encodePacked(traitBytes, \",\");\n            }\n        }\n        _traitsString = string(abi.encodePacked(traitBytes, \"]\"));\n    }\n\n    /// @notice create a metadata string from a metadata struct\n    function getTokenMetadata(\n        MetadataContract memory definition,\n        Trait[] memory _traits,\n        string memory _imageData\n    ) internal pure returns (string memory metadata) {\n        if(!_imageData.startsWith(\"0x\")) {\n            _imageData = string(abi.encodePacked('\"', _imageData, '\"'));\n        }\n        string memory traitsString = arrayizeTraits(_traits);\n        string memory imageUrl = bytes(definition._externalUri).length > 0\n            ? string(\n                abi.encodePacked(\n                    '\"',\n                    definition._externalUri,\n                    '\"'\n                )\n            )\n            : string(abi.encodePacked('\"external_url\"', ': \"', '\"'));\n        string memory externalUrl = bytes(definition._externalUri).length > 0\n            ? string(\n                abi.encodePacked(\n                    '\"external_url\": \"',\n                    definition._externalUri,\n                    '\"'\n                )\n            )\n            : string(abi.encodePacked('\"external_url\"', ': \"', '\"'));\n        bytes memory a1 = abi.encodePacked(\n            '{\"name\": \"',\n            definition._name,\n            '\", \"image\": ',\n            imageUrl,\n            ', \"description\": \"',\n            definition._description,\n            '\", ',\n            externalUrl\n        );\n        if (_traits.length > 0) {\n            a1 = abi.encodePacked(a1, ', \"attributes\": ', traitsString);\n        }\n        metadata = string(abi.encodePacked(a1, \"}\"));\n    }\n}\n"
    },
    "contracts/libraries/MultiSaleLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../identity/IdentityStorage.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./MerkleProver.sol\";\n\nimport \"../interfaces/IMultiSale.sol\";\nimport \"../interfaces/IVariablePrice.sol\";\n\nimport \"./VariablePriceLib.sol\";\n\nimport \"../utilities/InterfaceChecker.sol\";\n\nlibrary MultiSaleLib {\n    using SafeERC20 for IERC20;\n\n\n    /// @notice get a new tokensale id\n    /// @return tokenSaleId the new id\n    function _createTokenSale() internal returns (uint256 tokenSaleId) {\n\n        // set settings object\n        tokenSaleId = uint256(\n            keccak256(\n                abi.encodePacked(IdentitySystemStorage.multiSaleStorage().tsnonce++, address(this))\n            )\n        );\n    }\n\n    /// @notice validate the token purchase\n    /// @param self the multisale storage\n    /// @param valueAttached the value attached to the transaction\n    function _validatePurchase(\n        MultiSaleContract storage self, \n        VariablePriceContract storage priceContract,\n        uint256 quantity, \n        uint256 valueAttached) internal view {\n\n        MultiSaleSettings storage settings = self.settings;\n\n        // make sure there are still tokens to purchase\n        require(settings.maxQuantity == 0 || (settings.maxQuantity != 0 &&\n            self.totalPurchased < settings.maxQuantity), \"soldout\" );\n\n        // make sure the max qty per sale is not exceeded\n        require(settings.minQuantityPerSale == 0 || (settings.minQuantityPerSale != 0 &&\n            quantity >= settings.minQuantityPerSale), \"qtytoolow\");\n\n        // make sure the max qty per sale is not exceeded\n        require(settings.maxQuantityPerSale == 0 || (settings.maxQuantityPerSale != 0 &&\n            quantity <= settings.maxQuantityPerSale), \"qtytoohigh\");\n\n        // make sure token sale is started\n        require(block.timestamp >= settings.startTime || settings.startTime == 0, \"notstarted\");\n\n        // make sure token sale is not over\n        require(block.timestamp <= settings.endTime || settings.endTime == 0,\n            \"saleended\" );\n         \n        // gt thte total price \n        uint256 totalPrice = priceContract.price * quantity;\n        require(totalPrice <= valueAttached, \"notenoughvalue\");\n    }\n    \n    /// @notice validate the token purchase using the given proof\n    /// @param self the multisale storage\n    /// @param purchaseProof the proof\n    function _validateProof(\n        MultiSaleContract storage self,\n        MultiSalePurchase memory purchase,\n        MultiSaleProof memory purchaseProof\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage identityDs = IdentitySystemStorage.diamondStorage();\n        if (self.settings.whitelistOnly) {\n\n            // check that the airdrop has not yet been redeemed by the user\n            require(!_airdropRedeemed(self, purchase.receiver), \"redeemed\");\n\n            // check to see if redeemed already\n            uint256 _redeemedAmt = self._redeemedDataQuantities[purchase.receiver];\n            uint256 _redeemedttl = self._totalDataQuantities[purchase.receiver];\n            _redeemedttl = _redeemedAmt > 0 ? _redeemedttl : purchaseProof.total;\n\n            // ensure that the user has not redeemed more than the total\n            require(_redeemedAmt + purchase.quantity <= _redeemedttl, \"redeemed\");\n            self._totalDataQuantities[purchase.receiver] = _redeemedttl;\n            self._redeemedDataQuantities[purchase.receiver] += purchase.quantity; // increment amount redeemed\n\n            // Construct the leaf data including the receiver address and the total quantity\n            bytes32 leafData = keccak256(abi.encodePacked(purchaseProof.leaf, purchase.receiver, purchaseProof.total));\n\n            // Check the proof against the constructed leaf data\n            bool valid = MerkleProver.verify(\n                bytes32 (self.settings.whitelistHash),\n                leafData, // Use the constructed leaf data\n                purchaseProof.merkleProof\n            );\n\n            // Check the merkle proof\n            require(valid, \"Merkle proof failed\");\n\n            // Prevent replay attacks by tracking used leaves\n            bytes32 leafHash = keccak256(abi.encodePacked(purchaseProof.leaf, purchase.receiver));\n            require(!identityDs.usedMerkleLeaves[leafHash], \"Merkle proof already used\");\n            identityDs.usedMerkleLeaves[leafHash] = true;\n        }\n    }\n\n    /// @notice airdrops check to see if proof is redeemed\n    /// @param recipient the merkle proof\n    /// @return isRedeemed the amount of tokens redeemed\n    function _airdropRedeemed(MultiSaleContract storage self, address recipient) internal view returns (bool isRedeemed) {\n\n        uint256 red = self._totalDataQuantities[recipient];\n        uint256 tot = self._redeemedDataQuantities[recipient]; // i\n        isRedeemed = red != 0 && red == tot;\n    }\n\n    /// @notice purchase a token sale token without any proof\n    /// @param self the token sale id\n    /// @param purchase the token hash\n    function __purchase(\n        MultiSaleContract storage self,\n        MultiSalePurchase memory purchase,\n        VariablePriceContract memory variablePrice,\n        uint256 valueAttached\n    ) internal {\n        // transfer the payment to the contract if erc20\n        if (self.settings.paymentType == PaymentType.ERC20 &&\n            self.settings.tokenAddress != address(0)) {\n            uint256 purchaseAmount = purchase.quantity * variablePrice.price;\n            require(purchaseAmount > 0, \"invalidamount\");\n            _transferErc20PaymkentToContract(\n                purchase.purchaser,\n                self.settings.tokenAddress,\n                purchaseAmount\n            );\n        } else {\n            uint256 purchaseAmount = purchase.quantity * variablePrice.price;\n            require(valueAttached >= purchaseAmount, \"invalidamount\");\n        }\n        // transfer the tokens to the receiver\n        _transferPaymentToPayee(self, valueAttached);\n\n    }    \n\n    /// @notice purchase a token sale token without any proof\n    /// @param self the token sale id\n    /// @param purchase the token hash\n    function _purchaseToken(\n        MultiSaleContract storage self,\n        VariablePriceContract storage variablePrice,\n        MultiSalePurchase memory purchase,\n        MultiSaleProof memory purchaseProof,\n        uint256 valueAttached\n    ) internal {\n\n        // validate the purchase\n        _validatePurchase(self, variablePrice, purchase.quantity, valueAttached);\n        \n        // validate the proof\n        _validateProof(self, purchase, purchaseProof);\n\n        // make the purchase\n        __purchase(\n            self, \n            purchase, \n            VariablePriceLib.variablePriceStorage().variablePrices,\n            valueAttached);\n\n    }\n\n    /// @notice purchase a token sale token without any proof\n    /// @param self the token sale id\n    /// @param purchase the token hash\n    function _purchaseToken(\n        MultiSaleContract storage self,\n        VariablePriceContract storage variablePrice,\n        MultiSalePurchase memory purchase,\n        uint256 valueAttached\n    ) internal {\n\n        // validate the purchase\n        _validatePurchase(self, variablePrice, purchase.quantity, valueAttached);\n\n        // make the purchase\n        __purchase(self, purchase, variablePrice, valueAttached);\n    }\n    \n    /// @notice transfer erc20 payment to the contract\n    /// @param sender the sender of the payment\n    /// @param paymentToken the token address\n    /// @param paymentAmount the amount of payment\n    function _transferErc20PaymkentToContract(\n        address sender,\n        address paymentToken,\n        uint256 paymentAmount\n    ) internal {\n\n        // transfer payment to contract\n        IERC20(paymentToken).safeTransferFrom(sender, address(this), paymentAmount);\n    }\n\n    /// @notice transfer payment to the token sale payee\n    /// @param self the token sale settings\n    /// @param valueAttached the value attached to the transaction\n    function _transferPaymentToPayee(MultiSaleContract storage self, uint256 valueAttached) internal {\n\n        // transfer the payment to the payee if the payee address is set\n        if (self.settings.payee != address(0)) {\n            if (self.settings.paymentType == PaymentType.ERC20) {\n                IERC20(self.settings.tokenAddress).safeTransferFrom(\n                    address(this),\n                    self.settings.payee,\n                    valueAttached\n                );\n            } else {\n                (bool success, ) = self.settings.payee.call{value: valueAttached}(\"\");\n                require(success, \"Failed to send Ether\");\n            }\n        }\n    }\n\n    /// @notice get the token type\n    /// @param token the token id\n    /// @return tokenType the token type\n    function _getTokenType(address token)\n        internal\n        view\n        returns (TokenType tokenType) {\n\n        tokenType = InterfaceChecker.isERC20(token)\n            ? TokenType.ERC20\n            : InterfaceChecker.isERC721(token)\n            ? TokenType.ERC721\n            : TokenType.ERC1155;\n    }\n}\n"
    },
    "contracts/libraries/StringsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../interfaces/IStrings.sol\";\n\nlibrary StringsLib {\n\n    function parseInt(string memory s) internal pure returns (uint256 res) {\n        uint256 sLength = bytes(s).length;\n        for (uint256 i = 0; i < sLength; i++) {\n            if ((uint8(bytes(s)[i]) - 48) < 0 || (uint8(bytes(s)[i]) - 48) > 9) {\n                return 0;\n            }\n            res += (uint8(bytes(s)[i]) - 48) * 10**(bytes(s).length - i - 1);\n        }\n        return res;\n\n    }\n\n    function startsWith(string memory haystack, string memory needle)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        bytes memory needleBytes = bytes(needle);\n        uint256 haystackLength = haystackBytes.length;\n        uint256 needleLength = needleBytes.length;\n        if (needleLength > haystackLength) {\n            return false;\n        }\n        for (uint256 i = 0; i < needleLength; i++) {\n            if (haystackBytes[i] != needleBytes[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function endsWith(string memory haystack, string memory needle)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        bytes memory needleBytes = bytes(needle);\n        uint256 haystackLength = haystackBytes.length;\n        uint256 needleLength = needleBytes.length;\n        if (needleLength > haystackLength) {\n            return false;\n        }\n        for (uint256 i = 0; i < needleLength; i++) {\n            if (\n                haystackBytes[haystackLength - i - 1] !=\n                needleBytes[needleLength - i - 1]\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function substring(string memory haystack, uint256 startpos)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        uint256 length = haystackBytes.length;\n        uint256 endpos = length - startpos;\n        bytes memory substringBytes = new bytes(endpos);\n        for (uint256 i = 0; i < endpos; i++) {\n            substringBytes[i] = haystackBytes[startpos + i];\n        }\n        return string(substringBytes);\n    }\n\n    function substring(string memory haystack, uint256 startpos, uint256 endpos)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        uint256 substringLength = endpos - startpos;\n        bytes memory substringBytes = new bytes(substringLength);\n        for (uint256 i = 0; i < substringLength; i++) {\n            substringBytes[i] = haystackBytes[startpos + i];\n        }\n        return string(substringBytes);\n    }\n\n    function concat(string[] memory _strings)\n        internal\n        pure\n        returns (string memory _concat)\n    {\n        _concat = \"\";\n        uint256 stringsLength = _strings.length;\n        for (uint256 i = 0; i < stringsLength; i++) {\n            _concat = string(abi.encodePacked(_concat, _strings[i]));\n        }\n        return _concat;\n    }\n\n    function split(string memory _string, string memory _delimiter) internal pure returns (string[] memory _split) {\n        _split = new string[](0);\n        uint256 _delimiterLength = bytes(_delimiter).length;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _splitLength = 0;\n        uint256 _splitIndex = 0;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] == bytes(_delimiter)[0]) {\n                _endpos = i;\n                if (_endpos - _startpos > 0) {\n                    _split[_splitIndex] = substring(_string, _startpos);\n                    _splitIndex++;\n                    _splitLength++;\n                }\n                _startpos = i + _delimiterLength;\n            }\n        }\n        if (_startpos < _stringLength) {\n            _split[_splitIndex] = substring(_string, _startpos);\n            _splitIndex++;\n            _splitLength++;\n        }\n        return _split;\n    }\n\n    function join(string[] memory _strings, string memory _delimiter) internal pure returns (string memory _joined) {\n        uint256 stringsLength = _strings.length;\n        for (uint256 i = 0; i < stringsLength; i++) {\n            _joined = string(abi.encodePacked(_joined, _strings[i]));\n            if (i < _strings.length - 1) {\n                _joined = string(abi.encodePacked(_joined, _delimiter));\n            }\n        }\n        return _joined;\n    }\n\n    function replace(string memory _string, string memory _search, string memory _replace) internal pure returns (string memory _replaced) {\n        _replaced = _string;\n        uint256 _searchLength = bytes(_search).length;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _replacedLength = _stringLength;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] == bytes(_search)[0]) {\n                _endpos = i;\n                if (_endpos - _startpos > 0) {\n                    _replaced = substring(_replaced, _startpos);\n                    _replacedLength -= _endpos - _startpos;\n                }\n                _replaced = string(abi.encodePacked(_replaced, _replace));\n                _replacedLength += bytes(_replace).length;\n                _startpos = i + _searchLength;\n            }\n        }\n        if (_startpos < _stringLength) {\n            _replaced = substring(_replaced, _startpos);\n            _replacedLength -= _stringLength - _startpos;\n        }\n        return _replaced;\n    }\n\n    function trim(string memory _string) internal pure returns (string memory _trimmed) {\n        _trimmed = _string;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] != 0x20) {\n                _startpos = i;\n                break;\n            }\n        }\n        for (uint256 i = _stringLength - 1; i >= 0; i--) {\n            if (bytes(_string)[i] != 0x20) {\n                _endpos = i;\n                break;\n            }\n        }\n        if (_startpos < _endpos) {\n            _trimmed = substring(_trimmed, _startpos);\n            _trimmed = substring(_trimmed, 0, _endpos - _startpos + 1);\n        }\n        return _trimmed;\n    }\n\n    function toUint16(string memory s) internal pure returns (uint16 res_) {\n        uint256 res = 0;\n        uint256 sLength = bytes(s).length;\n        for (uint256 i = 0; i < sLength; i++) {\n            if ((uint8(bytes(s)[i]) - 48) < 0 || (uint8(bytes(s)[i]) - 48) > 9) {\n                return 0;\n            }\n            res += (uint8(bytes(s)[i]) - 48) * 10**(bytes(s).length - i - 1);\n        }\n        res_ = uint16(res);\n    }\n\n\n    function replace(string[] memory input, string memory matchTag, string[] memory repl) internal pure returns (string memory) {\n        string memory svgBody;\n        for(uint256 i = 0; i < input.length; i++) {\n            string memory svgString = input[i];\n            string memory outValue;\n            if(StringsLib.startsWith(svgString, matchTag)) {\n                string memory restOfLine = StringsLib.substring(svgString, bytes(matchTag).length);\n                uint256 replIndex = StringsLib.parseInt(restOfLine);\n                outValue = repl[replIndex];\n            } else {\n                outValue = svgString;\n            }\n            svgBody = string(abi.encodePacked(svgBody, outValue));\n        }\n        return svgBody;\n    }\n\n    function replace(bytes[] memory sourceBytes, Replacement[] memory replacements_) public pure returns (string memory) {\n        //bytes[] memory sourceBytes = _getSourceBytes();\n        string memory outputFile = \"\";\n        uint256 sourceBytesLength = sourceBytes.length;\n        for (uint256 i = 0; i < sourceBytesLength; i++) {\n            bytes memory sourceByte = sourceBytes[i];\n            string memory outputLine  = string(sourceBytes[i]);\n            for (uint256 j = 0; j < replacements_.length; j++) {\n                Replacement memory replacement = replacements_[j];\n                if (keccak256(sourceByte) == keccak256(bytes(replacement.matchString))) {\n                    outputLine = replacement.replaceString;\n                }\n            }\n            outputFile = string(abi.encodePacked(outputFile, outputLine));\n        }\n        return outputFile;\n    }    \n}\n"
    },
    "contracts/libraries/SVGTemplatesLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../interfaces/ISVG.sol\";\nimport \"../interfaces/IStrings.sol\";\nimport \"../interfaces/IMultiPart.sol\";\n\nimport \"../libraries/StringsLib.sol\";\n\nimport \"../utilities/SVGTemplate.sol\";\n\nstruct SaltStorage {\n    uint256 salt;\n}\n\nstruct SVGStorage {\n    SVGTemplatesContract svgTemplates;\n    SaltStorage salt;    \n    address svgManager;\n    MultiPartContract multiPart;\n}\n\nlibrary SVGTemplatesLib {\n\n    event SVGTemplateCreated(string name, address template);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.SVGStorage.storage\");\n\n    function svgStorage() internal pure returns (SVGStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n    \n    /// @notice get the stored template names in the contract\n    /// @return the names of the templates\n    function _svgs(SVGTemplatesContract storage self)\n        internal\n        view\n        returns (string[] memory) { return self._templateNames; }\n\n    /// @notice get the create2 address of the given name\n    function _svgAddress(\n        SVGTemplatesContract storage,\n        string memory _name) \n        internal \n        view returns (address) {\n        return Create2.computeAddress(\n            keccak256(abi.encodePacked(_name)), \n            keccak256(type(SVGTemplate).creationCode)\n        );  \n    }\n\n    /// @notice the svg string or an empty string\n    function _svgString(\n        SVGTemplatesContract storage self,\n        string memory _name\n    ) internal view returns (string memory data_) {\n        try SVGTemplate(_svgAddress(self, _name)).svgString() returns (string memory _data) {\n            data_ = _data;\n        } catch (bytes memory) {}\n    }\n\n    /// @notice the sstored address for the name storage. empty is no svg\n    function _svgData(\n        SVGTemplatesContract storage self,\n        string memory _name\n    ) internal view returns (address) {\n        return self._templates[_name];\n    }\n\n    /// @notice create a new SVG image with the given name\n    function _createSVG(SVGTemplatesContract storage self, address sender, string memory _name)\n        internal\n        returns (address _tplAddress)\n    {\n        // make sure the name is unique\n        require(\n            self._templates[_name] == address(0),\n            \"template already deployed\"\n        );\n\n        // get the address for the given name, create using create2,\n        // then verify that create2 returned the expected address\n        address targetTplAddress = _svgAddress(self, _name);\n        _tplAddress = Create2.deploy(\n            0,\n            keccak256(abi.encodePacked(_name)),\n            type(SVGTemplate).creationCode\n        );\n        require(targetTplAddress == _tplAddress, \"template address mismatch\");\n\n        // transfer ownership to the creator and update storage\n        Ownable(_tplAddress).transferOwnership(sender);\n        self._templateNames.push(_name);\n        self._templates[_name] = _tplAddress;\n    }\n}\n"
    },
    "contracts/libraries/TradeDealLib.sol": {
      "content": " // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../identity/IdentityStorage.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"../interfaces/IInterest.sol\";\nimport \"../interfaces/IUSDCPool.sol\";\nimport \"../interfaces/IAttribute.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nusing SafeERC20 for IERC20;\nimport \"../interfaces/IERC721Permissioned.sol\";\nimport \"../interfaces/IFeeDistributor.sol\"; // Added for fee distribution\nimport \"hardhat/console.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../libraries/AttributeLib.sol\";\n\nimport {console} from \"hardhat/console.sol\";\n\nlibrary TradeDealLib {\n    // These event declarations are temporary until we complete migration\n    // They'll be removed once we've updated all functions to return event params\n    // rather than emit events directly\n    \n    // Operation mode for trade deals\n    enum OperationMode {\n        CENTRALIZED,    // Contract owner manages all fund operations\n        SELF_SERVICE,   // Borrowers can directly withdraw/repay funds\n        HYBRID,         // Mixed model with configurable permissions\n        CUSTOM          // Fine-grained permission configuration\n    }\n    \n    // Roles for the role-based access control system\n    enum Role {\n        NONE,        // No special role (default)\n        ADMIN,       // Full control over the trade deal\n        LENDER,      // Can deposit funds and receive Collateral tokens\n        BORROWER,    // Can deposit invoices and withdraw funds (in self-service)\n        UNDERWRITER, // Can approve/reject deals, modify terms\n        LIQUIDATOR   // Can liquidate collateral if terms are violated\n    }\n    \n    // Permission bit flags for fine-grained control\n    uint256 constant PERMISSION_DEPOSIT_FUNDS = 1;\n    uint256 constant PERMISSION_WITHDRAW_FUNDS = 2;\n    uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4;\n    uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8;\n    uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16;\n    \n    event TradeDealCreated(\n        uint256 indexed tradeDealId,\n        string name,\n        string symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        bool active,\n        address nftAddress,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    );\n    // Removed duplicate TradeDealUpdated event definition\n    event TradeDealActivated(uint256 indexed tradeDealId);\n    event TradeDealDeactivated(uint256 indexed tradeDealId);\n    event TradeDealParticipantAdded(uint256 indexed tradeDealId, address indexed participant);\n    event TradeDealParticipantRemoved(uint256 indexed tradeDealId, address indexed participant);\n    event InvoiceDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n    event InvoiceWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\n    event USDCDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 amount);\n    event USDCWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 amount);\n    event InterestDistributedForTradeDeal(uint256 indexed tradeDealId, uint256 totalInterest, uint256 invoicePoolInterest, uint256 interestInterest, uint256 interestTokensMinted);\n    event TradeDealRequiredClaimTopicsSet(uint256 indexed tradeDealId, uint256[] claimTopics);\n    // New events for enhanced functionality\n    event TradeDealFullyFunded(uint256 indexed tradeDealId, uint256 fundingTarget);\n    event TradeDealFundingWithdrawn(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\n    event TradeDealRepaid(uint256 indexed tradeDealId, address indexed repayer, uint256 amount, bool fullyRepaid);\n    event CollateralTokensRedeemed(uint256 indexed tradeDealId, address indexed redeemer, uint256 collateralAmount, uint256 usdcAmount);\n    // Trade Deal data structure\n    struct TradeDeal {\n        uint256 id;\n        string name;\n        string symbol;           // Symbol for the trade deal, used for Collateral token\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        uint256[] requiredClaimTopics; // Claim topics required for participation\n        address collateralAddress;     // Address of the Collateral token contract for this trade deal\n        address interestAddress;     // Address of the VABI token contract for this trade deal\n        address usdcAddress;     // Address of the USDC token contract for this trade deal\n        OperationMode operationMode; // Operation mode (CENTRALIZED or SELF_SERVICE)\n    }\n\n    struct CollateralRedemptionResult {\n        uint256 tradeDealId;\n        address redeemer;\n        uint256 collateralAmount;\n        uint256 usdcAmount;\n    }\n    \n    // Extended CollateralleStorage to support trade deals\n    struct TradeDealStorage {\n        // Trade deal tracking\n        mapping(uint256 => TradeDeal) tradeDeals;\n        uint256[] tradeDealIds;\n        uint256 nextTradeDealId;\n        \n        // Per-trade deal mappings\n        mapping(uint256 => uint256[]) tradeDealInvoices; // Trade deal ID => array of invoice token IDs\n        mapping(uint256 => uint256) tradeDealUsdcBalances; // Trade deal ID => USDC balance\n        mapping(uint256 => mapping(address => bool)) tradeDealParticipants; // Trade deal ID => user address => is participant\n        mapping(uint256 => uint256[]) tradeDealRequiredClaimTopics; // Trade deal ID => array of required claim topics\n        \n        // Role-based access control\n        mapping(uint256 => mapping(address => Role)) userRoles; // Trade deal ID => user address => role\n        mapping(uint256 => mapping(address => uint256)) userPermissions; // Trade deal ID => user address => permissions\n        \n        // New fields for enhanced functionality\n        mapping(uint256 => uint256) tradeDealFundingTargets; // Trade deal ID => funding target\n        mapping(uint256 => bool) tradeDealFundingWithdrawn; // Trade deal ID => whether funding has been withdrawn\n        mapping(uint256 => uint256) tradeDealRepaidAmounts; // Trade deal ID => amount repaid\n        mapping(uint256 => uint256) tradeDealTotalDebt; // Trade deal ID => total debt (principal + interest)\n        \n        // Track original depositors of invoices\n        mapping(uint256 => mapping(uint256 => address)) invoiceDepositors; // Trade deal ID => token ID => original depositor\n    }\n    \n    // Return struct for createTradeDeal function\n    struct CreateTradeDealResult {\n        uint256 tradeDealId;\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        address nftAddress;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n        bool hasClaimTopics;\n        uint256[] requiredClaimTopics;\n        OperationMode operationMode;\n    }\n    \n    // Parameters struct for createTradeDeal function\n    struct CreateTradeDealParams {\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        uint256[] requiredClaimTopics;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n        OperationMode operationMode;\n    }\n    \n    // Create a new trade deal\n    function _createTradeDeal(\n        CreateTradeDealParams memory params\n    ) internal returns (CreateTradeDealResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        uint256 tradeDealId = tds.nextTradeDealId++;\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        tradeDeal.id = tradeDealId;\n        tradeDeal.name = params.name;\n        tradeDeal.symbol = params.symbol;\n        tradeDeal.interestRate = params.interestRate;\n        tradeDeal.collateralToInterestRatio = params.collateralToInterestRatio;\n        tradeDeal.active = true;\n        \n        // Check if we should use the CollateralTokenFactoryFacet to create a new Collateral token\n        address collateralAddress = params.collateralAddress;\n        if (collateralAddress == address(0)) {\n            // Try to create a new Collateral token\n            collateralAddress = _createOrGetCollateralToken(tradeDealId, params.symbol);\n        }\n        \n        tradeDeal.collateralAddress = collateralAddress;\n        tradeDeal.interestAddress = params.interestAddress;\n        tradeDeal.usdcAddress = params.usdcAddress;\n        tradeDeal.operationMode = params.operationMode;\n        \n        // Set required claim topics\n        bool hasClaimTopics = params.requiredClaimTopics.length > 0;\n        if (hasClaimTopics) {\n            uint256 requiredClaimTopicsLength = params.requiredClaimTopics.length;\n            for (uint256 i = 0; i < requiredClaimTopicsLength; i++) {\n                tradeDeal.requiredClaimTopics.push(params.requiredClaimTopics[i]);\n                tds.tradeDealRequiredClaimTopics[tradeDealId].push(params.requiredClaimTopics[i]);\n            }\n        }\n        // Initialize repayment tracking - funding target will be set when an invoice is deposited\n        tds.tradeDealFundingTargets[tradeDealId] = 0; // Will be set based on NFT totalAmount when invoice is deposited\n        tds.tradeDealRepaidAmounts[tradeDealId] = 0;\n        tds.tradeDealTotalDebt[tradeDealId] = 0; // Will be set when fully funded\n        tds.tradeDealFundingWithdrawn[tradeDealId] = false;\n        tds.tradeDealFundingWithdrawn[tradeDealId] = false;\n        \n        tds.tradeDealIds.push(tradeDealId);\n        \n        // Instead of emitting events, return the data needed for the facet to emit events\n        CreateTradeDealResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.name = params.name;\n        result.symbol = params.symbol;\n        result.interestRate = params.interestRate;\n        result.collateralToInterestRatio = params.collateralToInterestRatio;\n        result.active = true;\n        result.nftAddress = address(0); // Use address(0) for nftAddress since we're using the Diamond's ERC721PermissionedTokenFacet\n        result.collateralAddress = collateralAddress;\n        result.interestAddress = params.interestAddress;\n        result.usdcAddress = params.usdcAddress;\n        result.hasClaimTopics = hasClaimTopics;\n        result.requiredClaimTopics = params.requiredClaimTopics;\n        result.operationMode = params.operationMode;\n        \n        return result;\n    }\n    // Return struct for updateTradeDeal function\n    struct UpdateTradeDealResult {\n        uint256 tradeDealId;\n        string name;\n        string symbol;\n        uint256 interestRate;\n        uint256 collateralToInterestRatio;\n        bool active;\n        address collateralAddress;\n        address interestAddress;\n        address usdcAddress;\n    }\n    \n    // Update an existing trade deal\n    // Update an existing trade deal\n    function _updateTradeDeal(\n        uint256 tradeDealId,\n        string memory name,\n        string memory symbol,\n        uint256 interestRate,\n        uint256 collateralToInterestRatio,\n        address collateralAddress,\n        address interestAddress,\n        address usdcAddress\n    ) internal returns (UpdateTradeDealResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        tradeDeal.name = name;\n        tradeDeal.symbol = symbol;\n        tradeDeal.interestRate = interestRate;\n        tradeDeal.collateralToInterestRatio = collateralToInterestRatio;\n        tradeDeal.collateralAddress = collateralAddress;\n        tradeDeal.interestAddress = interestAddress;\n        tradeDeal.usdcAddress = usdcAddress;\n        \n        // Instead of emitting an event, return the data needed for the facet to emit the event\n        UpdateTradeDealResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.name = name;\n        result.symbol = symbol;\n        result.interestRate = interestRate;\n        result.collateralToInterestRatio = collateralToInterestRatio;\n        result.active = tradeDeal.active;\n        result.collateralAddress = collateralAddress;\n        result.interestAddress = interestAddress;\n        result.usdcAddress = usdcAddress;\n        \n        return result;\n    }\n    \n    // Return struct for activate/deactivate trade deal\n    struct TradeDealStateChangeResult {\n        uint256 tradeDealId;\n    }\n    \n    // Activate a trade deal\n    function _activateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDeals[tradeDealId].active = true;\n        \n        // Return result instead of emitting event\n        TradeDealStateChangeResult memory result;\n        result.tradeDealId = tradeDealId;\n        return result;\n    }\n    \n    // Deactivate a trade deal\n    function _deactivateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDeals[tradeDealId].active = false;\n        \n        // Return result instead of emitting event\n        TradeDealStateChangeResult memory result;\n        result.tradeDealId = tradeDealId;\n        return result;\n    }\n    \n    // Check if a trade deal exists\n    function _tradeDealExists(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        return tradeDealId < tds.nextTradeDealId && tds.tradeDeals[tradeDealId].id == tradeDealId;\n    }\n    \n    // Get trade deal info\n    function _getTradeDealInfo(uint256 tradeDealId) internal view returns (TradeDeal memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDeals[tradeDealId];\n    }\n    \n    // Get all trade deal IDs\n    function _getAllTradeDealIds() internal view returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        return tds.tradeDealIds;\n    }\n    \n    // Return struct for participant management functions\n    struct TradeDealParticipantResult {\n        uint256 tradeDealId;\n        address participant;\n    }\n    \n    // Participant management\n    function _addTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDealParticipants[tradeDealId][participant] = true;\n        \n        // Return result instead of emitting event\n        TradeDealParticipantResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.participant = participant;\n        return result;\n    }\n    \n    function _removeTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        tds.tradeDealParticipants[tradeDealId][participant] = false;\n        \n        // Return result instead of emitting event\n        TradeDealParticipantResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.participant = participant;\n        return result;\n    }\n    \n    function _isTradeDealParticipant(uint256 tradeDealId, address user) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // First check if the user is explicitly added as a participant\n        if (tds.tradeDealParticipants[tradeDealId][user]) {\n            return true;\n        }\n        \n        // If no required claim topics are set, only explicit participants are allowed\n        if (tds.tradeDealRequiredClaimTopics[tradeDealId].length == 0) {\n            return false;\n        }\n        \n        // Check if the user has any of the required claim topics\n        address identityAddress = ds.identities[user];\n        if (identityAddress == address(0)) {\n            return false; // User has no identity\n        }\n        \n        // Get the user's claims\n        uint256[] storage userClaims = ds.claimList[identityAddress];\n        \n        // Check if the user has any of the required claim topics\n        uint256 requiredClaimTopicsLength = tds.tradeDealRequiredClaimTopics[tradeDealId].length;\n        for (uint256 i = 0; i < requiredClaimTopicsLength; i++) {\n            uint256 requiredClaimTopic = tds.tradeDealRequiredClaimTopics[tradeDealId][i];\n            \n            for (uint256 j = 0; j < userClaims.length; j++) {\n                if (userClaims[j] == requiredClaimTopic) {\n                    return true; // User has a required claim\n                }\n            }\n        }\n        \n        return false; // User has no required claims\n    }\n    \n    // Return struct for invoice management functions\n    struct InvoiceActionResult {\n        uint256 tradeDealId;\n        uint256 tokenId;\n    }\n    \n    // Invoice management for trade deals\n    function _depositInvoiceToTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        \n        // Use the Diamond's ERC721PermissionedTokenFacet to transfer the NFT\n        // This bypasses the need for approval\n        bytes memory emptyData = \"\";\n        IERC721Permissioned(address(this)).forcedTransfer(\n            msg.sender,\n            address(this),\n            tokenId,\n            emptyData\n        );\n        \n        // Track the invoice in this trade deal\n        tds.tradeDealInvoices[tradeDealId].push(tokenId);\n        // Record the original depositor of this invoice\n        tds.invoiceDepositors[tradeDealId][tokenId] = msg.sender;\n        \n        // Get the totalAmount from the NFT and set it as the funding target\n        uint256 totalAmount = _getNFTInvoiceTotalAmount(tokenId);\n        tds.tradeDealFundingTargets[tradeDealId] += totalAmount;\n        \n        // Return result instead of emitting event\n        InvoiceActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.tokenId = tokenId;\n        return result;\n    }\n\n    function _withdrawInvoiceFromTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // Verify that the NFT is owned by this contract\n        require(IERC721(address(this)).ownerOf(tokenId) == address(this), \"NFT not owned by this contract\");\n        \n        // Check if the caller is the original depositor of this invoice\n        require(\n            tds.invoiceDepositors[tradeDealId][tokenId] == msg.sender ||\n            msg.sender == LibDiamond.contractOwner(),\n            \"Only the original depositor or contract owner can withdraw this invoice\"\n        );\n        \n        // Remove the invoice from this trade deal's tracking\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        bool found = false;\n        uint256 invoicesLength = invoices.length;\n        for (uint256 i = 0; i < invoicesLength; i++) {\n            if (invoices[i] == tokenId) {\n                // Remove by swapping with the last element and popping\n                invoices[i] = invoices[invoices.length - 1];\n                invoices.pop();\n                found = true;\n                break;\n            }\n        }\n        \n        require(found, \"Invoice not found in this trade deal\");\n\n        // *** FIX: Decrease funding target when invoice is withdrawn ***\n        uint256 invoiceAmount = _getNFTInvoiceTotalAmount(tokenId);\n        if (tds.tradeDealFundingTargets[tradeDealId] >= invoiceAmount) {\n             tds.tradeDealFundingTargets[tradeDealId] -= invoiceAmount;\n        } else {\n            // Avoid underflow if target is somehow already less than amount (shouldn't happen)\n            tds.tradeDealFundingTargets[tradeDealId] = 0;\n        }\n        // *** END FIX ***\n\n        // Use forcedTransfer to transfer the NFT back to the sender\n        // This bypasses the need for approval\n        bytes memory emptyData = \"\";\n        IERC721Permissioned(address(this)).forcedTransfer(\n            address(this),\n            msg.sender,\n            tokenId,\n            emptyData\n        );\n\n        // Clean up the depositor tracking\n        delete tds.invoiceDepositors[tradeDealId][tokenId];\n        \n        // Return result instead of emitting event\n        InvoiceActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.tokenId = tokenId;\n        return result;\n    }\n    \n    // Return struct for USDC management functions\n    struct USDCActionResult {\n        uint256 tradeDealId;\n        uint256 amount;\n        bool isFullyFunded;\n        uint256 fundingTarget;\n    }\n    \n    // USDC management for trade deals\n    function _depositUSDCToTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.usdcAddress != address(0), \"Trade deal USDC address not set\");\n        \n        // Get funding target and current balance\n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\n        uint256 currentBalance = tds.tradeDealUsdcBalances[tradeDealId];\n        \n        // If funding target exists, check that deposit won't exceed it\n        if (fundingTarget > 0) {\n            uint256 remainingToFund = fundingTarget > currentBalance ?\n                fundingTarget - currentBalance : 0;\n                \n            require(amount <= remainingToFund, \"Amount exceeds remaining funding needed\");\n        }\n        \n        // Log the depositor address and amount\n        address depositor = msg.sender;\n        \n        // Use the USDC token's transferFrom method to transfer tokens from the sender to this contract\n        IERC20(tradeDeal.usdcAddress).safeTransferFrom(depositor, address(this), amount);\n        \n        // Track the amount in this trade deal\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Explicitly add the depositor as a participant in the trade deal\n        // This ensures they can receive Collateral tokens\n        if (!_isTradeDealParticipant(tradeDealId, depositor)) {\n            _addTradeDealParticipant(tradeDealId, depositor);\n        }\n        \n        // If the trade deal has a Collateral token, mint Collateral tokens to the depositor\n        if (tradeDeal.collateralAddress != address(0)) {\n            // Get the Collateral token contract\n            address collateralToken = tradeDeal.collateralAddress;\n            \n            // Force the trade deal to be active during minting\n            bool wasActive = tradeDeal.active;\n            tradeDeal.active = true;\n            \n            // Try to mint Collateral tokens to the depositor\n            // We need to make sure the depositor is added as a participant first\n            // This is done by the _addTradeDealParticipant call above\n            \n            // Adjust for the difference in decimals between USDC (6) and Collateral (18)\n            // Multiply by 10^12 to convert from USDC decimals to Collateral decimals\n            uint256 adjustedAmount = amount * 1000000000000; // 10^12\n\n            // Attempt to mint Collateral tokens; will revert if it fails\n            ICollateral(collateralToken).mint(depositor, adjustedAmount);\n            // *** END FIX ***\n            \n            // Restore the original active state\n            tradeDeal.active = wasActive;\n        }\n        \n        // Check if this deposit completes the funding\n        if (fundingTarget > 0 && currentBalance + amount >= fundingTarget) {\n            // Calculate total debt including interest\n            uint256 interest = (fundingTarget * tradeDeal.interestRate) / 10000;\n            tds.tradeDealTotalDebt[tradeDealId] = fundingTarget + interest;\n            \n            // Track if funding was completed for the result\n        }\n        \n        // Return result instead of emitting events\n        USDCActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.amount = amount;\n        result.isFullyFunded = (fundingTarget > 0 && currentBalance + amount >= fundingTarget);\n        result.fundingTarget = fundingTarget;\n        return result;\n    }\n    \n    function _withdrawUSDCFromTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDealUsdcBalances[tradeDealId] >= amount, \"Insufficient USDC balance in trade deal\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.usdcAddress != address(0), \"Trade deal USDC address not set\");\n        \n        // Use the USDC token's transfer method to transfer tokens from this contract to the sender\n        require(IERC20(tradeDeal.usdcAddress).transfer(msg.sender, amount), \"USDC transfer failed\");\n        \n        // Update the amount in this trade deal\n        tds.tradeDealUsdcBalances[tradeDealId] -= amount;\n        \n        // Return result instead of emitting event\n        USDCActionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.amount = amount;\n        result.isFullyFunded = false; // Not applicable for withdrawal\n        result.fundingTarget = 0;     // Not applicable for withdrawal\n        return result;\n    }\n    \n    // Return struct for interest distribution\n    struct InterestDistributionResult {\n        uint256 tradeDealId;\n        uint256 totalInterest;\n        uint256 invoicePoolInterest;\n        uint256 interestInterest;\n        uint256 interestTokensMinted;\n    }\n    \n    // Interest distribution for a specific trade deal\n    // This function is kept for backward compatibility but is simplified to avoid VABI token complexity\n    function _distributeInterestForTradeDeal(uint256 tradeDealId) internal view returns (InterestDistributionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        \n        // Note: Interest calculation is now handled during funding completion and repayment processes\n        // This function is maintained for backward compatibility\n        \n        // We'll calculate interest but won't do anything with it\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        uint256 balance = tds.tradeDealUsdcBalances[tradeDealId];\n        uint256 interest = (balance * tradeDeal.interestRate) / 10000;\n        \n        // Return result instead of emitting event\n        InterestDistributionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.totalInterest = interest;\n        result.invoicePoolInterest = interest; // All interest goes to the trade deal now\n        result.interestInterest = 0;               // No VABI interest\n        result.interestTokensMinted = 0;           // No VABI tokens minted\n        \n        return result;\n    }\n    \n    // Get USDC balance for a specific trade deal\n    function _getUSDCBalanceForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealUsdcBalances[tradeDealId];\n    }\n    \n    // Get invoice count for a specific trade deal\n    function _getInvoiceCountForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealInvoices[tradeDealId].length;\n    }\n    \n    // Get invoice token ID for a specific trade deal\n    function _getInvoiceTokenIdForTradeDeal(uint256 tradeDealId, uint256 index) internal view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(index < tds.tradeDealInvoices[tradeDealId].length, \"Index out of bounds\");\n        \n        return tds.tradeDealInvoices[tradeDealId][index];\n    }\n    \n    // Return struct for setting required claim topics\n    struct ClaimTopicsResult {\n        uint256 tradeDealId;\n        uint256[] claimTopics;\n    }\n    \n    // Set required claim topics for a trade deal\n    function _setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) internal returns (ClaimTopicsResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        // Clear existing claim topics\n        delete tds.tradeDealRequiredClaimTopics[tradeDealId];\n        delete tds.tradeDeals[tradeDealId].requiredClaimTopics;\n        \n        // Set new claim topics\n        uint256 claimTopicsLength = claimTopics.length;\n        for (uint256 i = 0; i < claimTopicsLength; i++) {\n            tds.tradeDealRequiredClaimTopics[tradeDealId].push(claimTopics[i]);\n            tds.tradeDeals[tradeDealId].requiredClaimTopics.push(claimTopics[i]);\n        }\n        \n        // Return result instead of emitting event\n        ClaimTopicsResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.claimTopics = claimTopics;\n        return result;\n    }\n    \n    // Get required claim topics for a trade deal\n    function _getTradeDealRequiredClaimTopics(uint256 tradeDealId) internal view returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        return tds.tradeDealRequiredClaimTopics[tradeDealId];\n    }\n    \n    // Check if a trade deal is fully funded\n    function _isTradeDealFunded(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\n        if (fundingTarget == 0) {\n            return false; // No funding target set\n        }\n        \n        return tds.tradeDealUsdcBalances[tradeDealId] >= fundingTarget;\n    }\n    \n    // Check if a trade deal is fully repaid\n    function _isTradeDealRepaid(uint256 tradeDealId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        if (totalDebt == 0) {\n            return false; // No debt established yet\n        }\n        \n        return tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt;\n    }\n    \n    // Return struct for funding withdrawal\n    struct FundingWithdrawalResult {\n        uint256 tradeDealId;\n        address recipient;\n        uint256 amount;\n    }\n    \n    // Allow fundees to withdraw USDC funding\n    function _withdrawTradeDealFunding(uint256 tradeDealId, address borrowerAddress) internal returns (FundingWithdrawalResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(_isTradeDealFunded(tradeDealId), \"Trade deal is not fully funded\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        require(borrowerAddress != address(0), \"Borrower address cannot be zero\"); // Added check\n        \n        // Verify caller has deposited invoices as collateral\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        require(invoices.length > 0, \"No invoices deposited as collateral\");\n        \n        // Get token addresses\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Get the funding amount\n        uint256 fundingAmount = tds.tradeDealFundingTargets[tradeDealId];\n        \n        // Mark as withdrawn\n        tds.tradeDealFundingWithdrawn[tradeDealId] = true;\n        \n        // Distribute USDC via FeeDistributor: fees to receivers, adjusted principal to borrower\n        IFeeDistributor feeDistributor = IFeeDistributor(address(this));\n        (address adjustedReceiver, uint256 adjustedAmount, , ) = feeDistributor.distributeAmounts(borrowerAddress, fundingAmount);\n        require(adjustedReceiver == borrowerAddress, \"FeeDistributor: Adjusted amount sent to wrong receiver\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= fundingAmount;\n        \n        // Return result instead of emitting event\n        FundingWithdrawalResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.recipient = borrowerAddress; // Recipient is the borrower\n        result.amount = adjustedAmount;    // Amount is the adjusted principal received\n        return result;\n    }\n    \n    // Return struct for debt repayment\n    struct RepaymentResult {\n        uint256 tradeDealId;\n        address repayer;\n        uint256 amount;\n        bool fullyRepaid;\n    }\n    \n    // Allow fundees to repay their debt\n    function _repayTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (RepaymentResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding not yet withdrawn\");\n        \n        // Calculate remaining debt\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        uint256 repaidSoFar = tds.tradeDealRepaidAmounts[tradeDealId];\n        uint256 remainingDebt = totalDebt > repaidSoFar ? totalDebt - repaidSoFar : 0;\n        \n        require(remainingDebt > 0, \"No remaining debt to repay\");\n        require(amount <= remainingDebt, \"Amount exceeds remaining debt\");\n        \n        // Get USDC token\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Transfer USDC from repayer to contract\n        IERC20(usdcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Update repaid amount\n        tds.tradeDealRepaidAmounts[tradeDealId] += amount;\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Check if fully repaid\n        bool fullyRepaid = (tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt);\n        \n        // Return result instead of emitting event\n        RepaymentResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.repayer = msg.sender;\n        result.amount = amount;\n        result.fullyRepaid = fullyRepaid;\n        return result;\n    }\n\n    function _repayTradeDealForBorrower(uint256 tradeDealId, address borrower, uint256 amount) internal returns (RepaymentResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(tds.tradeDeals[tradeDealId].active, \"Trade deal is not active\");\n        require(tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding not yet withdrawn\");\n        \n        // Calculate remaining debt\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\n        uint256 repaidSoFar = tds.tradeDealRepaidAmounts[tradeDealId];\n        uint256 remainingDebt = totalDebt > repaidSoFar ? totalDebt - repaidSoFar : 0;\n        \n        require(remainingDebt > 0, \"No remaining debt to repay\");\n        require(amount <= remainingDebt, \"Amount exceeds remaining debt\");\n        \n        // Get USDC token\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Transfer USDC from borrower to contract\n        IERC20(usdcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Update repaid amount\n        tds.tradeDealRepaidAmounts[tradeDealId] += amount;\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\n        \n        // Check if fully repaid\n        bool fullyRepaid = (tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt);\n\n        // Return result instead of emitting event\n        RepaymentResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.repayer = borrower;\n        result.amount = amount;\n        result.fullyRepaid = fullyRepaid;\n    \n        return result;\n    }\n    \n    // Check if a user has a valid Collateral token balance for the trade deal\n    function _hasCollateralTokenBalance(uint256 tradeDealId, address user, uint256 requiredAmount) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address collateralToken = tradeDeal.collateralAddress;\n        \n        if (collateralToken == address(0)) return false;\n        \n        uint256 collateralBalance = ICollateral(collateralToken).balanceOf(user);\n        return collateralBalance >= requiredAmount;\n    }\n    \n    // Allow funders to redeem their Collateral tokens\n    function _redeemCollateralTokens(uint256 tradeDealId, uint256 collateralAmount) internal returns (CollateralRedemptionResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(_isTradeDealRepaid(tradeDealId), \"Trade deal not fully repaid\");\n        \n        // Get token addresses\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        address collateralToken = tradeDeal.collateralAddress;\n        address usdcToken = tradeDeal.usdcAddress;\n        require(collateralToken != address(0), \"Collateral token address not set\");\n        require(usdcToken != address(0), \"USDC token address not set\");\n        \n        // Check Collateral balance\n        uint256 collateralBalance = ICollateral(collateralToken).balanceOf(msg.sender);\n        require(collateralBalance >= collateralAmount, \"Insufficient Collateral balance\");\n        \n        // Calculate proportional USDC amount\n        uint256 totalCollateralSupply = ICollateral(collateralToken).totalSupply();\n        require(totalCollateralSupply > 0, \"No Collateral tokens in circulation\");\n        \n        uint256 usdcBalance = tds.tradeDealUsdcBalances[tradeDealId];\n        uint256 usdcAmount = (usdcBalance * collateralAmount) / totalCollateralSupply;\n        \n        require(usdcAmount > 0, \"Calculated USDC amount is zero\");\n        require(usdcBalance >= usdcAmount, \"Insufficient USDC balance in trade deal\");\n        \n        // Burn Collateral tokens\n        ICollateral(collateralToken).burn(msg.sender, collateralAmount);\n        \n        // Transfer USDC to redeemer\n        require(IERC20(usdcToken).transfer(msg.sender, usdcAmount), \"USDC transfer failed\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= usdcAmount;\n        \n        // Return result instead of emitting event\n        CollateralRedemptionResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.redeemer = msg.sender;\n        result.collateralAmount = collateralAmount;\n        result.usdcAmount = usdcAmount;\n        return result;\n    }\n    \n    // Role-based access control functions\n    \n    /**\n     * @notice Set a user's role for a specific trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param role The role to assign\n     */\n    function _setUserRole(uint256 tradeDealId, address user, Role role) internal {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        require(user != address(0), \"Invalid user address\");\n        \n        tds.userRoles[tradeDealId][user] = role;\n        \n        // If user is being set as a borrower, also add them as a participant\n        if (role == Role.BORROWER && !tds.tradeDealParticipants[tradeDealId][user]) {\n            tds.tradeDealParticipants[tradeDealId][user] = true;\n        }\n    }\n    \n    /**\n     * @notice Check if a user has a specific role in a trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param role The role to check\n     * @return True if the user has the role, false otherwise\n     */\n    function _hasRole(uint256 tradeDealId, address user, Role role) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        if (!_tradeDealExists(tradeDealId)) return false;\n        if (user == address(0)) return false;\n        \n        // Contract owner is always considered to have ADMIN role\n        if (role == Role.ADMIN && user == LibDiamond.contractOwner()) return true;\n        \n        return tds.userRoles[tradeDealId][user] == role;\n    }\n    \n    /**\n     * @notice Check if a user has a specific permission in a trade deal\n     * @param tradeDealId The ID of the trade deal\n     * @param user The address of the user\n     * @param permission The permission to check\n     * @return True if the user has the permission, false otherwise\n     */\n    function _hasPermission(uint256 tradeDealId, address user, uint256 permission) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        if (!_tradeDealExists(tradeDealId)) return false;\n        if (user == address(0)) return false;\n        \n        // Contract owner always has all permissions\n        if (user == LibDiamond.contractOwner()) return true;\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        \n        // Check operation mode defaults\n        if (tradeDeal.operationMode == OperationMode.CENTRALIZED) {\n            // In centralized mode, only contract owner can withdraw funds\n            if (permission == PERMISSION_WITHDRAW_FUNDS) {\n                return user == LibDiamond.contractOwner();\n            }\n            \n            // Anyone can deposit funds or collateral in centralized mode\n            if (permission == PERMISSION_DEPOSIT_FUNDS || permission == PERMISSION_DEPOSIT_COLLATERAL) {\n                return true;\n            }\n        }\n        else if (tradeDeal.operationMode == OperationMode.SELF_SERVICE) {\n            // In self-service mode, borrowers can withdraw funds\n            if (permission == PERMISSION_WITHDRAW_FUNDS && _hasRole(tradeDealId, user, Role.BORROWER)) {\n                return true;\n            }\n            \n            // Anyone can deposit funds or collateral in self-service mode\n            if (permission == PERMISSION_DEPOSIT_FUNDS || permission == PERMISSION_DEPOSIT_COLLATERAL) {\n                return true;\n            }\n        }\n        \n        // For HYBRID and CUSTOM modes, check explicit permissions\n        return (tds.userPermissions[tradeDealId][user] & permission) != 0;\n    }\n    \n    /**\n     * @notice Extract the totalAmount from an NFT invoice metadata\n     * @param tokenId The token ID of the NFT invoice\n     * @return The totalAmount value from the metadata, or 0 if not found\n     */\n    function _getNFTInvoiceTotalAmount(uint256 tokenId) internal view returns (uint256) {\n        // Check if this token exists\n        require(IERC721(address(this)).ownerOf(tokenId) != address(0), \"Token does not exist\");\n        \n        // Get the totalAmount attribute using AttributeLib\n        AttributeStorage storage attributeStore = AttributeLib.attributeStorage();\n        AttributeContract storage attributeContract = attributeStore.attributes;\n        \n        // Try to get the \"totalAmount\" attribute\n        Attribute memory totalAmountAttr = AttributeLib._getAttribute(\n            attributeContract,\n            tokenId,\n            \"totalAmount\"\n        );\n        \n        // If the attribute exists and has a value, convert it to uint256\n        if (bytes(totalAmountAttr.value).length > 0) {\n            // Convert string to uint256\n            uint256 amount = _stringToUint(totalAmountAttr.value);\n            return amount;\n        }\n        \n        // Fallback logic - if totalAmount attribute is not found, check if there's an \"amount\" attribute\n        Attribute memory amountAttr = AttributeLib._getAttribute(\n            attributeContract,\n            tokenId,\n            \"amount\"\n        );\n        \n        if (bytes(amountAttr.value).length > 0) {\n            uint256 amount = _stringToUint(amountAttr.value);\n            return amount;\n        }\n        \n        // If no attributes found, return 0\n        return 0;\n    }\n    \n    /**\n     * @notice Helper function to convert a string to uint256\n     * @param s The string to convert\n     * @return result The converted uint256 value\n     */\n    function _stringToUint(string memory s) internal pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n        return result;\n    }\n    \n    // Return struct for self-service funding withdrawal\n    struct SelfServiceWithdrawalResult {\n        uint256 tradeDealId;\n        address recipient;\n        uint256 amount;\n    }\n    \n    /**\n     * @notice Allow borrowers to withdraw funds in self-service mode\n     * @param tradeDealId The ID of the trade deal\n     * @param borrower The address of the borrower\n     * @return Result struct with withdrawal details\n     */\n    function _withdrawTradeDealFundingSelf(uint256 tradeDealId, address borrower) internal returns (FundingWithdrawalResult memory) {\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\n        TradeDealStorage storage tds = ds.tradeDealStorage;\n        \n        require(_tradeDealExists(tradeDealId), \"Trade deal does not exist\");\n        \n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\n        require(tradeDeal.active, \"Trade deal is not active\");\n        require(tradeDeal.operationMode == OperationMode.SELF_SERVICE, \"Trade deal is not in self-service mode\");\n        require(_isTradeDealFunded(tradeDealId), \"Trade deal is not fully funded\");\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \"Funding already withdrawn\");\n        \n        // Check if borrower is a participant and has the BORROWER role\n        require(_isTradeDealParticipant(tradeDealId, borrower), \"Not a participant in this trade deal\");\n        require(_hasRole(tradeDealId, borrower, Role.BORROWER), \"Must have borrower role to withdraw funds\");\n        \n        // Verify the borrower has deposited invoices as collateral\n        bool hasDepositedInvoice = false;\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\n        for (uint256 i = 0; i < invoices.length; i++) {\n            if (tds.invoiceDepositors[tradeDealId][invoices[i]] == borrower) {\n                hasDepositedInvoice = true;\n                break;\n            }\n        }\n        require(hasDepositedInvoice, \"Borrower has not deposited any invoices\");\n        \n        // Get token addresses\n        address usdcToken = tradeDeal.usdcAddress;\n        require(usdcToken != address(0), \"Trade deal USDC address not set\");\n        \n        // Get the funding amount\n        uint256 fundingAmount = tds.tradeDealFundingTargets[tradeDealId];\n        \n        // Mark as withdrawn\n        tds.tradeDealFundingWithdrawn[tradeDealId] = true;\n        \n        // Distribute USDC via FeeDistributor: fees to receivers, adjusted principal to borrower\n        IFeeDistributor feeDistributor = IFeeDistributor(address(this));\n        (address adjustedReceiver, uint256 adjustedAmount, , ) = feeDistributor.distributeAmounts(borrower, fundingAmount);\n        require(adjustedReceiver == borrower, \"FeeDistributor: Adjusted amount sent to wrong receiver\");\n        \n        // Update USDC balance\n        tds.tradeDealUsdcBalances[tradeDealId] -= fundingAmount;\n        \n        // Return result\n        FundingWithdrawalResult memory result;\n        result.tradeDealId = tradeDealId;\n        result.recipient = borrower;\n        result.amount = adjustedAmount; // Amount is the adjusted principal received\n        return result;\n    }\n\n    // Helper function to create or get a Collateral token for a trade deal\n    function _createOrGetCollateralToken(uint256 tradeDealId, string memory symbol) internal returns (address) {\n        address collateralAddress = address(0);\n        \n        // First try to get the Collateral token address from the CollateralTokenFactoryFacet\n        (bool checkSuccess, bytes memory checkData) = address(this).staticcall(\n            abi.encodeWithSignature(\n                \"getCollateralTokenAddress(uint256)\",\n                tradeDealId\n            )\n        );\n        \n        // If the check was successful and returned a non-zero address, use that\n        if (checkSuccess && checkData.length > 0) {\n            address existingCollateralAddress = abi.decode(checkData, (address));\n            if (existingCollateralAddress != address(0)) {\n                return existingCollateralAddress;\n            }\n        }\n        \n        // If we still don't have a Collateral token address, try to create one\n        string memory tokenName = string(abi.encodePacked(symbol, \"-C\"));\n        string memory tokenSymbol = string(abi.encodePacked(symbol, \"-C\"));\n\n        // Call the CollateralTokenFactoryFacet to create a new Collateral token\n        (bool success, bytes memory data) = address(this).call(\n            abi.encodeWithSignature(\n                \"createCollateralToken(uint256,string,string,bool)\",\n                tradeDealId,\n                tokenName,\n                tokenSymbol,\n                true // Enable restrictions by default\n            )\n        );\n        \n        // If the call was successful, use the returned token address\n        if (success && data.length > 0) {\n            collateralAddress = abi.decode(data, (address));\n        }\n        \n        // If we still don't have a Collateral token address, try to get it again\n        if (collateralAddress == address(0)) {\n            (bool retrySuccess, bytes memory retryData) = address(this).staticcall(\n                abi.encodeWithSignature(\n                    \"getCollateralTokenAddress(uint256)\",\n                    tradeDealId\n                )\n            );\n            \n            // If the retry was successful and returned a non-zero address, use that\n            if (retrySuccess && retryData.length > 0) {\n                address retryCollateralAddress = abi.decode(retryData, (address));\n                if (retryCollateralAddress != address(0)) {\n                    collateralAddress = retryCollateralAddress;\n                }\n            }\n        }\n        \n        return collateralAddress;\n    }\n}\n"
    },
    "contracts/libraries/UInt256Set.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary UInt256Set {\n    struct Set {\n        mapping(uint256 => uint256) keyPointers;\n        uint256[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, uint256 key) public {\n        require(\n            !exists(self, key),\n            \"UInt256Set: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, uint256 key) public {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"UInt256Set: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            uint256 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) public view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, uint256 key)\n        public\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "contracts/libraries/VariablePriceLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IVariablePrice.sol\";\n\nlibrary VariablePriceLib {\n    event VariablePriceChanged(\n        address eventContract,\n        VariablePriceContract price\n    );\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.nextblock.bitgem.app.VariablePriceStorage.storage\");\n\n    /// @notice get the storage for variable pricing\n    /// @return ds the storage\n    function variablePriceStorage()\n        internal\n        pure\n        returns (VariablePriceStorage storage ds) {\n\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice update the variable price contract\n    /// @param self the variable price contract\n    function _updatePrice(VariablePriceContract storage self)\n        internal\n        returns (uint256 _price, uint256 updatedPrice) {\n\n        _price = self.price;\n        _increaseClaimPrice(self);\n        updatedPrice = self.price;\n    }\n\n    /// @notice get the current price of the claim\n    /// @return _price the current price of the claim\n    function _currentPrice(VariablePriceContract storage self)\n        internal\n        view\n        returns (uint256 _price) {\n\n        _price = self.price;\n    }\n\n    function _setPrice(VariablePriceContract storage self, uint256 _price)\n        internal\n        returns (uint256 _newPrice) {\n\n        self.price = _price;\n        _newPrice = self.price;\n    }\n    \n    /// @notice Increases the price of the claim by the price increase rate\n    /// @param self The variable price contract\n    function _increaseClaimPrice(VariablePriceContract storage self) internal {\n        \n        // get the current price\n        uint256 currentPrice = self.price;\n        // get the current modifier\n        PriceModifier currentModifier = self.priceModifier;\n        // get the current modifier factor\n        uint256 currentModifierFactor = self.priceModifierFactor;\n\n        // fixed price - increase by modifier factor\n        if (currentModifier == PriceModifier.Fixed) {\n            currentPrice = currentPrice + currentModifierFactor;\n        }\n        // exponential intcrease\n        else if (currentModifier == PriceModifier.Exponential) {\n            currentPrice =\n                currentPrice +\n                (currentPrice / currentModifierFactor);\n        }\n        // inverse log increase\n        else if (currentModifier == PriceModifier.InverseLog) {\n            currentPrice =\n                currentPrice +\n                (currentPrice / (currentModifierFactor * currentPrice));\n        } else {\n            return;\n        }\n        // set the new price\n        self.price = currentPrice;\n    }\n}\n"
    },
    "contracts/tokens/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract CollateralToken is ICollateral, ERC20, Ownable {\n\n    constructor() ERC20(\"Collateral Token\", \"Collateral\") Ownable(msg.sender) {}\n\n    function mint(address to, uint256 amount) external override onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external override onlyOwner {\n        _burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public override(ERC20,ICollateral) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override(ERC20,ICollateral) returns (bool) {\n        return super.transferFrom(from, to, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override(ERC20,ICollateral) returns (bool) {\n        return super.approve(spender, amount);\n    }\n\n    function allowance(address owner, address spender) public view override(ERC20,ICollateral) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n    function balanceOf(address account) public view override(ERC20,ICollateral) returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    function totalSupply() public view override(ERC20,ICollateral) returns (uint256) {\n        return super.totalSupply();\n    }\n}"
    },
    "contracts/tokens/CollateralTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./RestrictedCollateralToken.sol\";\n\n/**\n * @title CollateralTokenFactory\n * @dev Factory contract for creating new RestrictedCollateralToken instances using the minimal proxy pattern\n */\ncontract CollateralTokenFactory is Ownable {\n    // The implementation contract that will be cloned\n    address public implementation;\n    \n    // Mapping from trade deal ID to token address\n    mapping(uint256 => address) public tradeDealToToken;\n    \n    // Array of all created tokens\n    address[] public allTokens;\n    \n    // Event emitted when a new token is created\n    event TokenCreated(uint256 indexed tradeDealId, address indexed tokenAddress, string name, string symbol);\n    \n    /**\n     * @dev Constructor - sets the implementation contract\n     * @param _implementation The address of the implementation contract\n     */\n    constructor(address _implementation) Ownable(msg.sender) {\n        implementation = _implementation;\n    }\n    \n    /**\n     * @dev Set the implementation contract\n     * @param _implementation The address of the implementation contract\n     */\n    function setImplementation(address _implementation) external onlyOwner {\n        implementation = _implementation;\n    }\n    \n    /**\n     * @dev Create a new RestrictedCollateralToken\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     * @param _diamondAddress The address of the Diamond contract\n     * @param _tradeDealId The ID of the trade deal this token is associated with\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @return The address of the new token\n     */\n    function createToken(\n        string memory _name,\n        string memory _symbol,\n        address _diamondAddress,\n        uint256 _tradeDealId,\n        bool _restrictionsEnabled\n    ) external onlyOwner returns (address) {\n        // Check if a token already exists for this trade deal\n        require(tradeDealToToken[_tradeDealId] == address(0), \"CollateralTokenFactory: token already exists for this trade deal\");\n        \n        // Clone the implementation contract\n        address tokenAddress = Clones.clone(implementation);\n        \n        // Initialize the token\n        RestrictedCollateralToken(tokenAddress).initialize(\n            _name,\n            _symbol,\n            _diamondAddress,\n            _tradeDealId,\n            _restrictionsEnabled,\n            owner()\n        );\n        \n        // Store the token address\n        tradeDealToToken[_tradeDealId] = tokenAddress;\n        allTokens.push(tokenAddress);\n        \n        // Emit an event\n        emit TokenCreated(_tradeDealId, tokenAddress, _name, _symbol);\n        \n        return tokenAddress;\n    }\n    \n    /**\n     * @dev Get the token address for a trade deal\n     * @param _tradeDealId The ID of the trade deal\n     * @return The address of the token\n     */\n    function getTokenAddress(uint256 _tradeDealId) external view returns (address) {\n        return tradeDealToToken[_tradeDealId];\n    }\n    \n    /**\n     * @dev Get the number of tokens created\n     * @return The number of tokens\n     */\n    function getTokenCount() external view returns (uint256) {\n        return allTokens.length;\n    }\n    \n    /**\n     * @dev Get a token address by index\n     * @param _index The index of the token\n     * @return The address of the token\n     */\n    function getTokenByIndex(uint256 _index) external view returns (address) {\n        require(_index < allTokens.length, \"CollateralTokenFactory: index out of bounds\");\n        return allTokens[_index];\n    }\n}"
    },
    "contracts/tokens/ERC721/ERC721AFacet.sol": {
      "content": "  // SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../../libraries/ERC721ALib.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable indent */\n/* solhint-disable func-order */\ncontract ERC721AFacet is Context, Initializable, Modifiers {\n\n    using Address for address;\n    using Strings for uint256;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    event ERC721ATransfer(address indexed from, address indexed to, uint256 indexed tokenId, bytes data);\n\n    /// @dev See {IERC721Enumerable-totalSupply}.\n    function totalSupply() external view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.totalSupply();\n    }\n\n    /// @dev See {IERC721-balanceOf}.\n    function balanceOf(address owner) external view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.balanceOf(owner);\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.ownershipOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external {\n        address owner = ERC721AFacet.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (operator == _msgSender()) revert ApproveToCaller();\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage.\n            setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual {\n        _transfer(from, to, tokenId);\n        emit ERC721ATransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external virtual {\n        _transfer(from, to, tokenId);\n        emit ERC721ATransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\n            revert IdentitySystemStorage.TransferToNonERC721ReceiverImplementer();\n        }\n        emit ERC721ATransfer(from, to, tokenId, _data);\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, \n     * which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._mint(msg.sender, to, quantity, _data, safe);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._transfer(msg.sender, from, to, tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n       _storage._burn(_storage._ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage.erc721Contract._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address().\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        return IdentitySystemStorage._checkOnERC721Received(msg.sender, from, to, tokenId, _data);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256\n    ) internal virtual {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._beforeTokenTransfer(from, to, tokenId, true);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._afterTokenTransfer(from, to, tokenId, 1);\n    }\n}\n"
    },
    "contracts/tokens/ERC721/ERC721AMetadataFacet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../../libraries/LibDiamond.sol\";\nimport \"../../libraries/MetadataLib.sol\";\nimport \"../../libraries/AttributeLib.sol\";\nimport \"../../libraries/DiamondLib.sol\";\nimport \"../../libraries/ERC721ALib.sol\";\nimport \"../../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable indent */\n\ncontract ERC721AMetadataFacet is Modifiers {\n\n\n    event ContractMetadataSet(string key, Attribute value);\n    event TokenMetadataSet(uint256 indexed tokenId, string key, Attribute value);\n    event ContractMetadataDeleted(string key);\n    event TokenMetadataDeleted(uint256 indexed tokenId, string key);\n\n\n    using MetadataLib for MetadataContract;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n    using Strings for uint256;\n\n    function setMetadata(MetadataContract memory _contract) external {\n\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata.setMetadata(_contract);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() external view returns (string memory) {\n\n        // solhint-disable-next-lsine\n        return MetadataLib.metadataStorage().metadata.name();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.symbol();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function description() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.description();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function image() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.image();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function externalUri() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata._externalUri;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function baseUri() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata._externalUri;\n    }\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();    \n        if (!identitySystem._exists(tokenId)) revert URIQueryForNonexistentToken();\n        \n        MetadataContract storage metadata = MetadataLib.metadataStorage().metadata;\n        if(metadata._metadataSource == MetadataSource.EXTERNAL) {\n            return string(\n                abi.encodePacked(\n                    metadata._baseUri, \n                    uint256(uint160(address(this))).toHexString(),\n                    \"/\",\n                    tokenId.toString())\n                );\n        } else {\n            AttributeContract storage attributes = AttributeLib.attributeStorage().attributes;\n            DiamondContract storage diamond = DiamondLib.diamondStorage().diamondContract;\n            return metadata.tokenURI(diamond, attributes, tokenId);\n        }\n    }\n\n    function setMetadataSource(MetadataSource _source) external {\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata._setMetadataSource(_source);\n    }\n\n    function setBaseUri(string memory _baseUri) external {\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata._setBaseURI(_baseUri);\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts().\n     */\n    function contractURI() external view returns (string memory) {\n\n        MetadataContract storage metadata = MetadataLib.metadataStorage().metadata;\n        Trait[] memory dum;\n        if(metadata._metadataSource == MetadataSource.EXTERNAL) {\n            return string(\n                abi.encodePacked(\n                    metadata._baseUri, \n                    uint256(uint160(address(this))).toHexString())\n                );\n        } else {\n            (, string memory svg) = metadata.getContractImage();\n            string memory json = Base64.encode(\n                bytes(\n                    metadata.getTokenMetadata(dum, svg)\n                )\n            );\n            return string(abi.encodePacked(\"data:application/json;base64,\", json));\n        }\n\n    }\n\n        // Functions for managing metadata\n    function setContractMetadata(string memory key, Attribute memory value) external onlyOwner {\n        AttributeLib._setAttribute(AttributeLib.attributeStorage().attributes, 0, value);\n        emit ContractMetadataSet(key, value);\n    }\n\n    function setTokenMetadata(uint256 tokenId, Attribute memory value) external onlyOwner {\n        require(tokenId > 0, \"Invalid tokenId\");\n        AttributeLib._setAttribute(AttributeLib.attributeStorage().attributes, tokenId, value);\n        emit TokenMetadataSet(tokenId, value.key, value);\n    }\n\n    function getContractMetadata(string memory key) external view returns (Attribute memory) {\n        return AttributeLib._getAttribute(AttributeLib.attributeStorage().attributes, 0, key);\n    }\n\n    function getTokenMetadata(uint256 tokenId, string memory key) external view returns (Attribute memory) {\n        require(tokenId > 0, \"Invalid tokenId\");\n        return AttributeLib._getAttribute(AttributeLib.attributeStorage().attributes, tokenId, key);\n    }\n\n    function deleteContractMetadata(string memory key) external onlyOwner {\n        AttributeLib._removeAttribute(AttributeLib.attributeStorage().attributes, 0, key);\n        emit ContractMetadataDeleted(key);\n    }\n\n    function deleteTokenMetadata(uint256 tokenId, string memory key) external onlyOwner {\n        require(tokenId > 0, \"Invalid tokenId\");\n        AttributeLib._removeAttribute(AttributeLib.attributeStorage().attributes, tokenId, key);\n        emit TokenMetadataDeleted(tokenId, key);\n    }\n\n    function getContractKeys() external view returns (string[] memory) {\n        return AttributeLib._getAttributeKeys(AttributeLib.attributeStorage().attributes, 0);\n    }\n\n    function getTokenKeys(uint256 tokenId) external view returns (string[] memory) {\n        require(tokenId > 0, \"Invalid tokenId\");\n        return AttributeLib._getAttributeKeys(AttributeLib.attributeStorage().attributes, tokenId);\n    }\n\n    function getAllTokenMetadata(uint256 tokenId) external view returns (string[] memory keys, string[] memory values) {\n        require(tokenId > 0, \"Invalid tokenId\");\n        keys = AttributeLib._getAttributeKeys(AttributeLib.attributeStorage().attributes, tokenId);\n        values = AttributeLib._getAttributeValues(tokenId);\n    }\n\n    function getAllContractMetadata() external view returns (string[] memory keys, string[] memory values) {\n        keys = AttributeLib._getAttributeKeys(AttributeLib.attributeStorage().attributes, 0);\n        values = AttributeLib._getAttributeValues(0);\n    }\n\n\n}\n"
    },
    "contracts/tokens/ERC721/ERC721EnumerableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\npragma solidity ^0.8.6;\n\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../../identity/IdentityStorage.sol\";\nimport \"../../libraries/ERC721AEnumerationLib.sol\";\nimport \"../../interfaces/IERC721Enumerable.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\ncontract ERC721EnumerableFacet is Modifiers {\n\n    using ERC721AEnumerationLib for ERC721EnumerableContract;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    // Removed tokenOfOwnerByIndex and tokenByIndex to resolve selector conflicts.\n    // These functions are provided by ERC721PermissionedTokenFacet.\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._removeTokenFromOwnerEnumeration(from, tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage._removeTokenFromAllTokensEnumeration(tokenId);\n    }\n    \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        if (from == address(0)) {\n            _storage._addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _storage._removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _storage._removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _storage._addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n}\n"
    },
    "contracts/tokens/ERC721/ERC721MinterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../../interfaces/IERC721Mint.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\nimport \"../../libraries/UInt256Set.sol\";\nimport \"../../libraries/ERC721ALib.sol\";\n\ncontract ERC721MinterFacet is Modifiers, IERC721Mint {\n\n    using UInt256Set for UInt256Set.Set;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    event ERC721Minted(address indexed to, uint256 indexed tokenId, bytes data);\n    event ERC721BatchMinted(address indexed to, uint256[] indexed tokenIds, bytes data);\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mint(\n        uint256 quantity,\n        bytes memory data\n    ) external override onlyOwner returns (uint256) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        ERC721AContract storage ds = _storage.erc721Contract;\n        _storage._mint(\n            address(this),\n            address(this),\n            quantity,\n            data,\n            true\n        );\n        emit ERC721Minted(address(this), quantity, data);\n        return  ds._currentIndex - 1;\n    }\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param receiver the mint target\n    function mintTo(\n        address receiver,\n        uint256 quantity,\n        bytes memory data\n    ) external override onlyOwner returns (uint256 tokenId) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        ERC721AContract storage ds = _storage.erc721Contract;\n        _storage._mint(\n            address(this),\n            receiver,\n            quantity,   \n            data,\n            true\n        );\n        emit ERC721Minted(receiver, quantity, data);\n        return ds._currentIndex - 1;\n    }\n\n}\n"
    },
    "contracts/tokens/ERC721/ERC721PermissionedTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\nimport {ERC721AFacet} from \"./ERC721AFacet.sol\";\nimport {IERC721Mint} from \"../../interfaces/IERC721Mint.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IIdentityRegistry} from \"../../interfaces/IIdentityRegistry.sol\";\nimport {Modifiers} from \"../../utilities/Modifiers.sol\";\nimport {IERC721Permissioned} from \"../../interfaces/IERC721Permissioned.sol\";\nimport {IClaimTopicsRegistry} from \"../../interfaces/IClaimTopicsRegistry.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../../interfaces/IERC721A.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IdentitySystemStorage} from \"../../identity/IdentityStorage.sol\";\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract ERC721PermissionedTokenFacet is\n    Context,\n    Initializable,\n    Modifiers,\n    IERC721Permissioned\n{\n    using Address for address;\n    using Strings for uint256;\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    event ERC721ATransfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId,\n        bytes data\n    );\n\n    /// @dev See {IERC721Enumerable-totalSupply}.\n    function totalSupply() external view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.totalSupply();\n    }\n\n    /// @dev See {IERC721-balanceOf}.\n    function balanceOf(address owner) external view returns (uint256) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.balanceOf(owner);\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function ownershipOf(\n        uint256 tokenId\n    ) internal view returns (TokenOwnership memory) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.ownershipOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public virtual view returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external {\n        address owner = ownerOf(tokenId);\n        if (to == owner) revert IdentitySystemStorage.ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert IdentitySystemStorage.ApprovalCallerNotOwnerNorApproved();\n        }\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (operator == _msgSender())\n            revert IdentitySystemStorage.ApproveToCaller();\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage.setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) public view virtual returns (bool) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        external\n        virtual\n        unfrozenTokenOnly(tokenId)\n        registeredSenderOnly(to)\n        registeredAddressOnly(to)\n    {\n        _transfer(from, to, tokenId, false);\n        emit ERC721ATransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    )\n        external\n        virtual\n        unfrozenTokenOnly(tokenId)\n        registeredSenderOnly(to)\n        registeredAddressOnly(to)\n    {\n        _transfer(from, to, tokenId, false);\n        emit ERC721ATransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        external\n        virtual\n        unfrozenTokenOnly(tokenId)\n        registeredSenderOnly(to)\n        registeredAddressOnly(to)\n    {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    )\n        public\n        virtual\n        registeredAddressOnly(to)\n        unfrozenTokenOnly(tokenId)\n        registeredSenderOnly(to)\n    {\n        _transfer(from, to, tokenId, false);\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\n            revert IdentitySystemStorage.TransferToNonERC721ReceiverImplementer();\n        }\n        emit ERC721ATransfer(from, to, tokenId, _data);\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._mint(msg.sender, to, quantity, _data, safe);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bool _force\n    ) internal {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._transfer(msg.sender, from, to, tokenId, _force);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage._burn(_storage._ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId, address owner) internal {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        _storage.erc721Contract._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address().\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        return\n            IdentitySystemStorage._checkOnERC721Received(\n                msg.sender,\n                from,\n                to,\n                tokenId,\n                _data\n            );\n    }\n\n    address private _delegatedMinter;\n    mapping(uint256 => bool) private _frozen;\n\n    constructor() {}\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     *\n     * @param tokenID uint256 ID of the token to be transferred\n     */\n    modifier unfrozenTokenOnly(uint256 tokenID) {\n        require(!_frozen[tokenID], \"ERC721: token is frozen\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier minterOnly() {\n        require(\n            _msgSender() == _delegatedMinter || _msgSender() == address(this),\n            \"ERC721: caller is not the delegated minter\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than a registered sender or the contract itself.\n     */\n    modifier registeredSenderOnly(address to) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        bool isV = _storage.isVerified(_msgSender());\n\n        require( isV || _msgSender() == address(this),\n            \"ERC721: caller is not registered or not the contract itself\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if the address is not registered or not the contract itself.\n     *\n     * @param _address address to check if registered\n     */\n    modifier registeredAddressOnly(address _address) {\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n        bool isV = _storage.isVerified(_address);\n\n        require(isV || _address == address(this),\n            \"ERC721: address is not registered or not the contract itself\"\n        );\n        _;\n    }\n\n    /**\n     *\n     * @dev Throws if called by any account other than the owner.\n     */\n    function setDelegatedMinter(\n        address _newDelegatedMinter\n    ) external returns (bool) {\n        require(\n            _msgSender() == _delegatedMinter || _delegatedMinter == address(0),\n            \"ERC721: caller is not the delegated minter\"\n        );\n        _delegatedMinter = _newDelegatedMinter;\n        return true;\n    }\n\n    /**\n     *\n     * @dev Returns the address of the current delegated minter.\n     */\n    function delegatedMinter() external view returns (address) {\n        return _delegatedMinter;\n    }\n\n    /**\n     *\n     * @dev Returns true if the token is frozen, and false otherwise.\n     *\n     * @param tokenID uint256 ID of the token to be transferred\n     */\n    function _isApprovedOrOwner(\n        address _address,\n        uint256 tokenID\n    ) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        bool isOwner = _storage.erc721Contract._ownerships[tokenID].addr ==\n            _address;\n        bool isApproved = _storage.erc721Contract._tokenApprovals[tokenID] ==\n            _address;\n        return isOwner || isApproved;\n    }\n\n    /**\n     * @dev See {IERC721A-getApproved}.\n     */\n    function forcedTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bool) {\n\n        IdentitySystemStorage.IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\n\n        // Check if the token exists\n        require(_storage._exists(_tokenId), \"ERC721: token does not exist\");\n\n        // Check if _from is the current owner\n        address currentOwner = _storage._ownerOf(_tokenId);\n        require(currentOwner == _from, \"ERC721: transfer from incorrect owner\");\n\n        // Perform the transfer\n        _storage._transfer(msg.sender, _from, _to, _tokenId, true);\n        emit ERC721ATransfer(_from, _to, _tokenId, _data);\n        return true;\n    }\n\n\n    function mint(\n        address _to,\n        bytes calldata data\n    ) external override minterOnly returns (uint256 tokenId) {\n        _mint(_to, 1, data, true);\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        tokenId = _storage.erc721Contract._currentIndex;\n        emit Mint(_to, tokenId);\n    }\n\n    function burn(\n        uint256 _tokenId\n    ) external virtual override minterOnly returns (bool) {\n        _burn(_tokenId);\n        emit Burn(msg.sender, _tokenId);\n        return true;\n    }\n\n\n    function _freeze(uint256 tokenID) internal {\n        // check to see if the user is the owner of the token\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenID),\n            \"ERC721: caller is not owner nor approved\"\n        );\n        _frozen[tokenID] = true;\n    }\n\n    function freeze(uint256 tokenID) external override minterOnly {\n        // check to see if the user is the owner of the token\n        _freeze(tokenID);\n    }\n\n    function release(uint256 tokenID) external override minterOnly {\n        require(\n            _msgSender() == _delegatedMinter,\n            \"ERC721: caller is not the delegated minter\"\n        );\n        _frozen[tokenID] = false;\n    }\n\n    function tokensOfOwner(\n        address owner\n    ) external view returns (uint256[] memory) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.tokensOfOwner(owner);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view virtual returns (uint256) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view virtual returns (uint256) {\n        IdentitySystemStorage.IdentitySystem\n            storage _storage = IdentitySystemStorage.diamondStorage();\n        return _storage.tokenByIndex(index);\n    }\n\n}\n"
    },
    "contracts/tokens/ERC721/ERC721PermissionedTokenWithClaimsFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721PermissionedTokenFacet.sol\";\nimport \"../../identity/IdentityStorage.sol\";\nimport \"../../interfaces/IClaim.sol\";\nimport \"../../interfaces/IIdentityRegistry.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract ERC721PermissionedTokenWithClaimsFacet is ERC721PermissionedTokenFacet {\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\n\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed claimType, address indexed issuer, uint256 signatureType, bytes32 signature, bytes claim, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    function addClaim(\n        uint256 tokenId,\n        uint256 _claimType,\n        address issuer\n    ) public returns (bytes32 claimId) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(_exists(tokenId), \"ERC721: token does not exist\");\n        require(ownerOf(tokenId) == msg.sender || msg.sender == identitySystem.delegatedMinter, \"Not authorized to add claim\");\n\n        claimId = keccak256(abi.encodePacked(tokenId, _claimType, issuer));\n        Claim memory claim = Claim({\n            topic: _claimType,\n            scheme: 0,\n            issuer: issuer,\n            signature: \"\",\n            data: \"\",\n            uri: ''\n        });\n\n        identitySystem.tokenClaims[tokenId] = claim;\n        identitySystem.tokenClaimList.push(claim);\n\n        emit ClaimAdded(claimId, _claimType, issuer, 0, \"\", \"\", \"\");\n        return claimId;\n    }\n\n    function removeClaim(uint256 tokenId, bytes32 _claimId) public returns (bool success) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(_exists(tokenId), \"ERC721: token does not exist\");\n        require(ownerOf(tokenId) == msg.sender || msg.sender == identitySystem.delegatedMinter, \"Not authorized to remove claim\");\n\n        Claim memory claim = identitySystem.tokenClaims[tokenId];\n        require(claim.issuer != address(0), \"Claim does not exist\");\n\n        delete identitySystem.tokenClaims[tokenId];\n\n        // Remove claim from claimList\n        Claim[] storage claimList = identitySystem.tokenClaimList;\n        uint256 claimListLength = claimList.length;\n        for (uint256 i = 0; i < claimListLength; i++) {\n            if (keccak256(abi.encodePacked(claimList[i].topic)) == keccak256(abi.encodePacked(claim.topic))) {\n                claimList[i] = claimList[claimList.length - 1];\n                claimList.pop();\n                break;\n            }\n        }\n        emit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n        return true;\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        return IdentitySystemStorage._tokenExists(identitySystem, tokenId);\n    }\n\n    function setTokenClaimTopics(uint256 tokenId, uint256[] memory claimTopics) external onlyOwner {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(_exists(tokenId), \"ERC721: token does not exist\");\n        uint256 claimTopicsLength = claimTopics.length;\n        for (uint256 i = 0; i < claimTopicsLength; i++) {\n            identitySystem.tokenClaims[tokenId] = Claim({\n                topic: claimTopics[i],\n                scheme: 0,\n                issuer: address(this),\n                signature: \"\",\n                data: \"\",\n                uri: \"\"\n            });\n        }\n    }\n\n    function getTokenClaimTopics(uint256 tokenId) public view returns (Claim[] memory) {\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\n        require(_exists(tokenId), \"ERC721: token does not exist\");\n        Claim[] memory claimTopics = new Claim[](identitySystem.tokenClaimList.length);\n        uint256 tokenClaimListLength = identitySystem.tokenClaimList.length;\n        for (uint256 i = 0; i < tokenClaimListLength; i++) {\n            claimTopics[i] = identitySystem.tokenClaims[tokenId];\n        }\n        return claimTopics;\n    }\n\n    // function _beforeTokenTransfers(\n    //     ERC721AContract storage identitySystem,\n    //     address from,\n    //     address to,\n    //     uint256 tokenId,\n    //     uint256,\n    //     bool force\n    // ) internal view {\n\n    //     Claim memory tokenClaim = identitySystem.tokenClaims[tokenId];\n\n    //     if(force) {\n    //         return;\n    //     }\n\n    //     if (tokenClaim.topic == 0) {\n    //         // Token has no claim, check for common claims between sender and receiver\n    //         IIdentityRegistry identityRegistry = IIdentityRegistry(address(this));\n            \n    //         bool hasCommonClaim = false;\n    //         uint256 claimType = 1; // Start from claim type 1\n            \n    //         while (!hasCommonClaim) {\n    //             bool hasFromClaim = identityRegistry.hasClaim(from, claimType) || from == address(this);\n    //             if (hasFromClaim && identityRegistry.hasClaim(to, claimType)) {\n    //                 hasCommonClaim = true;\n    //             } else {\n    //                 claimType++;\n    //                 if (claimType == 0) { // Overflow, we've checked all possible claim types\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         require(hasCommonClaim, \"ERC721: sender and receiver do not have a common claim\");\n    //     } else {\n    //         // Token has a claim, check only the receiver's claim against the token's claim\n    //         require(\n    //             IIdentityRegistry(address(this)).hasClaim(to, tokenClaim.topic),\n    //             \"ERC721: receiver does not have the required claim for this token\"\n    //         );\n    //     }\n    // }\n    \n}"
    },
    "contracts/tokens/InterestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IInterest.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract InterestToken is IInterest, ERC20, Ownable {\n\n    constructor() ERC20(\"Interest Token\", \"Interest\") Ownable(msg.sender) {}\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external  onlyOwner {\n        _burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public override(ERC20, IInterest) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override(ERC20, IInterest) returns (bool) {\n        return super.transferFrom(from, to, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override(ERC20, IInterest) returns (bool) {\n        return super.approve(spender, amount);\n    }\n\n    function allowance(address owner, address spender) public view override(ERC20, IInterest) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n    function balanceOf(address account) public view override(ERC20, IInterest) returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    function totalSupply() public view override(ERC20, IInterest) returns (uint256) {\n        return super.totalSupply();\n    }\n}"
    },
    "contracts/tokens/RestrictedCollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"../identity/IdentityStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @title RestrictedCollateralToken\n * @dev A Collateral token that can be restricted to only be held by participants of a specific trade deal\n */\ncontract RestrictedCollateralToken is ICollateral, ERC20, Ownable, Initializable {\n    // The address of the Diamond contract that contains the TradeDealFacet\n    address public diamondAddress;\n    \n    // The ID of the trade deal this token is associated with\n    uint256 public tradeDealId;\n    \n    // Whether to enforce restrictions on transfers\n    bool public restrictionsEnabled;\n\n    /**\n     * @dev Constructor - creates a new RestrictedCollateralToken\n     * Note: This is only used for the implementation contract, not for the proxies\n     */\n    constructor() ERC20(\"Collateral Token\", \"Collateral\") Ownable(msg.sender) {\n        // Disable initializers for the implementation contract\n        _disableInitializers();\n    }\n    \n    /**\n     * @dev Initialize the token with the given parameters\n     * @param _diamondAddress The address of the Diamond contract\n     * @param _tradeDealId The ID of the trade deal this token is associated with\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     * @param _owner The owner of the token\n     */\n    function initialize(\n        string memory /* _name */,\n        string memory /* _symbol */,\n        address _diamondAddress,\n        uint256 _tradeDealId,\n        bool _restrictionsEnabled,\n        address _owner\n    ) external initializer {\n        _transferOwnership(_owner);\n        diamondAddress = _diamondAddress;\n        tradeDealId = _tradeDealId;\n        restrictionsEnabled = _restrictionsEnabled;\n    }\n    \n    /**\n     * @dev Set whether to enforce restrictions on transfers\n     * @param _restrictionsEnabled Whether to enforce restrictions on transfers\n     */\n    function setRestrictionsEnabled(bool _restrictionsEnabled) external onlyOwner {\n        restrictionsEnabled = _restrictionsEnabled;\n    }\n    \n    /**\n     * @dev Check if an address is allowed to hold tokens\n     * @param _address The address to check\n     * @return Whether the address is allowed to hold tokens\n     */\n    function isParticipant(address _address) public view returns (bool) {\n        // If restrictions are disabled, anyone can hold tokens\n        if (!restrictionsEnabled) {\n            return true;\n        }\n        \n        // Call the Diamond contract to check if the address is a participant in the trade deal\n        (bool success, bytes memory data) = diamondAddress.staticcall(\n            abi.encodeWithSignature(\"isTradeDealParticipant(uint256,address)\", tradeDealId, _address)\n        );\n        \n        // If the call failed, assume the address is not a participant\n        if (!success) {\n            return false;\n        }\n        \n        // Decode the result\n        return abi.decode(data, (bool));\n    }\n    \n    /**\n     * @dev Override the transfer function to enforce restrictions\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     * @return Whether the transfer was successful\n     */\n    function transfer(address to, uint256 amount) public override(ERC20, ICollateral) returns (bool) {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        return super.transfer(to, amount);\n    }\n    \n    /**\n     * @dev Override the transferFrom function to enforce restrictions\n     * @param from The address to transfer from\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     * @return Whether the transfer was successful\n     */\n    function transferFrom(address from, address to, uint256 amount) public override(ERC20, ICollateral) returns (bool) {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        return super.transferFrom(from, to, amount);\n    }\n    \n    /**\n     * @dev Mint new tokens\n     * @param to The address to mint to\n     * @param amount The amount to mint\n     */\n    function mint(address to, uint256 amount) external override onlyOwner {\n        require(!restrictionsEnabled || isParticipant(to), \"RestrictedCollateralToken: recipient is not a participant\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Burn tokens\n     * @param from The address to burn from\n     * @param amount The amount to burn\n     */\n    function burn(address from, uint256 amount) external override onlyOwner {\n        _burn(from, amount);\n    }\n    \n    /**\n     * @dev Override the approve function to maintain interface compatibility\n     * @param spender The address to approve\n     * @param amount The amount to approve\n     * @return Whether the approval was successful\n     */\n    function approve(address spender, uint256 amount) public override(ERC20, ICollateral) returns (bool) {\n        return super.approve(spender, amount);\n    }\n    \n    /**\n     * @dev Override the allowance function to maintain interface compatibility\n     * @param owner The owner address\n     * @param spender The spender address\n     * @return The allowance\n     */\n    function allowance(address owner, address spender) public view override(ERC20, ICollateral) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n    \n    /**\n     * @dev Override the balanceOf function to maintain interface compatibility\n     * @param account The account to check\n     * @return The balance\n     */\n    function balanceOf(address account) public view override(ERC20, ICollateral) returns (uint256) {\n        return super.balanceOf(account);\n    }\n    \n    /**\n     * @dev Override the totalSupply function to maintain interface compatibility\n     * @return The total supply\n     */\n    function totalSupply() public view override(ERC20, ICollateral) returns (uint256) {\n        return super.totalSupply();\n    }\n}"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {        \n\n    }\n\n}\n"
    },
    "contracts/utilities/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../interfaces/IControllable.sol\";\r\n\r\n// control me baby\r\nabstract contract Controllable is IControllable {\r\n    mapping(address => bool) internal _controllers;\r\n\r\n    /**\r\n     * @dev Throws if called by any account not in authorized list\r\n     */\r\n    modifier onlyController() virtual {\r\n        require(\r\n            _controllers[msg.sender] == true || address(this) == msg.sender,\r\n            \"caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an address allowed to control this contract\r\n     */\r\n    function addController(address _controller)\r\n        external\r\n        override\r\n        onlyController\r\n    {\r\n        _addController(_controller);\r\n    }\r\n    function _addController(address _controller) internal {\r\n        _controllers[_controller] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if this address is a controller\r\n     */\r\n    function isController(address _address)\r\n        external\r\n        view\r\n        override\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _isController(_address);\r\n    }\r\n    function _isController(address _address)\r\n        internal view\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _controllers[_address];\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the sender address from the list of controllers\r\n     */\r\n    function relinquishControl() external override onlyController {\r\n        _relinquishControl();\r\n    }\r\n    function _relinquishControl() internal onlyController{\r\n        delete _controllers[msg.sender];\r\n    }\r\n}\r\n"
    },
    "contracts/utilities/InterfaceChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/interfaces/IERC1155.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nlibrary InterfaceChecker {\n    function isERC1155(address check) internal view returns(bool) {\n        return IERC165(check).supportsInterface(type(IERC1155).interfaceId);\n    }\n    function isERC721(address check) internal view returns(bool) {\n        return IERC165(check).supportsInterface(type(IERC721).interfaceId);\n    }\n    function isERC20(address check) internal view returns(bool) {\n        return IERC165(check).supportsInterface(type(IERC20).interfaceId);\n    }\n}\n"
    },
    "contracts/utilities/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/LibDiamond.sol\";\n\ncontract Modifiers {\n\n    modifier onlyOwner() {\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\n            \"not authorized to call function\");\n        _;\n    }\n\n    // Removed diamondOwner() function to avoid selector collision.\n    // Use owner() from OwnershipFacet (IERC173) instead.\n\n}"
    },
    "contracts/utilities/MultipartData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/SVGTemplatesLib.sol\";\n\nimport \"../interfaces/IMultiPart.sol\";\n\nabstract contract MultipartData  {\n    /// @notice add a new multipart to the contract\n    /// @param _data the data of the multipart\n    function _addData(bytes memory _data)\n        internal returns (uint256 _index) {\n        _index = SVGTemplatesLib.svgStorage().multiPart.data_.length;\n        SVGTemplatesLib.svgStorage().multiPart.data_.push(_data);\n    }\n\n    /// @notice get the data of the given index\n    /// @param _index the index of the data\n    function _getData(uint256 _index)\n        internal view  returns (bytes memory data) {\n        data = SVGTemplatesLib.svgStorage().multiPart.data_[_index];\n    }\n\n    /// @notice get the data as a string\n    function _fromBytes() internal view returns (string memory output) {\n        string memory result = \"\";\n        uint256 dataLength = SVGTemplatesLib.svgStorage().multiPart.data_.length;\n        for (uint256 i = 0; i < dataLength; i++) {\n            result = string(abi.encodePacked(result, SVGTemplatesLib.svgStorage().multiPart.data_[i]));\n        }\n        output = result;\n    }\n\n    /// @notice get the data as a  bytes array\n    function data__() internal view returns (bytes[] storage) {\n        return SVGTemplatesLib.svgStorage().multiPart.data_;\n    }\n\n    /// @notice clear the contents of the data array\n    function _clear() internal {\n        delete SVGTemplatesLib.svgStorage().multiPart.data_;\n    }\n}"
    },
    "contracts/utilities/SVGManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../utilities/Controllable.sol\";\nimport \"../interfaces/ISVG.sol\";\n\nimport \"../interfaces/IStrings.sol\";\n\nimport \"../libraries/StringsLib.sol\";\nimport \"../libraries/SVGTemplatesLib.sol\";\n\ncontract SVGManager is Controllable {\n\n    using SVGTemplatesLib for SVGTemplatesContract;\n\n    event SVGTemplateCreated(string name, address template);\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @notice get all the svg namea in the contract\n    function svgs() external view returns (string[] memory) {\n        return SVGTemplatesLib.svgStorage().svgTemplates._svgs();\n    }\n\n    /// @notice get the svg address of the given svg name. does not mean the file exists\n    function svgAddress(string memory _name) external view returns (address _svgAddress) {\n        _svgAddress = SVGTemplatesLib.svgStorage().svgTemplates._svgAddress(_name);\n    }\n\n    /// @notice get the svg data of the given svg name as a string\n    function svgString(string memory _name) external view returns (string memory data_) {\n\n        try SVGTemplate(SVGTemplatesLib.svgStorage().svgTemplates._svgAddress(_name)).svgString() returns (string memory _data) {\n            data_ = _data;\n        } catch (bytes memory) {}\n    }\n\n    /// @notice add a new gem pool\n    function createSVG(address sender, string memory _name) external onlyController returns(address _tplAddress) {\n\n        _tplAddress = SVGTemplatesLib.svgStorage().svgTemplates._createSVG(sender, _name);\n        emit SVGTemplateCreated(_name, _tplAddress);\n    }\n}"
    },
    "contracts/utilities/SVGTemplate.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../utilities/MultipartData.sol\";\n\nimport \"../libraries/StringsLib.sol\";\nimport \"../libraries/SVGTemplatesLib.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @notice a single SVG image\ncontract SVGTemplate is MultipartData, Ownable, Initializable {\n\n    event SVGImageAdded(address indexed _from, address indexed _to, string _name, string _data);\n    event SVGImagePartAdded(address indexed _from, address indexed _to, string _name, string _data);\n\n    constructor() Ownable(msg.sender) {}\n\n    function initialize(string memory _name, string[] memory _svg) external initializer {\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        ds.name_ = _name;\n        for(uint i = 0; i < _svg.length; i++) {\n            ds.data_.push(bytes(_svg[i]));\n        }\n    }\n\n    /// @notice the name of the svg\n    function svgName() external view returns (string memory _name) {\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        _name = ds.name_;\n    }\n\n    /// @notice the data of the svg\n    function svgString() external view returns (string memory _data) {\n        _data = _fromBytes();\n    }\n\n    /// @notice the data of the svg\n    function svgBytes() external view returns (bytes[] memory _data) {\n        _data = data__();\n    }\n    \n    /// @notice clear the data of the svg\n    function clear() external onlyOwner {\n        _clear();\n    }\n\n    /// @notice add data to the end of the data\n    function add(string memory _data) external onlyOwner returns (uint256 _index) {\n        _index = _addData(bytes(_data));\n        emit SVGImagePartAdded(msg.sender, address(this), SVGTemplatesLib.svgStorage().multiPart.name_, _data);\n    }\n\n    /// @notice add all SVG lines at\n    function addAll(string[] memory _data) external onlyOwner returns (uint256 _count) {\n        for(uint256 i = 0; i < _data.length; i++) {\n            _addData(bytes(_data[i]));\n        }\n        _count = _data.length;\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        emit SVGImageAdded(msg.sender, address(this), ds.name_, _fromBytes());\n    }\n\n    /// @notice get the svg, replacing the data with the data from the given replacements\n    function buildSVG(Replacement[] memory replacements) external view returns (string memory) {\n        return StringsLib.replace(data__(), replacements);\n    }\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 11
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}