{
  "address": "0xDBf79b6eA80E9E77124B4cb8aFD5A3d892dAD868",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "initialBalance",
          "type": "uint256"
        }
      ],
      "name": "CarbonCreditsInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "remainingBalance",
          "type": "uint256"
        }
      ],
      "name": "CarbonCreditsRetired",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "initialBalances",
          "type": "uint256[]"
        }
      ],
      "name": "batchInitializeCarbonCredits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        }
      ],
      "name": "getAllCarbonCreditBalances",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getCarbonCreditBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getCarbonCreditStatus",
      "outputs": [
        {
          "internalType": "enum CarbonCreditStatus",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "initialBalance",
          "type": "uint256"
        }
      ],
      "name": "initializeCarbonCredit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "retireCarbonCredits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6505b51aece96f0b06ce20fc513da5d7c7ffcef202987a935e1980820e8a8997",
  "receipt": {
    "to": null,
    "from": "0x9508f0Da19eC1C52D9C52611e4433159492bb93b",
    "contractAddress": "0xDBf79b6eA80E9E77124B4cb8aFD5A3d892dAD868",
    "transactionIndex": 47,
    "gasUsed": "879957",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9ef661d0bed618201515b839ea899f0918d2529705809739e4976b3adb079517",
    "transactionHash": "0x6505b51aece96f0b06ce20fc513da5d7c7ffcef202987a935e1980820e8a8997",
    "logs": [],
    "blockNumber": 26013724,
    "cumulativeGasUsed": "4249319",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "f3692121488f56f72e7047b22b2520f2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"}],\"name\":\"CarbonCreditsInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"name\":\"CarbonCreditsRetired\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"initialBalances\",\"type\":\"uint256[]\"}],\"name\":\"batchInitializeCarbonCredits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getAllCarbonCreditBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCarbonCreditBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCarbonCreditStatus\",\"outputs\":[{\"internalType\":\"enum CarbonCreditStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"}],\"name\":\"initializeCarbonCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retireCarbonCredits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Carbon credits are a mechanism to track and retire environmental credits      represented as balances attached to ERC721 tokens. This facet implements      the ICarbonCredit interface and leverages the CarbonCreditLib for storage      management. Carbon credits can be initialized with balances and then retired,      which represents their use for offsetting carbon emissions.\",\"events\":{\"CarbonCreditsInitialized(uint256,uint256)\":{\"params\":{\"initialBalance\":\"The initial balance of carbon credits\",\"tokenId\":\"The ID of the ERC721 token\"}},\"CarbonCreditsRetired(uint256,uint256,uint256)\":{\"params\":{\"amount\":\"The amount of carbon credits retired\",\"remainingBalance\":\"The remaining balance of carbon credits for the token\",\"tokenId\":\"The ID of the ERC721 token\"}}},\"kind\":\"dev\",\"methods\":{\"batchInitializeCarbonCredits(uint256[],uint256[])\":{\"custom:emission\":\"Emits CarbonCreditsInitialized event for each token individually\",\"details\":\"Batch version of initializeCarbonCredit to save gas and transaction costs when      setting up multiple tokens at once. Each token is verified to exist before initialization.      This function is more efficient than calling initializeCarbonCredit multiple times.\",\"params\":{\"initialBalances\":\"An array of initial balances corresponding to the token IDs\",\"tokenIds\":\"An array of ERC721 token IDs to initialize\"}},\"getAllCarbonCreditBalances(uint256[])\":{\"details\":\"Efficiently retrieves balances for multiple tokens at once to minimize      the number of external calls needed. This is a gas-saving alternative to      calling getCarbonCreditBalance multiple times. Returns 0 for any token      that doesn't exist or hasn't been initialized with carbon credits.\",\"params\":{\"tokenIds\":\"An array of ERC721 token IDs to query\"},\"returns\":{\"_0\":\"An array of carbon credit balances in the same order as the input tokenIds\"}},\"getCarbonCreditBalance(uint256)\":{\"details\":\"Returns the amount of carbon credits available to be retired for a given token.      Will return 0 if the token doesn't exist or hasn't been initialized with credits.\",\"params\":{\"tokenId\":\"The ID of the ERC721 token\"},\"returns\":{\"_0\":\"The current balance of carbon credits for the token\"}},\"getCarbonCreditStatus(uint256)\":{\"details\":\"Returns an enum value representing the token's carbon credit status:      - NONE: The token has not been initialized with any carbon credits      - ACTIVE: The token has carbon credits available for retirement      - RETIRED: All carbon credits for the token have been retired\",\"params\":{\"tokenId\":\"The ID of the ERC721 token\"},\"returns\":{\"_0\":\"Status enum representing the carbon credit state for the token\"}},\"initializeCarbonCredit(uint256,uint256)\":{\"custom:security\":\"Non-reentrant due to direct storage manipulation\",\"details\":\"This function can only be called by the contract owner to set up initial carbon credit balances      for ERC721 tokens. It ensures the token exists and hasn't already been initialized with a balance.      Carbon credits cannot be re-initialized once set.\",\"params\":{\"initialBalance\":\"The initial balance of carbon credits (must be greater than zero)\",\"tokenId\":\"The ID of the ERC721 token\"}},\"retireCarbonCredits(uint256,uint256)\":{\"custom:emission\":\"This operation emits CarbonCreditsRetired event with remaining balance\",\"details\":\"This function allows the token owner to permanently retire (use) carbon credits,      which can represent offsetting carbon emissions in real-world applications.      Once credits are retired, they cannot be recovered or reused. The function      ensures the token has sufficient balance before proceeding with the retirement.\",\"params\":{\"amount\":\"The amount of carbon credits to retire (must be a whole number)\",\"tokenId\":\"The ID of the ERC721 token\"}}},\"title\":\"CarbonCreditFacet\",\"version\":1},\"userdoc\":{\"events\":{\"CarbonCreditsInitialized(uint256,uint256)\":{\"notice\":\"Event emitted when carbon credits are initialized\"},\"CarbonCreditsRetired(uint256,uint256,uint256)\":{\"notice\":\"Event emitted when carbon credits are retired\"}},\"kind\":\"user\",\"methods\":{\"batchInitializeCarbonCredits(uint256[],uint256[])\":{\"notice\":\"Initialize carbon credit balances for multiple ERC721 tokens in a single transaction\"},\"getAllCarbonCreditBalances(uint256[])\":{\"notice\":\"Get the carbon credit balances for multiple ERC721 tokens in a single call\"},\"getCarbonCreditBalance(uint256)\":{\"notice\":\"Get the current carbon credit balance for an ERC721 token\"},\"getCarbonCreditStatus(uint256)\":{\"notice\":\"Get the status of carbon credits for an ERC721 token\"},\"initializeCarbonCredit(uint256,uint256)\":{\"notice\":\"Initialize carbon credit balance for an ERC721 token\"},\"retireCarbonCredits(uint256,uint256)\":{\"notice\":\"Retire carbon credits for an ERC721 token\"}},\"notice\":\"This contract manages carbon credits associated with ERC721 tokens\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/CarbonCreditFacet.sol\":\"CarbonCreditFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":11},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xc4d7ebf63eb2f6bf3fee1b6c0ee775efa9f31b4843a5511d07eea147e212932d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5dc63d1c6a12fe1b17793e1745877b2fcbe1964c3edfd0a482fac21ca8f18261\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/facets/CarbonCreditFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/ICarbonCredit.sol\\\";\\nimport \\\"../libraries/CarbonCreditLib.sol\\\";\\nimport \\\"../utilities/Modifiers.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\n\\n/// @title CarbonCreditFacet\\n/// @notice This contract manages carbon credits associated with ERC721 tokens\\n/// @dev Carbon credits are a mechanism to track and retire environmental credits\\n///      represented as balances attached to ERC721 tokens. This facet implements\\n///      the ICarbonCredit interface and leverages the CarbonCreditLib for storage\\n///      management. Carbon credits can be initialized with balances and then retired,\\n///      which represents their use for offsetting carbon emissions.\\ncontract CarbonCreditFacet is ICarbonCredit, Modifiers {\\n    using CarbonCreditLib for CarbonCreditLib.CarbonCreditStorage;\\n\\n    /// @notice Restricts function access to the owner of the specified ERC721 token\\n    /// @dev Uses the IERC721 interface to verify ownership of the token\\n    /// @param tokenId The ID of the ERC721 token whose owner is being checked\\n    modifier onlyTokenOwner(uint256 tokenId) {\\n        require(msg.sender == IERC721(address(this)).ownerOf(tokenId), \\\"Only token owner can call this function\\\");\\n        _;\\n    }\\n\\n    /// @notice Initialize carbon credit balance for an ERC721 token\\n    /// @dev This function can only be called by the contract owner to set up initial carbon credit balances\\n    ///      for ERC721 tokens. It ensures the token exists and hasn't already been initialized with a balance.\\n    ///      Carbon credits cannot be re-initialized once set.\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param initialBalance The initial balance of carbon credits (must be greater than zero)\\n    /// @custom:security Non-reentrant due to direct storage manipulation\\n    function initializeCarbonCredit(uint256 tokenId, uint256 initialBalance) external override onlyOwner {\\n        // Validate inputs\\n        require(tokenId > 0, \\\"CARBON_CREDIT: INVALID_TOKEN_ID - Token ID must be greater than zero\\\");\\n        require(initialBalance > 0, \\\"CARBON_CREDIT: INVALID_BALANCE - Initial balance must be greater than zero\\\");\\n        \\n        // Check that the token exists before initializing\\n        require(IERC721(address(this)).ownerOf(tokenId) != address(0), \\\"CARBON_CREDIT: NONEXISTENT_TOKEN - Token does not exist\\\");\\n        \\n        // Ensure token isn't already initialized with a balance\\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        require(s.getBalance(tokenId) == 0, \\\"CARBON_CREDIT: ALREADY_INITIALIZED - Token already has a carbon credit balance\\\");\\n        \\n        // Initialize the balance\\n        s.initializeBalance(tokenId, initialBalance);\\n        \\n        emit CarbonCreditsInitialized(tokenId, initialBalance);\\n    }\\n\\n    /// @notice Retire carbon credits for an ERC721 token\\n    /// @dev This function allows the token owner to permanently retire (use) carbon credits,\\n    ///      which can represent offsetting carbon emissions in real-world applications.\\n    ///      Once credits are retired, they cannot be recovered or reused. The function\\n    ///      ensures the token has sufficient balance before proceeding with the retirement.\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param amount The amount of carbon credits to retire (must be a whole number)\\n    /// @custom:emission This operation emits CarbonCreditsRetired event with remaining balance\\n    function retireCarbonCredits(uint256 tokenId, uint256 amount) external override onlyTokenOwner(tokenId) {\\n        // Validate inputs\\n        require(tokenId > 0, \\\"CARBON_CREDIT: INVALID_TOKEN_ID - Token ID must be greater than zero\\\");\\n        require(amount > 0, \\\"CARBON_CREDIT: INVALID_AMOUNT - Amount must be greater than zero\\\");\\n        \\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        \\n        // Check that the token has enough balance\\n        uint256 currentBalance = s.getBalance(tokenId);\\n        require(currentBalance >= amount, \\\"CARBON_CREDIT: INSUFFICIENT_BALANCE - Not enough carbon credits available\\\");\\n        \\n        // Retire the credits\\n        s.retireCredits(tokenId, amount);\\n        uint256 remainingBalance = s.getBalance(tokenId);\\n        \\n        emit CarbonCreditsRetired(tokenId, amount, remainingBalance);\\n    }\\n\\n    /// @notice Get the current carbon credit balance for an ERC721 token\\n    /// @dev Returns the amount of carbon credits available to be retired for a given token.\\n    ///      Will return 0 if the token doesn't exist or hasn't been initialized with credits.\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @return The current balance of carbon credits for the token\\n    function getCarbonCreditBalance(uint256 tokenId) external view override returns (uint256) {\\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        return s.getBalance(tokenId);\\n    }\\n\\n    /// @notice Get the status of carbon credits for an ERC721 token\\n    /// @dev Returns an enum value representing the token's carbon credit status:\\n    ///      - NONE: The token has not been initialized with any carbon credits\\n    ///      - ACTIVE: The token has carbon credits available for retirement\\n    ///      - RETIRED: All carbon credits for the token have been retired\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @return Status enum representing the carbon credit state for the token\\n    function getCarbonCreditStatus(uint256 tokenId) external view override returns (CarbonCreditStatus) {\\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        return s.getCarbonCreditStatus(tokenId);\\n    }\\n\\n    /// @notice Initialize carbon credit balances for multiple ERC721 tokens in a single transaction\\n    /// @dev Batch version of initializeCarbonCredit to save gas and transaction costs when\\n    ///      setting up multiple tokens at once. Each token is verified to exist before initialization.\\n    ///      This function is more efficient than calling initializeCarbonCredit multiple times.\\n    /// @param tokenIds An array of ERC721 token IDs to initialize\\n    /// @param initialBalances An array of initial balances corresponding to the token IDs\\n    /// @custom:emission Emits CarbonCreditsInitialized event for each token individually\\n    function batchInitializeCarbonCredits(uint256[] calldata tokenIds, uint256[] calldata initialBalances) external override onlyOwner {\\n        require(tokenIds.length == initialBalances.length, \\\"Array lengths must match\\\");\\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        \\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            // Check that the token exists before initializing\\n            require(IERC721(address(this)).ownerOf(tokenIds[i]) != address(0), \\\"Token does not exist\\\");\\n            \\n            s.initializeBalance(tokenIds[i], initialBalances[i]);\\n            emit CarbonCreditsInitialized(tokenIds[i], initialBalances[i]);\\n        }\\n    }\\n\\n    /// @notice Get the carbon credit balances for multiple ERC721 tokens in a single call\\n    /// @dev Efficiently retrieves balances for multiple tokens at once to minimize\\n    ///      the number of external calls needed. This is a gas-saving alternative to\\n    ///      calling getCarbonCreditBalance multiple times. Returns 0 for any token\\n    ///      that doesn't exist or hasn't been initialized with carbon credits.\\n    /// @param tokenIds An array of ERC721 token IDs to query\\n    /// @return An array of carbon credit balances in the same order as the input tokenIds\\n    function getAllCarbonCreditBalances(uint256[] calldata tokenIds) external view override returns (uint256[] memory) {\\n        CarbonCreditLib.CarbonCreditStorage storage s = CarbonCreditLib.carbonCreditStorage();\\n        uint256[] memory balances = new uint256[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            balances[i] = s.getBalance(tokenIds[i]);\\n        }\\n        return balances;\\n    }\\n}\",\"keccak256\":\"0x3ec1f9272a45f8a4070c5ee3277656ebf1f075a377650c23fe1beff32b0b96c1\",\"license\":\"MIT\"},\"contracts/interfaces/ICarbonCredit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { CarbonCreditStatus } from \\\"../libraries/CarbonCreditLib.sol\\\";\\n\\n/// @title ICarbonCredit\\n/// @notice Interface for managing carbon credits associated with ERC721 tokens\\ninterface ICarbonCredit {\\n    /// @notice Event emitted when carbon credits are initialized\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param initialBalance The initial balance of carbon credits\\n    event CarbonCreditsInitialized(uint256 indexed tokenId, uint256 initialBalance);\\n\\n    /// @notice Event emitted when carbon credits are retired\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param amount The amount of carbon credits retired\\n    /// @param remainingBalance The remaining balance of carbon credits for the token\\n    event CarbonCreditsRetired(uint256 indexed tokenId, uint256 amount, uint256 remainingBalance);\\n\\n    /// @notice Initialize carbon credit balance for an ERC721 token\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param initialBalance The initial balance of carbon credits\\n    function initializeCarbonCredit(uint256 tokenId, uint256 initialBalance) external;\\n\\n    /// @notice Retire carbon credits for an ERC721 token\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @param amount The amount of carbon credits to retire (must be a whole number)\\n    function retireCarbonCredits(uint256 tokenId, uint256 amount) external;\\n\\n    /// @notice Get the current carbon credit balance for an ERC721 token\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @return The current balance of carbon credits for the token\\n    function getCarbonCreditStatus(uint256 tokenId) external view returns (CarbonCreditStatus);\\n\\n    /// @notice Get the current carbon credit balance for an ERC721 token\\n    /// @param tokenId The ID of the ERC721 token\\n    /// @return The current balance of carbon credits for the token\\n    function getCarbonCreditBalance(uint256 tokenId) external view returns (uint256);\\n\\n    /// @notice Initialize carbon credit balances for multiple ERC721 tokens\\n    /// @param tokenIds An array of ERC721 token IDs\\n    /// @param initialBalances An array of initial balances corresponding to the token IDs\\n    function batchInitializeCarbonCredits(uint256[] calldata tokenIds, uint256[] calldata initialBalances) external;\\n\\n    /// @notice Get the carbon credit balances for multiple ERC721 tokens\\n    /// @param tokenIds An array of ERC721 token IDs\\n    /// @return An array of carbon credit balances corresponding to the token IDs\\n    function getAllCarbonCreditBalances(uint256[] calldata tokenIds) external view returns (uint256[] memory);\\n}\",\"keccak256\":\"0xe1eb41500b12cc35ca1e6595e0b88f2faa33c06141d919653d906bdeeb09a917\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n    \\r\\n    /// @notice Propose an upgrade to be executed after the timelock period\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    function proposeDiamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n    \\r\\n    /// @notice Execute a previously proposed upgrade after the timelock period\\r\\n    function executeDiamondCut() external;\\r\\n    \\r\\n    /// @notice Cancel a proposed upgrade\\r\\n    function cancelDiamondCut() external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n    event DiamondCutProposed(address indexed proposer, uint256 indexed proposalTime, uint256 executionTime);\\r\\n    event DiamondCutCancelled(address indexed canceller);\\r\\n}\\r\\n\",\"keccak256\":\"0x340a039f0dd63cf19bc669551feec28879457d8b741711ef3513168d620f11bc\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x84fe28f479bf96f1819514dd8493ae15955eda0dbabcbb5f24c3c935075a31d4\",\"license\":\"MIT\"},\"contracts/libraries/CarbonCreditLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum CarbonCreditStatus {\\n    ACTIVE,\\n    RETIRED\\n}\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\n\\nlibrary CarbonCreditLib {\\n    struct CarbonCreditStorage {\\n        mapping(uint256 => uint256) tokenBalances;\\n    }\\n\\n    bytes32 constant CARBON_CREDIT_STORAGE_POSITION = keccak256(\\\"diamond.standard.carbon.credit.storage\\\");\\n\\n    function carbonCreditStorage() internal pure returns (CarbonCreditStorage storage cs) {\\n        bytes32 position = CARBON_CREDIT_STORAGE_POSITION;\\n        assembly {\\n            cs.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Check if a token exists by verifying it has an owner\\n     * @param tokenId The ID of the token to check\\n     * @return true if the token exists, false otherwise\\n     */\\n    function _tokenExists(uint256 tokenId) internal view returns (bool) {\\n        try IERC721(address(this)).ownerOf(tokenId) returns (address owner) {\\n            return owner != address(0);\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function initializeBalance(CarbonCreditStorage storage self, uint256 tokenId, uint256 initialBalance) internal {\\n        require(self.tokenBalances[tokenId] == 0, \\\"Carbon credits already initialized\\\");\\n        require(_tokenExists(tokenId), \\\"Token does not exist\\\");\\n        require(initialBalance > 0, \\\"Initial balance must be greater than zero\\\");\\n        self.tokenBalances[tokenId] = initialBalance;\\n    }\\n\\n    function retireCredits(CarbonCreditStorage storage self, uint256 tokenId, uint256 amount) internal {\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\n        require(self.tokenBalances[tokenId] >= amount, \\\"Insufficient balance\\\");\\n        self.tokenBalances[tokenId] -= amount;\\n    }\\n\\n    function getBalance(CarbonCreditStorage storage self, uint256 tokenId) internal view returns (uint256) {\\n        return self.tokenBalances[tokenId];\\n    }\\n\\n    function getCarbonCreditStatus(CarbonCreditStorage storage self, uint256 tokenId) internal view returns (CarbonCreditStatus) {\\n        return self.tokenBalances[tokenId] == 0 ? CarbonCreditStatus.RETIRED : CarbonCreditStatus.ACTIVE;\\n    }\\n}\",\"keccak256\":\"0x87b7dceb7b19755d557dc8c6df27404b1c745207d94119c6b7252b9151cde88a\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\"; // for IERC173 interface\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    // Upgrade proposal struct for timelock functionality\\n    struct UpgradeProposal {\\n        IDiamondCut.FacetCut[] diamondCut;\\n        address initAddress;\\n        bytes initCalldata;\\n        uint256 proposalTime;\\n        bool exists;\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n        // Timelock for upgrades (in seconds)\\n        uint256 upgradeTimelock;\\n        // Storage for the current upgrade proposal\\n        UpgradeProposal upgradeProposal;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit IERC173.OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    // Timelock constants\\n    uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days;\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n\\n    // Initialize timelock settings for upgrade proposals\\n    function initializeUpgradeTimelock(uint256 _timelock) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(ds.upgradeTimelock == 0, \\\"LibDiamond: Timelock already initialized\\\");\\n        ds.upgradeTimelock = _timelock > 0 ? _timelock : DEFAULT_UPGRADE_TIMELOCK;\\n    }\\n\\n    // Propose a diamond cut to be executed after the timelock\\n    function proposeDiamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(!ds.upgradeProposal.exists, \\\"LibDiamond: Upgrade already proposed\\\");\\n        require(ds.upgradeTimelock > 0, \\\"LibDiamond: Timelock not initialized\\\");\\n        \\n        // Create a deep copy of the diamond cut to store in the proposal\\n        IDiamondCut.FacetCut[] memory diamondCutCopy = new IDiamondCut.FacetCut[](_diamondCut.length);\\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\\n            diamondCutCopy[i] = _diamondCut[i];\\n            \\n            // Deep copy the function selectors array\\n            bytes4[] memory selectors = new bytes4[](_diamondCut[i].functionSelectors.length);\\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\\n                selectors[j] = _diamondCut[i].functionSelectors[j];\\n            }\\n            diamondCutCopy[i].functionSelectors = selectors;\\n        }\\n        \\n        // Store the proposal\\n        // Create empty array in storage first\\n        delete ds.upgradeProposal.diamondCut;\\n        \\n        // Manually copy each element and its nested arrays to storage\\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\\n            // Create a new struct in storage by pushing an empty element first\\n            ds.upgradeProposal.diamondCut.push();\\n            \\n            // Now set the values for this element's fields\\n            ds.upgradeProposal.diamondCut[i].facetAddress = _diamondCut[i].facetAddress;\\n            ds.upgradeProposal.diamondCut[i].action = _diamondCut[i].action;\\n            \\n            // For the selectors array, we need to handle it separately\\n            // Clear any existing selectors to ensure clean state\\n            delete ds.upgradeProposal.diamondCut[i].functionSelectors;\\n            \\n            // Copy each selector individually\\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\\n                ds.upgradeProposal.diamondCut[i].functionSelectors.push(_diamondCut[i].functionSelectors[j]);\\n            }\\n        }\\n        ds.upgradeProposal.initAddress = _init;\\n        ds.upgradeProposal.initCalldata = _calldata;\\n        ds.upgradeProposal.proposalTime = block.timestamp;\\n        ds.upgradeProposal.exists = true;\\n        \\n        emit IDiamondCut.DiamondCutProposed(msg.sender, block.timestamp, block.timestamp + ds.upgradeTimelock);\\n    }\\n    \\n    // Execute a proposed diamond cut after the timelock period\\n    function executeDiamondCut() internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(ds.upgradeProposal.exists, \\\"LibDiamond: No upgrade proposal exists\\\");\\n        require(\\n            block.timestamp >= ds.upgradeProposal.proposalTime + ds.upgradeTimelock,\\n            \\\"LibDiamond: Timelock period not elapsed\\\"\\n        );\\n        \\n        // Execute the diamond cut\\n        diamondCut(\\n            ds.upgradeProposal.diamondCut,\\n            ds.upgradeProposal.initAddress,\\n            ds.upgradeProposal.initCalldata\\n        );\\n        \\n        // Reset the proposal\\n        delete ds.upgradeProposal;\\n    }\\n    \\n    // Cancel a proposed diamond cut\\n    function cancelDiamondCut() internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(ds.upgradeProposal.exists, \\\"LibDiamond: No upgrade proposal exists\\\");\\n        \\n        // Reset the proposal\\n        delete ds.upgradeProposal;\\n        \\n        emit IDiamondCut.DiamondCutCancelled(msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x2bb59ec15c5218cff473ba4ae9f480fd346c4f91aff5e7a1850e0ad29e51b31b\",\"license\":\"MIT\"},\"contracts/utilities/Modifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract Modifiers {\\n\\n    modifier onlyOwner() {\\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\\n            \\\"not authorized to call function\\\");\\n        _;\\n    }\\n\\n    // Removed diamondOwner() function to avoid selector collision.\\n    // Use owner() from OwnershipFacet (IERC173) instead.\\n\\n}\",\"keccak256\":\"0xd1b5a54d763fd2a4831cbfc84d4d17a21c23c52a22e65acb3ce715f3e0f7d773\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50610ef38061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631f182973146100675780631ff275f1146100905780632a8ed06f146100a5578063543300fe146100c5578063cd86fab3146100d8578063fee99035146100eb575b600080fd5b61007a610075366004610b97565b61010c565b6040516100879190610bb0565b60405180910390f35b6100a361009e366004610c23565b61012a565b005b6100b86100b3366004610c92565b610320565b6040516100879190610cd3565b6100a36100d3366004610d16565b6103da565b6100a36100e6366004610d16565b61066d565b6100fe6100f9366004610b97565b6108c4565b604051908152602001610087565b6000806101176108db565b905061012381846108ff565b9392505050565b33610133610923565b6001600160a01b0316148061014757503033145b61016c5760405162461bcd60e51b815260040161016390610d38565b60405180910390fd5b8281146101b65760405162461bcd60e51b8152602060048201526018602482015277082e4e4c2f240d8cadccee8d0e640daeae6e840dac2e8c6d60431b6044820152606401610163565b60006101c06108db565b905060005b8481101561031857600030636352211e8888858181106101e7576101e7610d6f565b905060200201356040518263ffffffff1660e01b815260040161020c91815260200190565b602060405180830381865afa158015610229573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061024d9190610d85565b6001600160a01b0316036102735760405162461bcd60e51b815260040161016390610dae565b6102b886868381811061028857610288610d6f565b905060200201358585848181106102a1576102a1610d6f565b90506020020135846109519092919063ffffffff16565b8585828181106102ca576102ca610d6f565b90506020020135600080516020610e9e8339815191528585848181106102f2576102f2610d6f565b9050602002013560405161030891815260200190565b60405180910390a26001016101c5565b505050505050565b6060600061032c6108db565b90506000836001600160401b0381111561034857610348610ddc565b604051908082528060200260200182016040528015610371578160200160208202803683370190505b50905060005b848110156103cf576103aa86868381811061039457610394610d6f565b9050602002013584610a5190919063ffffffff16565b8282815181106103bc576103bc610d6f565b6020908102919091010152600101610377565b509150505b92915050565b336103e3610923565b6001600160a01b031614806103f757503033145b6104135760405162461bcd60e51b815260040161016390610d38565b600082116104335760405162461bcd60e51b815260040161016390610df2565b600081116104bc5760405162461bcd60e51b815260206004820152604a60248201527f434152424f4e5f4352454449543a20494e56414c49445f42414c414e4345202d60448201527f20496e697469616c2062616c616e6365206d7573742062652067726561746572606482015269207468616e207a65726f60b01b608482015260a401610163565b6040516331a9108f60e11b8152600481018390526000903090636352211e90602401602060405180830381865afa1580156104fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051f9190610d85565b6001600160a01b0316036105955760405162461bcd60e51b815260206004820152603760248201527f434152424f4e5f4352454449543a204e4f4e4558495354454e545f544f4b454e604482015276080b48151bdad95b88191bd95cc81b9bdd08195e1a5cdd604a1b6064820152608401610163565b600061059f6108db565b90506105ab8184610a51565b156106355760405162461bcd60e51b815260206004820152604e60248201527f434152424f4e5f4352454449543a20414c52454144595f494e495449414c495a60448201527f4544202d20546f6b656e20616c726561647920686173206120636172626f6e2060648201526d6372656469742062616c616e636560901b608482015260a401610163565b610640818484610951565b82600080516020610e9e8339815191528360405161066091815260200190565b60405180910390a2505050565b6040516331a9108f60e11b81526004810183905282903090636352211e90602401602060405180830381865afa1580156106ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106cf9190610d85565b6001600160a01b0316336001600160a01b03161461073f5760405162461bcd60e51b815260206004820152602760248201527f4f6e6c7920746f6b656e206f776e65722063616e2063616c6c207468697320666044820152663ab731ba34b7b760c91b6064820152608401610163565b6000831161075f5760405162461bcd60e51b815260040161016390610df2565b600082116107c5576040805162461bcd60e51b81526020600482015260248101919091527f434152424f4e5f4352454449543a20494e56414c49445f414d4f554e54202d206044820152600080516020610e7e8339815191526064820152608401610163565b60006107cf6108db565b905060006107dd8286610a51565b9050838110156108675760405162461bcd60e51b815260206004820152604960248201527f434152424f4e5f4352454449543a20494e53554646494349454e545f42414c4160448201527f4e4345202d204e6f7420656e6f75676820636172626f6e206372656469747320606482015268617661696c61626c6560b81b608482015260a401610163565b610872828686610a64565b600061087e8387610a51565b604080518781526020810183905291925087917fe3320ebc9096bdda0cb987763df59caa860417c61ac1725fa91523d1ab8b297a910160405180910390a2505050505050565b6000806108cf6108db565b90506101238184610a51565b7fa7530886f770be1a2d9f7845fb24135da6a334864119d065ed91a38a62919f7090565b6000818152602083905260408120541561091a576000610123565b60019392505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b600082815260208490526040902054156109b85760405162461bcd60e51b815260206004820152602260248201527f436172626f6e206372656469747320616c726561647920696e697469616c697a604482015261195960f21b6064820152608401610163565b6109c182610b1f565b6109dd5760405162461bcd60e51b815260040161016390610dae565b60008111610a3f5760405162461bcd60e51b815260206004820152602960248201527f496e697469616c2062616c616e6365206d7573742062652067726561746572206044820152687468616e207a65726f60b81b6064820152608401610163565b60009182526020929092526040902055565b6000908152602091909152604090205490565b60008111610aa25760405162461bcd60e51b81526020600482018190526024820152600080516020610e7e8339815191526044820152606401610163565b600082815260208490526040902054811115610af75760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b6044820152606401610163565b60008281526020849052604081208054839290610b15908490610e5c565b9091555050505050565b6040516331a9108f60e11b8152600481018290526000903090636352211e90602401602060405180830381865afa925050508015610b7a575060408051601f3d908101601f19168201909252610b7791810190610d85565b60015b610b8657506000919050565b6001600160a01b0316151592915050565b600060208284031215610ba957600080fd5b5035919050565b6020810160028310610bd257634e487b7160e01b600052602160045260246000fd5b91905290565b60008083601f840112610bea57600080fd5b5081356001600160401b03811115610c0157600080fd5b6020830191508360208260051b8501011115610c1c57600080fd5b9250929050565b60008060008060408587031215610c3957600080fd5b84356001600160401b03811115610c4f57600080fd5b610c5b87828801610bd8565b90955093505060208501356001600160401b03811115610c7a57600080fd5b610c8687828801610bd8565b95989497509550505050565b60008060208385031215610ca557600080fd5b82356001600160401b03811115610cbb57600080fd5b610cc785828601610bd8565b90969095509350505050565b602080825282518282018190526000918401906040840190835b81811015610d0b578351835260209384019390920191600101610ced565b509095945050505050565b60008060408385031215610d2957600080fd5b50508035926020909101359150565b6020808252601f908201527f6e6f7420617574686f72697a656420746f2063616c6c2066756e6374696f6e00604082015260600190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610d9757600080fd5b81516001600160a01b038116811461012357600080fd5b602080825260149082015273151bdad95b88191bd95cc81b9bdd08195e1a5cdd60621b604082015260600190565b634e487b7160e01b600052604160045260246000fd5b60208082526044908201527f434152424f4e5f4352454449543a20494e56414c49445f544f4b454e5f49442060408201527f2d20546f6b656e204944206d7573742062652067726561746572207468616e206060820152637a65726f60e01b608082015260a00190565b818103818111156103d457634e487b7160e01b600052601160045260246000fdfe416d6f756e74206d7573742062652067726561746572207468616e207a65726f181209f5a594950bcc5984235e2464fcbd7023ecf54abee8bdb3391937210426a2646970667358221220c30c7d80cee0b4b9897665bfa5400aac7513bb8f75ff4a313469da6fa6ec260f64736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c80631f182973146100675780631ff275f1146100905780632a8ed06f146100a5578063543300fe146100c5578063cd86fab3146100d8578063fee99035146100eb575b600080fd5b61007a610075366004610b97565b61010c565b6040516100879190610bb0565b60405180910390f35b6100a361009e366004610c23565b61012a565b005b6100b86100b3366004610c92565b610320565b6040516100879190610cd3565b6100a36100d3366004610d16565b6103da565b6100a36100e6366004610d16565b61066d565b6100fe6100f9366004610b97565b6108c4565b604051908152602001610087565b6000806101176108db565b905061012381846108ff565b9392505050565b33610133610923565b6001600160a01b0316148061014757503033145b61016c5760405162461bcd60e51b815260040161016390610d38565b60405180910390fd5b8281146101b65760405162461bcd60e51b8152602060048201526018602482015277082e4e4c2f240d8cadccee8d0e640daeae6e840dac2e8c6d60431b6044820152606401610163565b60006101c06108db565b905060005b8481101561031857600030636352211e8888858181106101e7576101e7610d6f565b905060200201356040518263ffffffff1660e01b815260040161020c91815260200190565b602060405180830381865afa158015610229573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061024d9190610d85565b6001600160a01b0316036102735760405162461bcd60e51b815260040161016390610dae565b6102b886868381811061028857610288610d6f565b905060200201358585848181106102a1576102a1610d6f565b90506020020135846109519092919063ffffffff16565b8585828181106102ca576102ca610d6f565b90506020020135600080516020610e9e8339815191528585848181106102f2576102f2610d6f565b9050602002013560405161030891815260200190565b60405180910390a26001016101c5565b505050505050565b6060600061032c6108db565b90506000836001600160401b0381111561034857610348610ddc565b604051908082528060200260200182016040528015610371578160200160208202803683370190505b50905060005b848110156103cf576103aa86868381811061039457610394610d6f565b9050602002013584610a5190919063ffffffff16565b8282815181106103bc576103bc610d6f565b6020908102919091010152600101610377565b509150505b92915050565b336103e3610923565b6001600160a01b031614806103f757503033145b6104135760405162461bcd60e51b815260040161016390610d38565b600082116104335760405162461bcd60e51b815260040161016390610df2565b600081116104bc5760405162461bcd60e51b815260206004820152604a60248201527f434152424f4e5f4352454449543a20494e56414c49445f42414c414e4345202d60448201527f20496e697469616c2062616c616e6365206d7573742062652067726561746572606482015269207468616e207a65726f60b01b608482015260a401610163565b6040516331a9108f60e11b8152600481018390526000903090636352211e90602401602060405180830381865afa1580156104fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051f9190610d85565b6001600160a01b0316036105955760405162461bcd60e51b815260206004820152603760248201527f434152424f4e5f4352454449543a204e4f4e4558495354454e545f544f4b454e604482015276080b48151bdad95b88191bd95cc81b9bdd08195e1a5cdd604a1b6064820152608401610163565b600061059f6108db565b90506105ab8184610a51565b156106355760405162461bcd60e51b815260206004820152604e60248201527f434152424f4e5f4352454449543a20414c52454144595f494e495449414c495a60448201527f4544202d20546f6b656e20616c726561647920686173206120636172626f6e2060648201526d6372656469742062616c616e636560901b608482015260a401610163565b610640818484610951565b82600080516020610e9e8339815191528360405161066091815260200190565b60405180910390a2505050565b6040516331a9108f60e11b81526004810183905282903090636352211e90602401602060405180830381865afa1580156106ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106cf9190610d85565b6001600160a01b0316336001600160a01b03161461073f5760405162461bcd60e51b815260206004820152602760248201527f4f6e6c7920746f6b656e206f776e65722063616e2063616c6c207468697320666044820152663ab731ba34b7b760c91b6064820152608401610163565b6000831161075f5760405162461bcd60e51b815260040161016390610df2565b600082116107c5576040805162461bcd60e51b81526020600482015260248101919091527f434152424f4e5f4352454449543a20494e56414c49445f414d4f554e54202d206044820152600080516020610e7e8339815191526064820152608401610163565b60006107cf6108db565b905060006107dd8286610a51565b9050838110156108675760405162461bcd60e51b815260206004820152604960248201527f434152424f4e5f4352454449543a20494e53554646494349454e545f42414c4160448201527f4e4345202d204e6f7420656e6f75676820636172626f6e206372656469747320606482015268617661696c61626c6560b81b608482015260a401610163565b610872828686610a64565b600061087e8387610a51565b604080518781526020810183905291925087917fe3320ebc9096bdda0cb987763df59caa860417c61ac1725fa91523d1ab8b297a910160405180910390a2505050505050565b6000806108cf6108db565b90506101238184610a51565b7fa7530886f770be1a2d9f7845fb24135da6a334864119d065ed91a38a62919f7090565b6000818152602083905260408120541561091a576000610123565b60019392505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b600082815260208490526040902054156109b85760405162461bcd60e51b815260206004820152602260248201527f436172626f6e206372656469747320616c726561647920696e697469616c697a604482015261195960f21b6064820152608401610163565b6109c182610b1f565b6109dd5760405162461bcd60e51b815260040161016390610dae565b60008111610a3f5760405162461bcd60e51b815260206004820152602960248201527f496e697469616c2062616c616e6365206d7573742062652067726561746572206044820152687468616e207a65726f60b81b6064820152608401610163565b60009182526020929092526040902055565b6000908152602091909152604090205490565b60008111610aa25760405162461bcd60e51b81526020600482018190526024820152600080516020610e7e8339815191526044820152606401610163565b600082815260208490526040902054811115610af75760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b6044820152606401610163565b60008281526020849052604081208054839290610b15908490610e5c565b9091555050505050565b6040516331a9108f60e11b8152600481018290526000903090636352211e90602401602060405180830381865afa925050508015610b7a575060408051601f3d908101601f19168201909252610b7791810190610d85565b60015b610b8657506000919050565b6001600160a01b0316151592915050565b600060208284031215610ba957600080fd5b5035919050565b6020810160028310610bd257634e487b7160e01b600052602160045260246000fd5b91905290565b60008083601f840112610bea57600080fd5b5081356001600160401b03811115610c0157600080fd5b6020830191508360208260051b8501011115610c1c57600080fd5b9250929050565b60008060008060408587031215610c3957600080fd5b84356001600160401b03811115610c4f57600080fd5b610c5b87828801610bd8565b90955093505060208501356001600160401b03811115610c7a57600080fd5b610c8687828801610bd8565b95989497509550505050565b60008060208385031215610ca557600080fd5b82356001600160401b03811115610cbb57600080fd5b610cc785828601610bd8565b90969095509350505050565b602080825282518282018190526000918401906040840190835b81811015610d0b578351835260209384019390920191600101610ced565b509095945050505050565b60008060408385031215610d2957600080fd5b50508035926020909101359150565b6020808252601f908201527f6e6f7420617574686f72697a656420746f2063616c6c2066756e6374696f6e00604082015260600190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610d9757600080fd5b81516001600160a01b038116811461012357600080fd5b602080825260149082015273151bdad95b88191bd95cc81b9bdd08195e1a5cdd60621b604082015260600190565b634e487b7160e01b600052604160045260246000fd5b60208082526044908201527f434152424f4e5f4352454449543a20494e56414c49445f544f4b454e5f49442060408201527f2d20546f6b656e204944206d7573742062652067726561746572207468616e206060820152637a65726f60e01b608082015260a00190565b818103818111156103d457634e487b7160e01b600052601160045260246000fdfe416d6f756e74206d7573742062652067726561746572207468616e207a65726f181209f5a594950bcc5984235e2464fcbd7023ecf54abee8bdb3391937210426a2646970667358221220c30c7d80cee0b4b9897665bfa5400aac7513bb8f75ff4a313469da6fa6ec260f64736f6c634300081c0033",
  "libraries": {
    "AddressSet": "0x8aB21bf41B908d9CBee3E78e97033E3916840cA8",
    "AttributeLib": "0x9d0749b64bEDB024B1AaF596c84029E67635D43c",
    "Base64": "0x8d10857B6d2bEA12d67A888F3E995ea142Db701E",
    "Bytes32Set": "0xB01Cf1Baf9ABFa5309AE3ff649B31ae87A80AE62",
    "CarbonCreditLib": "0x44520E8dA039d4D7D460f5DBF6C1eC347De53A7C",
    "DiamondFactoryLib": "0x50353159348c63A448eDAfC6d5ef81CF9C1cdE9a",
    "DiamondLib": "0x2Be86045394c8096b3b9d9449A08Cc74afEd5717",
    "ERC721AEnumerationLib": "0x6a9A6D75AECEfB8dC969D5Ef5ea3EcF57e29706d",
    "ERC721ALib": "0x8F980CBDb943c2794FdA47D82d81a71d31A815DE",
    "Identity": "0x4C6fE457018d32B9aEc2aA99F655b5aCD7d0D658",
    "IdentityFactory": "0x5c970fD1E772548Be3Dc3de62381Fd8b2b3fAb96",
    "IdentitySystemStorage": "0x05d7966Acfa90f529e3844B1d1b7702dBde7789c",
    "LibDiamond": "0x30Fb10d923CfFC1151B8CFe683A937F414854570",
    "MerkleProver": "0x6361c8F2C7Fb1498C15C5e90Ed477ee8cEeC9f5f",
    "MetadataLib": "0xEA17bE869d528F2c3e4F7cae231ebE4BE42BeB75",
    "MultiSaleLib": "0x3b12B21202DaC69552E7b1f9D4D3E31085c7a378",
    "Strings": "0x26375f3210F1F8C90f53c663AC44F3d4a86b12A6",
    "StringsLib": "0x928c0A50586514D291087403befe3540E3631ECd",
    "SVGTemplatesLib": "0xFD3DfE346d5d5c8C90313036BC1b1E3De29FCb33",
    "UInt256Set": "0x908B9bE15117446dE01d076Ecb75D9210E182D97",
    "VariablePriceLib": "0x92E3cBf7226518CF757c48446067de1485CCCcBb"
  },
  "devdoc": {
    "details": "Carbon credits are a mechanism to track and retire environmental credits      represented as balances attached to ERC721 tokens. This facet implements      the ICarbonCredit interface and leverages the CarbonCreditLib for storage      management. Carbon credits can be initialized with balances and then retired,      which represents their use for offsetting carbon emissions.",
    "events": {
      "CarbonCreditsInitialized(uint256,uint256)": {
        "params": {
          "initialBalance": "The initial balance of carbon credits",
          "tokenId": "The ID of the ERC721 token"
        }
      },
      "CarbonCreditsRetired(uint256,uint256,uint256)": {
        "params": {
          "amount": "The amount of carbon credits retired",
          "remainingBalance": "The remaining balance of carbon credits for the token",
          "tokenId": "The ID of the ERC721 token"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "batchInitializeCarbonCredits(uint256[],uint256[])": {
        "custom:emission": "Emits CarbonCreditsInitialized event for each token individually",
        "details": "Batch version of initializeCarbonCredit to save gas and transaction costs when      setting up multiple tokens at once. Each token is verified to exist before initialization.      This function is more efficient than calling initializeCarbonCredit multiple times.",
        "params": {
          "initialBalances": "An array of initial balances corresponding to the token IDs",
          "tokenIds": "An array of ERC721 token IDs to initialize"
        }
      },
      "getAllCarbonCreditBalances(uint256[])": {
        "details": "Efficiently retrieves balances for multiple tokens at once to minimize      the number of external calls needed. This is a gas-saving alternative to      calling getCarbonCreditBalance multiple times. Returns 0 for any token      that doesn't exist or hasn't been initialized with carbon credits.",
        "params": {
          "tokenIds": "An array of ERC721 token IDs to query"
        },
        "returns": {
          "_0": "An array of carbon credit balances in the same order as the input tokenIds"
        }
      },
      "getCarbonCreditBalance(uint256)": {
        "details": "Returns the amount of carbon credits available to be retired for a given token.      Will return 0 if the token doesn't exist or hasn't been initialized with credits.",
        "params": {
          "tokenId": "The ID of the ERC721 token"
        },
        "returns": {
          "_0": "The current balance of carbon credits for the token"
        }
      },
      "getCarbonCreditStatus(uint256)": {
        "details": "Returns an enum value representing the token's carbon credit status:      - NONE: The token has not been initialized with any carbon credits      - ACTIVE: The token has carbon credits available for retirement      - RETIRED: All carbon credits for the token have been retired",
        "params": {
          "tokenId": "The ID of the ERC721 token"
        },
        "returns": {
          "_0": "Status enum representing the carbon credit state for the token"
        }
      },
      "initializeCarbonCredit(uint256,uint256)": {
        "custom:security": "Non-reentrant due to direct storage manipulation",
        "details": "This function can only be called by the contract owner to set up initial carbon credit balances      for ERC721 tokens. It ensures the token exists and hasn't already been initialized with a balance.      Carbon credits cannot be re-initialized once set.",
        "params": {
          "initialBalance": "The initial balance of carbon credits (must be greater than zero)",
          "tokenId": "The ID of the ERC721 token"
        }
      },
      "retireCarbonCredits(uint256,uint256)": {
        "custom:emission": "This operation emits CarbonCreditsRetired event with remaining balance",
        "details": "This function allows the token owner to permanently retire (use) carbon credits,      which can represent offsetting carbon emissions in real-world applications.      Once credits are retired, they cannot be recovered or reused. The function      ensures the token has sufficient balance before proceeding with the retirement.",
        "params": {
          "amount": "The amount of carbon credits to retire (must be a whole number)",
          "tokenId": "The ID of the ERC721 token"
        }
      }
    },
    "title": "CarbonCreditFacet",
    "version": 1
  },
  "userdoc": {
    "events": {
      "CarbonCreditsInitialized(uint256,uint256)": {
        "notice": "Event emitted when carbon credits are initialized"
      },
      "CarbonCreditsRetired(uint256,uint256,uint256)": {
        "notice": "Event emitted when carbon credits are retired"
      }
    },
    "kind": "user",
    "methods": {
      "batchInitializeCarbonCredits(uint256[],uint256[])": {
        "notice": "Initialize carbon credit balances for multiple ERC721 tokens in a single transaction"
      },
      "getAllCarbonCreditBalances(uint256[])": {
        "notice": "Get the carbon credit balances for multiple ERC721 tokens in a single call"
      },
      "getCarbonCreditBalance(uint256)": {
        "notice": "Get the current carbon credit balance for an ERC721 token"
      },
      "getCarbonCreditStatus(uint256)": {
        "notice": "Get the status of carbon credits for an ERC721 token"
      },
      "initializeCarbonCredit(uint256,uint256)": {
        "notice": "Initialize carbon credit balance for an ERC721 token"
      },
      "retireCarbonCredits(uint256,uint256)": {
        "notice": "Retire carbon credits for an ERC721 token"
      }
    },
    "notice": "This contract manages carbon credits associated with ERC721 tokens",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}